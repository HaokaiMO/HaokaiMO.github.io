---
title: '鸟哥的 Linux 私房菜 -- 大纲与笔记'
category: Linux
tags: 
  - 'VbirdTsai Linux Tutorial'
---

这篇文章记录了鸟哥的 Linux 私房菜基础篇-第四版中每个章节的大纲，以及我通过 VirtualBox 安装 CentOS 7 后，照着鸟哥的这份教程来练习时所记的笔记。在学完鸟哥的 Linux 基础篇后，查看了鸟哥网站上关于服务器架设篇的介绍。当前鸟哥对服务器架设篇-第三版的更新只更新了前两章，在看完更新的这两章后查看了服务器架设篇-第三版的前十一章内容，其中对第二章、第五章、第十一章记了笔记。鸟哥的这份 Linux 教程比较详实，在学习 Linux 入门后，今后用到哪部分内容，如果忘了一些细节的话也可以回过头来再查看。

<!-- more -->



&nbsp;

## 基础篇目录



新手的建议：

因此这里建议想要学习 Linux 的朋友们，基础的功夫要学好，往后就不需要太麻烦人家啰！先从 Linux 的安装与指令学起。




第一部分 Linux 的规划与安装                 ： 第零章 - 第四章

第二部分 Linux 文件、目录与磁盘格式 ：第五章 - 第八章

第三部分 学习 Shell 和 Shell scripts      ：第九章 - 第十二章

第四部分 Linux 使用者管理                    ：第十三章 - 第十六章

第五部分 Linux 系统管理员                    ：第十七章 - 第二十四章

&nbsp;

来源：[鸟哥的Linux私房菜-基础学习篇目录](http://linux.vbird.org/linux_basic/) 



&nbsp;

## 第一部分 Linux 的规划与安装



### 第零章 计算机概论



0.1 计算机：辅助人脑的好工具

- 计算机硬件的五大单元
  - 输入单元、输出单元、CPU 内部的控制单元与算数逻辑单元、主存储器。
- 一切设计的起点：CPU 的架构
  - 精简指令集（Reduced Instruction Set Computer, RISC）
    - Oracle 的 SPARC 系列；IBM 的 Power Architecture（包括 PowerPC）系列；ARM Holdings 的 ARM CPU 。
  - 复杂指令集（Complex Instruction Set Computer, CISC）
    - AMD、Intel、VIA 等 x86 架构的 CPU 。
- 其它单元的设备
- 运行流程
- 计算机用途的分类
- 计算机上面常用的计算单位（容量、速度等）



0.2 个人计算机架构与相关设备组件

- 执行脑袋运算与判断的 CPU
  - CPU 的工作频率：外频与倍频
  - 32 位与 64 位的 CPU 与总线「宽度」
  - CPU 等级
  - 超线程（Hyper-Threading, HT）
- 内存
  - 多通道设计
  - DRAM 与 SRAM
  - 只读存储器（ROM）
    - BIOS (Basic Input Output System) 是一套程序，这套程序是写死到主板上面的一个内存芯片中，这个内存芯片在没有通电时也能够将数据记录下来，那就是只读存储器（Read Only Memory, ROM）。
    - 韧体（firmware）很多情况下也是使用 ROM 来进行软件的写入的。韧体像软件一样，也是一个被计算机所执行的程序。很多硬件上面都会有韧体喔！例如鸟哥常用的磁盘阵列卡、10G 的网卡、交换器设备等等！你可以简单地这么想，韧体就是绑在硬件上面的控制软件！
- 显示适配器
- 硬盘与储存设备
- 扩充卡与接口
- 主板
- 电源供应器
- 选购须知



0.3 数据表示方式

- 数字系统
- 文字编码系统



0.4 软件程序运行

- 机器程序与编译程序
- 操作系统
  - 操作系统核心（Kernel）
    - 操作系统（Operating System, OS）其实也是一组程序，这组程序的重点在于管理计算机的所有活动以及驱动系统中的所有硬件。
  - 系统呼叫（System Call）
  - 核心功能
    - 系统呼叫接口（System call interface）
    - 进程管理（Process control）
    - 内存管理（Memory management）
    - 文件系统管理（Filesystem management）
    - 装置的驱动（Device drivers）
  - 操作系统与驱动程序
- 应用程序



0.5 重点回顾



鸟哥的 Changelog: Chapter 0

- 2016-12-28：增加了 GB 与 GiB 等，区分 2 进位与 10 进位的单位辨别。
  - 在 0.1.6 的容量单位介绍中增加了一个 Tips 说明：其实，若要区分 2 进位还是 10 进位的容量，目前也经常使用 GB 与 GiB 之类的方式来辨别，GB 为 10 进位，加上 i 成为 GiB 则是 2 进位，所有的容量都可以这样处理的，包括 KiB，TiB 等等喔！



&nbsp;

### 第一章 Linux 是什么与如何学习



1.1 Linux 是什么

- Linux 是什么？操作系统/应用程序？

- Linux 之前，Unix 的历史

  - Linux 的核心是由 Linus Torvalds 在 1991 年的时候给他开发出来的。

  - 1969 年以前：一个伟大的梦想 -\- Bell，MIT 与 GE 的 Multics 系统

  - 1969 年：Ken Thompson 的小型 file server system

    - Thompson 的这个文件系统有两个重要的概念，分别是：

      - 所有的程序或系统装置都是文件；
      - 不管构建编辑器还是附属文件，所写的程序只有一个目的，且要有效地完成目标。

      这些概念在后来对 Linux 的发展有相当重要的影响喔！

    - 套一句常听到的广告词：科技始终来自于人性，当初 Thompson 会写这套 Unix 核心程序，确实想要移植一套名为「太空旅行」的游戏呢！

  - 1973 年 Unix 的正式诞生，Ritchie 等人以 C 语言写出第一个正式 Unix 核心

  - 1977 年：重要的 Unix 分支 -\- BSD 的诞生

    - 伯克利（Berkeley）大学的 Bill Joy 在取得了 Unix 的核心原始码后，着手修改成适合自己机器的版本，并且同时增加了很多工具软件与编译程序，最终将它命名为 Berkeley Software Distribution (BSD) 。这个 BSD 是 Unix 很重要的一个分支，Bill Joy 也是 Unix 业者 Sun（升阳）这家公司的创办者！Sun 公司即是以 BSD 发展的核心进行自己的商业 Unix 版本的发展的。（后来可以安装在 x86 硬件架构上面的 FreeBSD 即是 BSD 改版而来！）

      &nbsp;

  - 1979 年：重要的 System V 架构与版权宣告

    - 目前被称为纯种的 Unix 指的就是 System V 以及 BSD 这两套啰！

      &nbsp;

  - 1984 年之一：x86 架构的 Minix 操作系统开始撰写并与两年后诞生

  - 1984 年之二：GNU 计划与 FSF 基金会的成立

    - Richard Mathew Stallman (史托曼) 在 1984 年发起的 GNU 计划，对于现今的自由软件风潮，有着不可磨灭的地位！
    - 自由软件基金会（FSF, Free Software Foundation）
    - 事实上，GNU 自己开发的核心称为 hurd，是一个架构相当先进的核心。不过由于开发者在开发的过程中对于系统的要求太过于严谨，因此推出的时程一再延后，所以才有后来 Linux 的开发！

  - 1988 年：图形接口 XFree86 计划

    - 所谓的 XFree86 其实是 X Window System + Free + x86 的整合名称。
    - 为什么称图形用户接口为 X 呢？因为由英文单词来看 Window  的 W 接着就是 X 啦！意指 Window 的下一版就是了！

  - 1991 年芬兰大学生 Linus Torvalds 的一则简讯

- 关于 GNU 计划、自由软件与开放原始码
  - 自由软件的活动
  - 自由软件的版权 GNU GPL
    - 为什么要称为 GNU 呢？其实 GNU 是 GNU's Not Unix 的缩写，意思是说 GNU 并不是 Unix 啊！
  - 自由（Free）的真谛
    - Stallman 对 GPL 一直是强调 Free 的，这个 Free 的意思是这样的："Free software" is a matter of liberty, not price. To understand the concept, you should think of "free speech", not "free beer". "Free software" refers to users's freedom to run, copy, distribute, study, change, and improve the software.
  - 自由软件与商业行为
  - 开放原始码
  - 专属软件/专利软件（Close Source）
    - 相对于 Open Source 的软件会释出原始码，Close Source 的程序则仅推出可执行的二进制程序（binary program）而已。



1.2 Torvalds 的 Linux 发展

- 与 Minix 之间
- 对 386 硬件的多任务测试
- 初次释出 Linux 0.02
  - 由于 Linux 希望能够兼容于 Unix ，于是托瓦兹选择了第二个作法，修改 Linux，为了让所有的软件都可以在 Linux 上执行，于是托瓦兹开始参考标准的 POSIX 规范。
  - POSIX 是可便携式操作系统接口（Portable Operating System Interface）的缩写，重点在规范核心与应用程序之间的接口，这是由美国电器与电子工程师学会（IEEE）所发布的一项标准喔！
  - 其实托瓦兹有意无意之间经常会透露，他自己是个只喜欢（Just for Fun）的怪人！Linux 一开始也只是从托瓦兹的一个作业发展出来的玩具而已。他也说，如果 Minix 或 hurd 这两个中的任何一个系统，可以提早开发出他想要的功能与环境，也许他根本不会想要自己开发一个 Linux 哩！哇！人类智慧真是没有极限！各位啊：1) 要先有基础知识与技能；2) 有了第一点后，要用于挑战权威；3) 把你们的玩具发扬光大吧！^_^
- Linux 的发展：虚拟团队的产生
  - 单一个人维护阶段
  - 广大黑客志工加入阶段
    - 总之，托瓦兹是个很务实的人，对于 Linux 核心所欠缺的项目，他总是 “先求有且能跑，再求进一步改良” 的心态！这让 Linux 使用者与志工得到相当大的鼓励！
  - 核心功能细部分工发展阶段
- Linux 的核心版本
  - 奇数、偶数版本分类
  - 主线版本、长期维护版本（longterm version）
    - 如果你想要使用 Linux 核心来开发你的系统，那么当然要选择长期支持的版本才行！要判断你的 Linux 核心是否为长期支持的版本，可以使用 `uname -r` 来查阅核心版本，然后对照 [这个链接](https://www.kernel.org/releases.html) 来了解其对应值喔！
  - Linux 核心版本与 Linux 发布商版本
- Linux distributions
  - 因为 Linux 参考 POSIX 设计规范，于是兼容于 Unix 操作系统，故亦称之为 Unix Like 的一种。
  - 鸟哥曾在上课的时候问过同学：什么是 Unix Like 啊？其实 Unix Like 是很像 Unix 的操作系统哩！
  - 可完全安装的 Linux 发布套件
    - Linux 的出现让 GNU 计划放下了心里的一块大石头，因为 GNU 一直以来就是缺乏了核心程序，导致他们的 GNU 自由软件只能在其它的 Unix 上面跑。既然目前有 Linux 出现了，且 Linux 也用了很多 GNU 相关软件，所以 Stallman 认为 Linux 全名应该称之为 GNU/Linux 呢！
  - 各大 Linux Distributions 的主要异同：支持标准
    - 每个 Linux distributions 使用的 kernel 都是 http://www.kernel.org 所释出的，而他们所选择的软件，几乎都是目前很知名的软件，重复性相当的高，例如网页服务器的 Apache，电子邮件服务器的 Postfix/sendmail，文件服务器的 Samba 等等。
    - 此外，为了让所有的 Linux distributions 开发不至于差异太大，且让这些开发商在开发的时候有所依据，还有 Linux Standard Base (LSB) 等标准来规范开发者，以及目录架构的 File system Hierarchy Standard (FHS) 标准规范！唯一差别的，可能就是该开发者自家所开发出来的管理工具，以及套件管理的模式吧！
    - 事实上鸟哥认为 distributions 主要分为两大系统，一种是使用 RPM 方式安装软件的系统，包括 Red Hat，Fedora，SuSE 等都是这类；一种则是使用 Debian 的 dpkg 方式安装软件的系统，包括 Debian，Ubuntu，B2D 等等。
  - Linux 在台湾
  - 选择适合你的  Linux distribution
    - 总之，版本很多，但是各版本差异其实不大，建议你一定要先选定一个版本后，先彻头彻尾地了解它，那再继续玩其它版本时，就可以很快的进入状况。鸟哥的网站仅是提供一个版本，不过是以比较基础的方式来介绍的，因此，如果能够熟练俺这个网站的话，哪一个 distributions 对你来说，都不成问题啦！



1.3 Linux 当前应用的角色

- 企业环境的利用
  - 网络服务器
  - 关键任务的应用（金融数据库、大型企业网管环境）
  - 学术机构的高效能运算任务
- 个人环境的使用
  - 桌面计算机
  - 手持系统（PDA、手机）
  - 嵌入式系统
- 云端运用
  - 云程序
  - 端设备



1.4 Linux 该如何学习

- 通过命令行模式来学习 Linux
- 从头学习 Linux 基础
  1. 计算机概论与硬件相关知识
  2. 先从 Linux 安装与指令学起
  3. Linux 操作系统的基础技能
     - 使用者、群组的概念，权限的观念，程序的定义等等，尤其是权限的概念。
  4. 务必学会 vi 文字编辑器
  5. Shell 与 Shell Script 的学习
  6. 一定要会软件管理员
     - 对 Tarball/RPM/DPKG/YUM/APT 等软件管理员的安装方式的了解
  7. 网络基础的建立
  8. 如果网络基础通过了，那么网站的架设对你来说，简直就是太简单啦！
- 选择一本易读的工具书
- 实作再实作
- 发生问题怎么处理啊？建议流程是这样：
  1. 在自己的主机/网络数据库上查询 How-To 或 FAQ
  2. 注意讯息输出，自行解决疑难杂症
  3. 搜寻过后，注意网络礼节，讨论区大胆地发言吧
  4. Netman 大大给的建议
- 鸟哥的建议（重点在 solution 的学习）



1.5 重点回顾



&nbsp;

### 第二章 主机规划与磁盘分区



2.1 Linux 与硬件的搭配

- 认识计算机的硬件配备
  - 游戏机/工作机的考虑
  - 效能/价格比 与 效能/消耗的瓦数比 的考虑
  - 支持度的考虑
- 选择与 Linux 搭配的主机配备
- 各硬件装置在 Linux 中的文件名
  - 在 Linux 系统中，每个装置都被当成一个文件来对待。
- 使用虚拟机学习



2.2 磁盘分区

- 磁盘连接的方式与装置文件名的关系
  - 早期磁盘第一个扇区里面含有的重要信息我们称为 MBR (Master Boot Record) 格式，但是由于近年来磁盘的容量不断扩大，造成读写上的一些困扰，甚至大于 2TB 以上的磁盘分区，已经让某些操作系统无法存取。因此后来又多了一个新的磁盘分区格式，称为 GPT (GUID partition table) 。这两种分区格式与限制不太相同啦！
  - 必须要对硬盘进行分区，这样硬盘才可以被使用。
- MSDOS (MBR) 与 GPT 磁盘分区表（partition table）
  - MSDOS (MBR) 分区表格式与限制
    - 操作系统无法抓取到 2.2 T 以上的磁盘容量；
    - MBR 仅有一个区块，若被破坏后，经常无法或很难救援；
    - MBR 内的存放开机管理程序的区块仅 446 bytes，无法容纳较多的程序代码。
  - GUID partition table, GPT 磁盘分区表
    - 在磁盘管理工具上面，fdisk 这个老牌的软件并不认识 GPT 喔！要使用 GPT 的话，得要操作类似 gdisk 或者是 parted 指令才行！另外，开机管理程序方面，grub 第一版并不认识 GPT 喔！得要 grub2 以后才会认识的！
    - 并不是所有的操作系统都可以读取到 GPT 的磁盘分区格式喔！同时，也不是所有的硬件都可以支持 GPT 格式喔！是否能够读写 GPT 格式又与开机的检测程序有关！那开机的检测程序又分成什么呢？就是 BIOS 与 UEFI 啦！
- 开机流程中的 BIOS 与 UEFI 开机检测程序
  - BIOS 搭配 MBR/GPT 的开机流程
    - 整个开机流程到操作系统之前的动作应该是这样的：
      1. BIOS
      2. MBR
      3. 开机管理程序（boot loader）
      4. 核心文件
    - 这个 boot loader 的主要任务有这些项目：
      1. 提供选单
      2. 载入核心文件
      3. 转交其它 loader
  - UEFI BIOS 搭配 GPT 开机的流程
    - BIOS 仅为 16 位的程序，与现阶段新的操作系统接轨方面有点弱掉了！
    - UEFI (Unified Extensible Firmware Interface) ，统一可延伸韧体界面。
- Linux 安装模式下，磁盘分区的选择（极重要）
  - 目录树结构（directory tree）
  - 文件系统与目录树的关系（挂载）
    - 所谓是挂载，就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下。也就是说，进入该目录就可以读取该分区槽的意思。那个进入点的目录我们称为挂载点。
  - distributions 安装时，挂载点与磁盘分区的规划
    - 实际上，在 Linux 安装的时候已经提供了相当多的默认模式让你选择分区的方式了，不过，无论如何，分区的结果可能都不是很能符合自己主机的样子！因为毕竟每个人的想法都不太一样，因此，强烈建议使用「自定义安装，Custom」这个安装模式。
    - 自定义安装（Custom）
      - A：初次接触 Linux ：只要分区 「/」及「swap」即可
      - B：建议分区的方法：预留一个备用的剩余磁盘容量
    - 选择 Linux 安装程序提供的默认硬盘分区方式
      - 对于首次接触 Linux 的朋友们，鸟哥通常不建议使用各个 distribution 所提供默认的 Server 安装方式，因为会让你无法得知 Linux 在搞什么鬼，而且也不见得可以符合你的需求。而且要注意的是，选择 Server 的时候，请确定你的硬盘数据是不再需要！因为 Linux 会自动地把你的硬盘里面旧有的数据全部杀掉。



2.3 安装 Linux 前的规划

- 选择适当的 distribution
  - 你所下载的文件扩展名是 .iso，这就是所谓的 image 文件（镜像文件）。这种 image 文件是由光盘直接刻录成文件的，文件非常大，建议你不要使用浏览器来下载，可以使用 FTP 客户端程序来下载，例如 [Filezilla](http://filezilla-project.org/download.php) 等。这样比较不用担心断线的问题，因为可以续传啊！
- 主机的服务规划与硬件的关系
  - 打造 Windows 与 Linux 共存的环境
  - NAT（达成 IP 分享器的功能）
  - SAMBA（加入 Windows 网络上的芳邻）
  - Mail（邮件服务器）
  - Web（WWW 服务器）
  - DHCP（提供客户端自动取得 IP 的功能）
  - FTP
- 主机硬盘的主要规划
  - 最简单的分区方法
  - 稍微麻烦一点的方式
- 鸟哥的两个实际案例
  - 案例一：家用的小型 Linux 服务器，IP 分享与文件分享中心
  - 案例二：提供 Linux 的 PC 丛集（Cluster）计算机群



2.4 重点回顾



&nbsp;

### 第三章 安装 CentOS7.x



3.1 本练习机的规划-\-尤其是分区参数



3.2 开始安装 CenOS 7

- 调整开机媒体（BIOS）与虚拟机建置流程
- 选择安装模式与开机 - inst.gpt
- 在地设定之时区、语系与键盘布局
- 安装来源设定与软件选择
- 磁盘分区与文件系统设定
- 核心管理与网络设定
- 开始安装、设定 root 密码与新增可切换身份之一般用户
- 准备使用系统前的授权同意
- 其它功能：RAM testing，安装笔记本电脑的核心参数（Option）



3.3 多重引导安装流程与管理（Option）

- 安装 CentOS 7.x + Windows 7 的规划
- 进阶安装 CentOS 7.x 与 Windows 7 
- 救援 MBR 内的开机管理程序与设定多重引导选单



3.4 重点回顾



&nbsp;

### 第四章 首次登录与在线求助



4.1 首次登录系统

- 首次登录系统
  - 首次登录 CentOS 7.x 图形接口
  - GNOME 的操作与注销
  - X window 与文本模式的切换
    - 通常我们也称文本模式为终端机接口，terminal 或 console 喔！Linux 默认的情况会提供六个 Terminal 来让使用者登录，切换的方式为使用：[Ctrl] + [Alt] + [F1]~[F6] 的组合按钮。
  - 在终端界面登录 Linux 



4.2 文本模式下指令的下达

- 开始下达指令
  - 指令的说明
  - 语系的支持
    - locale

- 基础指令的操作
  - 显示日期的指令：date
    - 指令之后的选项除了前面带有减号「-」之外，某些特殊情况下，选项或参数前面也会带有正号「+」的情况。这部分可不要轻易地忘记了呢！
  - 显示日历的指令：cal
  - 简单好用的计算器：bc
  - 从上面的练习我们大概可以知道在指令列模式里面下达指令时，会有两种主要的情况：
    - 一种是该指令会直接显示结果，然后回到命令提示字符，等待下一个指令的输入；
    - 一种是进入到该指令的环境，直到结束该指令才回到命令提示字符的环境。
- 重要的几个热键 [Tab]，[Ctrl] + c，[Ctrl] + d
  - [Tab] 按键
    - 在各种 Unix-Like 的 Shell 当中，这个 [Tab] 按键算是 Linux 的 Bash shell 最棒的功能之一了！它具有命令补全与文件补齐的功能喔！
  - [Ctrl] + c
    - 中断目前的程序
  - [Ctrl] + d
    - 键盘输入结束（End Of File，EOF 或 End Of Input）。
    - 另外，它也可以用来取代 exit 的输入呢！例如你想要直接离开文字接口，可以直接按下 [Ctrl] + d 就能够直接离开了（相当于输入 exit啊！）。
  - [shift] + {[Page UP] \| [Page Down]} 按键
    - 在纯文本的画面中，可以使用 [shift] + [Page UP] 来往前翻页，也能够使用 [shift] + [Page Down] 来往后翻页！
  - 总之，在 Linux 底下，文字接口的功能是很强悍的！要多多地学习它，而要学习它的基础要诀就是多使用、多熟悉啦！
- 错误讯息的查看
  - 可以借由屏幕上面显示的错误讯息来了解你的问题点，那就很容易知道如何改善这个错误讯息啰！



4.3 Linux 系统的在线求助 man page 与 info page 

- 指令的 -\-help 求助说明

  - `date --help ` 

- man page

  - 这个 man 是 manual 的简写啦！

  - `man date` 

  - 既然有 man page，自然就是因为有一些文件数据，所以才能够以 man page 读出来啰！那么这些 man page 的数据放在哪里呢？不同的 distribution 通常可能有点差异性，不过通常是放在 /usr/share/man 这个目录里头，然而，我们可以通过修改它的 man page 搜寻路径来改善这个目录的问题！修改 /etc/man_db.conf（有的版本为 man.conf 或 manpath.conf 或 man.config 等）即可啰！至于更多的关于 man  的讯息你可以使用 `man man` 来查询呦！

  - 搜寻特定 指令/文件 的 man page 说明文件

    - `man -f man` 

    - `man 1 man` 

    - `man 7 man` 

    - `man -k man` 

    - 还有两个指令与 man page 有关呢！而这两个指令是 man 的简略写法，就是这两个：

      - `whatis [指令或者是数据]` 相当于 `man -f [指令或者是数据]` 
      - `apropos [指令或者是数据]` 相当于 `man -k [指令或者是数据]` 

      而要注意的是，这两个特殊指令要能使用，必须要有建立 whatis 数据库才行！这个数据库的建立需要以 root 的身份下达如下的指令：`mandb` 。

  - 一般来说，鸟哥是真的不会去背指令的，只会去记住几个常见的指令而已。那么鸟哥是怎么找到所需要的指令呢？举例来说，打印的相关指令，鸟哥其实仅记得 lp (line print) 而已。那我就由 man lp 开始，去找相关的说明，然后，再以 lp\[tab\]\[tab\] 找到任何以 lp 为开头的指令，找到我认为可能有点相关的指令后，先以 -\-help 去查基本的用法，若有需要再以 man 去查询指令的用法。所以，如果是实际在管理 Linux，那么真的只要记得几个很重要的指令即可。

- info page
  
- 基本上 info 与 man 的用途其实差不多，都是用来查询指令的用法或者是文件的格式。但是与 man page 一口气输出一堆信息不同的是，info page 则是将文件数据拆成一个一个的段落，每个段落用自己的页面来撰写，并且在各个页面中还有类似网页的超链接来跳到各不同的页面中，每个独立的页面也被称为一个节点（node）。
  
- 其它有用的文件（documents）
  
  - 在 /usr/share/doc 这个目录下有其它的说明文件。
- 总结上面的三个咚咚（man，info，/usr/share/doc/），请记住：
  - 在终端机模式中，如果你知道某个指令，但却忘了相关的选项与参数，请先善用 -\-help 的功能来查询相关信息。
  - 当有任何你不知道的指令或文件格式这种玩意儿，但是你想要了解它，请赶快使用 man 或者是 info 来查询！
  - 而如果你想要架设一些其它的服务，或想要利用一整组软件来达成某项功能时，请赶快到 /usr/share/doc 底下查一查有没有该服务的说明文件喔！
  - 另外，再次地强调，因为 Linux 毕竟是外国人发明的，所以中文文件确实是比较少的！但是不要害怕，拿本英文字典在身边吧！随时查阅，不要害怕英文喔！



4.4 超简单文书编辑器：nano



4.5 正确的关机方法

- 观察系统的使用状态：
  - `who` ：看目前有谁在线上
  - `netstat -a` ：看网络的连接状态
  - `ps -aux` ：看背景执行的程序
- 几个关机/重启相关的指令：
  - 将数据同步写入硬盘中的指令：sync
  - 惯用的关机指令：shutdown
  - 重新启动，关机：reboot，halt，poweroff
- `su - ; sync` ，事实上 `sync` 也可以被一般账号使用喔！只不过一般账号用户所更新的硬盘数据就仅有自己的数据，不像 root 可以更新整个系统中的数据了。
- shutdown 可以达成如下的工作：
  - 可以自由选择关机模式：是要关机或重新启动均可；
  - 可以设定关机时间：可以设定成现在立刻关机，也可以设定某一个特定的时间才关机；
  - 可以自定义关机讯息：在关机之前，可以将自己设定的讯息传送给在线 user；
  - 可以仅发出警告讯息：有时可能你要进行一些测试，而不想让其他的使用者干扰，或者是明白地告诉使用者某段时间要注意一下！这个时候可以使用 shutdown 来吓一吓使用者，但却不是真的要关机啦！
- 与旧版不同的地方在于，以前 shutdown 后面一定得要加时间参数才行，如果没有加上的话，系统会跳到单人维护模式中。在这一版中，shutdown 会以 1 分钟为限，进行自动关机的任务，真的很不一样喔！所以时间参数可以不用加啰！
- 还有三个指令可以进行重新启动与关机的任务，那就是 reboot，halt，poweroff。其实这三个指令呼叫的函数库都差不多，所以当你使用 `man reboot` 时，会同时出现三个指令的用法给你看呢。其实鸟哥通常都只记 poweroff 与 reboot 这两个指令啦！一般鸟哥在重新启动时，都会下达如下的指令喔：`sync; sync; sync; reboot` 
- 实际使用管理工具 systemctl 关机
  - init 指令，这个指令可以切换不同的执行等级，执行等级共有 0-6 七个，其中 0 就是关机，6 就是重新启动等等。不过，这个 init 目前只是一个兼容模式而已，所以在 CentOS 7 当中，虽然你依旧可以使用 `init 0` 来关机，但是那已经跟所谓的执行等级无关了。
  - 那目前系统中所有服务的管理是使用哪个指令呢？那就是 systemctl 啦！前面谈到的 halt，poweroff，reboot，shutdown 等等，其实都是呼叫这个 systemctl 指令的喔！这个指令跟关机有关的语法如下：
    - `systemctl reboot` 
    - `systemctl poweroff` 



4.6 重点回顾



&nbsp;

## 第二部分 Linux 文件、目录与磁盘格式



### 第五章 Linux 的文件权限与目录配置



5.1 使用者与群组

- 文件拥有者
- 群组概念
- 其他人的概念
- Linux 用户身份与群组记录的文件
  - /etc/passwd ：记录系统上的账号与一般身份使用者，root 的相关信息
  - /etc/shadow ：记录账号的密码
  - /etc/group ：记录所有组名



5.2 文件权限概念

- Linux 文件属性

  - ls ：查看文件的指令。是 list 的意思，显示文件的文件名与相关属性。
  - 通过 ls 列出的每行 7 个字段的意思，从左至右：文件类型权限、连结数、文件拥有者、文件所属群组、文件容量、文件最后被修改的时间、文件名。
  - 对于更详细的 ls 用法，还记得怎么查询吗？对啦！使用 `ls --help` 或 `man ls` 或 `info ls` 去看看它的基础用法去！自我进修是很重要的，因为「师傅带进门，修行看个人！」，自古只有天才学生，没有明星老师呦！加油吧！
  - Linux 文件权限的重要性

- 如何改变文件属性与权限

  - chgrp：改变文件所属群组
  - chown：改变文件拥有者
  - chmod：改变文件的权限，SUID，SGID，SBIT 等特性
  - `cp 来源文件 目标文件` 
  - 将一个文件的权限改为 -rwxr-xr-\- ：`chmod 754 filename`  or  `chmod u=rwx,g=rx,o=r filename` 
  - 要拿掉全部人的可执行权限，可以使用 `chmod a-x filename`  

- 目录与文件之权限意义

  - 权限对文件的重要性
  - 权限对目录的重要性
    - 如果你在某目录下不具有 x 的权限，那么你就无法切换到该目录下，也就无法执行该目录下的任何指令，即使你具有该目录的 r 或 w 的权限。
    - 要开放目录给任何人浏览时，应该至少也要给予 r 及 x 的权限，但 w 权限不可随便给！
  - 建立目录可用 `mkdir` ，make directory；建立空文件可用 `touch` 

- Linux 文件种类与扩展名

  - 文件种类

    - 正规文件（regular file）：「-」
    - 目录（directory）：「d」
    - 连结档（link）：「l」，字母L的小写
    - 设备与装置文件（device）：
      - 区块（block）设备档：就是一些储存数据，以提供系统随机存取的接口设备。「b」
      - 字符（character）设备文件：亦即是一些串行端口的接口设备，例如键盘、鼠标等等。「c」
    - 资料接口文件（sockets）：「s」
    - 数据输送文件（FIFO, pipe）：「p」

  - Linux 文件扩展名

    - 基本上，Linux 的文件是没有所谓的扩展名的，一个 Linux 文件能不能被执行，与它第一栏的十个属性有关，与文件名根本一点关系也没有。在 Linux 底下，只要你的权限当中具有 x 的话，例如 「-rwxr-xr-x」即代表这个文件具有可以被执行的能力喔！

    - 这个 x 代表这个文件具有可执行的能力，但是能不能执行成功，当然就得要看该文件的内容啰~

    - 基本上，Linux 系统上的文件名真的只是让你了解该文件可能的用途而已，真正的执行与否仍然需要权限的规范才行！例如，虽然有一个文件为可执行文件，如常见的 bin/ls 这个显示文件属性的指令，不过，如果这个文件的权限被修改成无法执行时，那么 ls 就变成不能执行啰！

      这种问题最常发生在文件传送的过程中。例如，你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行！那么就是可能文件的属性被改变了！不要怀疑，从网络上传送到你的 Linux 系统中，文件是属性与权限确实是会改变的喔！

  - Linux 文件名的限制



5.3 Linux 目录配置

- Linux 目录配置的依据 -\- FHS
  - Filesystem Hierarchy Standard (FHS) 
  - 根据 FHS 的标准文件指出，他们的主要目的是希望让使用者可以了解到已安装软件通常放置于哪个目录下，所以他们希望独立的软件开发商、操作系统制作者、以及想要维护系统的用户，都能够遵循 FHS 的标准。也就是说，FHS 的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。
  - 事实上，FHS 针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是这三个目录的定义：
    - / (root，根目录) ：与开机系统有关；
    - /usr (unix software resource) ：与软件安装/执行有关；
    - /var (variable) ：与系统运行过程有关。
- 目录树（directory tree）
  - 在 Linux 底下，所有的文件与目录都是由根目录开始的，那是所有目录与文件的源头~ 然后再一个一个地分支下来，有点像是树枝状啊~ 因此，我们也称这种目录配置方式为：目录树（directory tree）。它主要的特性有：
    - 目录树的起始点为根目录（/，root）；
    - 每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem。举例来说，可以利用 Network File System (NFS) 服务器挂载某特定目录等；
    - 每一个文件在此目录树中的文件名（包含完整路径）都是独一无二的。
- 绝对路径与相对路径
  - 根据文件名写法的不同，也将所谓的路径（path）定义为绝对路径（absolute）与相对路径（relative）。这两种文件名/路径的写法依据是这样的：
    - 绝对路径：由根目录（/）开始写起的文件名或目录名称，例如 /home/dmtsai.bashrc ；
    - 相对路径：相对于目前路径的文件名写法。例如 ./home/dmtsai 或 ../../home/dmtsai 等等。反正开头不是 / 就属于相对路径的写法。
  - 两个特殊的目录：
    - . ：代表当前的目录，也可以使用 ./ 来表示；
    - .. ：代表上一层目录，也可以 ../ 来表示。
- CentOS 的观察
  - 如同在第一章谈到 Linux distribution 的差异性，除了 FHS 之外，还有个 Linux Standard Base (LSB) 的标准是可以依循的！我们可以简单的使用 ls 来查看 FHS 规范的目录是否正确的存在于你的 Linux 系统中，那么 Linux 核心、LSB 的标准又该如何查阅呢？基本上，LSB 团队是有列出正确支持 LSB 标准的 distribution 在相关的网页中。
  - 不过，如果你想要知道确切的核心与 LSB 所需求的几种重要的标准的话，恐怕就得要使用诸如 uname 与 lsb_release 等指令来查阅了。
  - `uname -r` ，查看核心版本
  - `uname -m` ，查看操作系统的位版本
  - `lsb_release -a` 



5.4 重点回顾
- 要开放目录给任何人浏览时，应该至少也要给予 r 及 x 权限，但 w 权限不可随便给。
- 能否读取到某个文件内容，跟该文件所在的目录权限也有关系（目录至少需要有 x 的权限）



&nbsp;

### 第六章 Linux 文件与目录管理



6.1 目录与路径

- 相对路径与绝对路径
  - 相对路径的用途
  - 绝对路径的用途

- 目录的相关操作
  - 一些比较特殊的目录
    - . ：代表此层目录
    - .. ：代表上一层目录
    - \- ：代表前一个工作目录
    - ~ ：代表目前用户身份所在的家目录
    - ~account ：代表 account 这个用户的家目录（account 是个账号名称）
  - cd (change directory，变换目录) 
  - pwd (Print Working Directory，显示目前所在的目录)
    - `pwd -P` ，显示出确实的路径，而非使用链接（link）路径。
  - mkdir (建立新目录) 
    - -m 选项
    - -p 选项
  - rmdir (删除空的目录) 
    - 如果要将所有目录下的东西都杀掉呢？这个时候就必须使用 `rm -r DirectoryName` ，不过还是使用 rmdir 比较不危险。
- 关于执行文件路径的变量：$PATH
  - 环境变量 PATH
  - `echo $PATH` ，echo 有显示、印出的意思，而 PATH 前面加的 $ 表示后面接的是变量，所以会显示出目前的 PATH 。
  - mv 为移动指令，可将文件在不同目录间进行移动作业。



6.2文件与目录管理

- 文件与目录的检视：ls
  - ls 最常被使用到的功能还是那个 -l 的选项，为此，很多 distribution 在预设的情况中，已经将 ll（L 的小写）设定成为 ls -l  的意思了！其实，这个功能是 Bash Shell 的 alias 功能呢~ 也就是说，我们直接输入 ll 就等于是输入 ls -l 。
- 复制、删除与移动：cp，rm，mv
  - 要复制文件，请使用 cp (copy) 这个指令即可~ 不过，cp 这个指令的用途可多了~ 除了单纯的复制之外，还可以建立连结档（就是快捷方式啰），比对两文件的新旧而予以更新，以及复制整个目录等等的功能呢！
  - 至于移动目录与文件，则使用 mv (move)，这个指令也可以直接拿来作更名（rename）
  - 至于移除，那就是 rm (remove) 这个指令啰~ 
  - `rm [-fir] 文件或目录` 
    - `rm -r /tmp/ect` ，因为执行命令的身份是 root，默认已经加入 -i 的选项，所以你要一直按 y 才会删除！如果不想要继续按 y，可以按下 [ctrl] + c 来结束 rm 的工作。
    - `\rm -r /tmp/etc` ，在指令前加上反斜杠，可以忽略掉 alias 的指定选项喔！至于 alias 我们在 bash 再谈！这个范例很可怕，你不要删错了，删除 /etc 系统是会挂掉的！
- 取得路径的文件名与目录名称
  - 每个文件的完整文件名包含了前面的目录与最终的文件名。其实取得文件名或者是目录名称，一般的用途应该是在写程序的时候用来判断之用的啦~ 所以，这部分的指令可以用在 shell scripts 里头喔！
  - `basename /etc/sysconfig/network` ，取得最后的文件名
  - `dirname /etc/sysconfig/network` ，取得目录名



6.3 文件内容查阅

- 最常使用的显示文件内容的指令可以说是 cat 与 more 及 less 了！此外，如果我们要查看一个很大型的文件，但是我们只需要后端的几行字而已，那么该如何是好？用 tail 呀，此外 tac 这个指令也可以达到这个目的喔！
  - cat ：由第一行开始显示文件内容
  - tac ：从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
  - nl ：显示的时候，顺道输出行号！
  - more ：一页一页地显示文件内容
  - less ：与 more 类似，但是比 more 更好的是，它可以往前翻页！
  - head ：只看头几行
  - tail ：只看尾巴几行
  - od ：以二进制的方式读取文件内容！
- 直接检视文件内容
  - 直接查阅一个文件的内容可以使用 cat/tac/nl 这几个指令啊！
  - cat (concatenate) 
  - tac (反向显示) 
  - nl (添加行号打印) 
- 可翻页检视
  - more (一页一页翻动)
  - less (一页一页翻动)
    - less 的用法比 more 更加的有弹性，可以使用 [pageup]、[pagedown] 等按键的功能来往前、往后翻看文件（在 more 中使用 [ctrl] + b 或 b，代表往回翻页）。除此之外，在 less 里头有更多的搜寻功能喔！
    - 你是否会觉得 less 使用的画面与环境与 man page 非常的类似呢？没错啦！因为 man 这个指令就是呼叫 less 来显示说明文件的内容的！现在你是否觉得 less 很重要呢？^_^
- 资料撷取
  - 我们可以将输出的资料作一个最简单的撷取，那就是取出文件前面几行（head）或取出后面几行（tail）文字的功能。不过，要注意的是，head 与 tail 都是以行为单位来进行数据撷取的喔！
  - head (取出前面几行)
    - `head -n 20 /etc/man_db.conf | tail -n 10` （这两个指令中有个管线（ \| ）的符号存在，这个管线的意思是：前面的指令所输出的讯息，请透过管线交由后续的指令继续使用）
  - tail (取出后面几行)
- 非纯文本文件：od
  - `echo password | od -t oCc` （echo 可以在屏幕上面显示任何信息，在这个命令中，这个信息不由屏幕输出，而是传给 od 去继续处理，这样就可以得到 password 的 ASCII code 对照啰！）
- 修改文件时间或创建新文件：touch
  - 我们在 ls 这个指令的介绍时，有稍微提到每个文件在 Linux 底下都会记录许多的时间参数，其实是有三个主要的变动时间，那么三个时间的意义是什么呢？
    - modification time (mtime) ：当该文件的内容数据变更时，就会更新这个时间！内容数据指的是文件的内容，而不是文件的属性或权限喔！
    - status time (ctime) ：当该文件的状态（status）改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。
    - access time (atime) ：当该文件的内容被取用时，就会更新这个读取时间（access）。举例来说，我们使用 cat 去读取 /etc/man_db.conf ，就会更新该文件的 atime 了。
  - 在默认的情况下，ls 显示出来的是该文件的 mtime，也就是这个文件的内容上次被更动的时间。
  - touch 这个指令最常被使用的情况是：
    - 建立一个空的文件；
    - 将某个文件日期修订为目前（mtime 与 atime）



6.4 文件与目录的默认权限与隐藏权限

- 除了基本的 r，w，x 权限外，在 Linux 传统的 Ext2/Ext3/Ext4 文件系统下，我们还可以设定其它的系统隐藏属性，这部分可使用 chattr 来设定，而以 lsattr 来查看，最重要的属性就是设定其不可修改的特性！连文件的拥有者都不能进行修改！这个属性可是相当重要的，尤其是在安全机制上面（security）！比较可惜的是，在 CentOS 7.x 当中利用 xfs 作为默认的文件系统，但是 xfs 就没有支持所有的 chattr 的参数了！仅有部分参数还有支持而已！
- 文件默认权限：umask
  - umask 就是指定目前用户在建立文件或目录时候的权限默认值
  - `umask` 
  - `umask -S` ，S 表示 Symbolic
  - 在默认权限的属性上，目录与文件是不一样的。文件是 -rw-rw-rw- ，即 666 分，而目录是 drwxrwxrwx ，即 777 分。umask 的分数指的是该默认值需要减掉的权限。
  - 如果以上面的例子来说明的话，因为 umask 为 022，那么当使用者：
    - 建立文件时：( -rw-rw-rw- ) - ( -\--\--w-\-w- ) ==> -rw-r-\-r-\- 
    - 建立目录时：( drwxrwxrwx ) - ( d-\--\-w-\-w- ) ==> drwxr-xr-x
  - umask 的利用与重要性：专题制作
    - 这个 umask 对于新建文件与目录的默认权限是很有关系的！这个概念可以用在任何服务器上面，尤其是未来在你架设文件服务器（file server），举例来说，SAMBA Server 或者是 FTP server 时，都是很重要的观念！
- 文件隐藏属性
  - 要先强调的是，chattr 指令只能在 Ext2/Ext3/Ext4 的 Linux 传统文件系统上面完整生效，其它的文件系统可能就无法完整地支持这个指令了，例如 xfs 仅支持部分参数而已。
  - chattr (配置文件隐藏属性)
    - `cd /tmp; touch attrtest; chattr +i attrtest; rm attrtest` 
    - `chattr -i attrtest`
    - 由于这些属性是隐藏的性质，所以需要用 lsattr 才能看到该属性呦！其中，个人认为最重要的当属 +i 与 +a 这两个属性了。+i 让一个文件不能被删除、改名、设定连结也无法写入或新增数据，对于系统安全有相当大的帮助，只有 root 能设定此属性。+a 让这个文件将只能增加数据，而不能删除也不能修改数据，只有 root 才能设定这个属性。
  - lsattr (显示文件隐藏属性)
    - `chattr +aiS attrtest; lsattr attrtest` 
    - 使用 chattr 设定后，可以利用 lsattr 来查阅隐藏的属性。不过，这两个指令在使用上必须要特别小心，否则会造成很大的困扰。例如，某天你心情好，突然将 /etc/shadow 这个重要的密码记录文件给它设定为具有 i 属性，那么过了若干天之后，你突然要新增使用者，却一直无法新增！别怀疑，赶快去将 i 属性拿掉吧！
- 文件特殊权限：SUID，SGID，SBIT
  - Set UID
    - Set UID，简称为 SUID 的特殊权限。针对文件进行设置。另外 SUID 仅可用在 binary program 上，不能够用在 shell script 上面！这是因为 shell script 只是将很多的 binary 执行文件叫进来执行而已。所以 SUID 的权限部分，还得要看 shell script 呼叫进来的程序的设定，而不是 shell script 本身。当然，SUID 对于目录也是无效的~ 这点要特别留意。
  - Set GID
    - Set GID，SGID。与 SUID 不同的是，SGID 可以针对文件或目录来设定，分别有不同的含义！
  - Sticky Bit
    - Sticky Bit，SBIT。目前只针对目录有效，对于文件已经没有效果了。
    - SBIT 对于目录的作用是：当用户对于此目录具有 w，x 权限，亦即具有写入的权限时，用户在该目录下建立文件或目录时，仅自己和 root 才有权力删除该文件。
  - SUID/SGID/SBIT 权限设定
    - 4 为 SUID；2 为 SGID；1 为 SBIT。
    - 假设要将一个文件权限改为 -rwsr-xr-x 时，由于 s 在用户权限中，所以是 SUID，因此在原先的 755 之前还要加上 4，也就是 `chmod 4755 filename` 来设定！此外，还有大 S 与大 T 的产生的情况喔！
    - 怎么会出现大写的 S 与 T 呢？不都是小写的吗？因为 s 与 t 都是取代 x 这个权限的，但是你有没有发现啊，我们是下达 7666 喔！也就是说，user，group 以及 others 都没有 x 这个可执行的标志，因为 666 嘛，所以这个 S，T 代表的就是空的啦！比如 SUID 是表示该文件在执行的时候，具有文件拥有者的权限，但是文件拥有者都无法执行了，哪里来的权限给其他人使用？当然就是空的啦！^_^
    - 必须要了解 SUID 不是用在目录上，而是用在文件上；SBIT 不是用在文件上，而是用在目录上！从它们各自所起到的作用去理解就很容易了。
- 观察文件类型：file
  - 如果你想要知道某个文件的基本数据，例如是属于 ASCII 或者是 data 文件，或者是 binary，且其中有没有使用到动态函数库（share library）等等的信息，就可以利用 file 这个指令来检阅喔！



6.5 指令与文件的搜寻

- 脚本文件名的搜寻
  - 我们知道在终端机模式当中，连续输入两次 [tab] 按键就能够知道用户有多少指令可以下达。那你知不知道这些指令的完整文件名放在哪里？举例来说，ls 这个常用的指令放在哪里呢？就通过 which 或 type 来寻找吧！
  - which (寻找可执行文件) 
    - which 这个指令是根据 PATH 这个环境变量所规范的路径，去搜寻可执行文件的文件名~ 所以，重点是找出可执行文件而已！且 which 后面接的是完整文件名喔！若加上 -a 选项，则可以列出所有的可以找到的同名可执行文件，而非仅显示第一个而已！
    - `which ifconfig` 
    - `which history` ，怎么 history 这个常用的指令竟然找不到啊！为什么呢？这是因为 history 是 bash 内建的指令啦！但是 which 默认是找 PATH 内所规范的目录，所以当然一定找不到的啊！（有 bash 就有 history ！）那怎么办？我们可以通过 type 这个指令喔！
- 文件文件名的搜寻
  - 再来谈一谈怎么搜寻文件吧！在 Linux 底下也有相当优异的搜寻指令呦！通常 find 不很常用的！因为除了速度慢之外，也很操作硬盘！一般我们都是先使用 whereis 或者是 locate 来检查，如果真的找不到了，才以 find 来搜寻呦！为什么呢？因为 whereis 只找系统中某些特定目录底下的文件而已，locate  则是利用数据库来搜寻文件名，当然两者就相当的快速，并且没有实际地搜寻硬盘内的文件系统状态，比较省时间啦！
  - whereis (由一些特定的目录中寻找文件文件名) 
  - locate / updatedb 
  - find
    - find 指令中选项与参数
      - 与时间有关的选项
      - 与使用者或组名有关的参数
      - 与文件权限及名称有关的参数
      - 额外可进行的动作
    - find 后面可以接多个目录来进行搜寻！另外，find 本来就会搜寻次目录，这个特点也要特别注意喔！
    - `find /usr/bin /usr/sbin -perm /7000 -exec ls -l {} \;` 
    - 如果你要找的文件是具有特殊属性的，例如 SUID、文件拥有者、文件大小等等，那么利用 locate 是没有办法达成你的搜寻的！此时 find 就显得很重要啦！另外，find 还可以利用通配符来寻找文件名呢！不过由于 find 在寻找数据时相当地操作硬盘，所以没事情不要使用 find 啦！有更棒的指令可以取代呦！那就是上面提到的 whereis 与 locate 啰！



6.6 极其重要的复习！权限与指令间的关系



6.7 重点回顾



鸟哥的 Changelog: Chapter 6

- 2015-08-25：感谢网友「学习日记博客」的告知，cp 的参数内，-a 不仅代表 -pdr ，因为有 SELinux 的影响。
- 2019-04-29：感谢网友 Emin 的提醒，locate 默认没有安装在新的 CentOS  当中了！所以需要手动安装！



&nbsp;

### 第七章 Linux 磁盘与文件系统管理



7.1 认识 Linux 文件系统

- 磁盘组成与分区的复习
- 文件系统特性
  - 传统的磁盘与文件系统之应用中，一个分区槽就是只能够被格式化成为一个文件系统，所以我们可以说一个 filesystem 就是一个 partition。但是由于新技术的利用，例如我们常听到的 LVM 与软件磁盘阵列（software raid），这些技术可以将一个分区槽格式化为多个文件系统（例如 LVM），也能够将多个分区槽合成一个文件系统（LVM，RAID）。所以说，目前我们在格式化时已经不再说针对 partition 来格式化了，通常我们可以称呼一个可被挂载的数据为一个文件系统而不是一个分区槽喔！
  - 文件系统通常会将这两部分数据分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中。另外还有一个超级区块（superblock）会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。
- Linux 的 EXT2 文件系统（inode）
  - 标准的 Linux 文件系统 Ext2 就是使用这种 inode 为基础的文件系统，inode 的内容在记录文件的权限与相关属性，至于 block 区块则是在记录文件的实际内容，而且文件系统一开始就将 inode 与 block 规划好了，除非重新格式化（或者利用 resize2fs 等指令变更文件系统大小），否则 inode 与 block 固定后就不再变动。
  - date block (资料区块)
  - inode table (inode 表格) 
  - Superblock (超级区块)
  - Filesystem Description (文件系统描述说明)
  - block bitmap (区块对照表)
  - inode bitmap (inode 对照表)
  - dumpe2fs ：查询 Ext 家族 superblock 信息的指令
    - CentOS 7 现在是以 xfs 为默认的文件系统，所以目前你的系统应该无法使用 dumpe2fs 去查询任何文件系统，鸟哥先找自己的一部机器来跟大家介绍，你可以在后续的格式化内容讲完之后，自己切出一个 ext4 的文件系统去查询看看即可。
    - blkid ，这个指令可以叫出目前系统有被格式化的装置。
- 与目录树的关系
  - 目录
    - 当我们在 Linux 下的文件系统建立一个目录时，文件系统会分配一个 inode 与至少一块 block 给该目录。其中，inode 记录该目录的相关权限与属性，并可记录分配到的那块 block 号码；而 block 则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据。
  - 文件
  - 目录树读取
  - filesystem 大小与磁盘读取效能
- EXT2/EXT3/EXT4 文件的存取与日志式文件系统的功能
  - 一般来说，我们将 inode table 与 data block 称为数据存放区域，至于其它例如 superblock、block bitmap 与 inode bitmap 等区段就被称为 metadata 啰，因为 superblock，inode bitmap 及 block bitmap 的数据是经常变动的，每次新增、移除、编辑时都可能会影响到这三个部分的数据。
  - 数据的不一致（Inconsistent）状态
  - 日志式文件系统（Journaling filesystem）

- Linux 文件系统的运行

  - Linux 通过异步处理（asynchronously）来解决磁盘与内存之间数据传输的效率问题。当系统加载一个文件到内存后，如果该文件没有被更改过，则在内存区段的文件数据会被设定为干净的（clean）。但如果内存中的文件数据被更改过了，此时该内存中的数据会被设定为脏的（Dirty）。此时所有的动作都还在内存中，并没有写入到磁盘中。系统会不定时地将内存中设定为 Dirty 的数据写回磁盘，以保持磁盘与内存数据的一致性。你也可以利用 sync 指令来手动强迫写入磁盘。
  - 因此 Linux 系统上面文件系统与内存有非常大的关系喔！

- 挂载点的意义（mount point）

  - 将文件系统与目录树结合的动作我们称为挂载。挂载点一定是目录，该目录为进入该文件系统的入口。因此并不是你有任何文件系统都能使用，必须要挂载到目录树的某个目录后，才能够使用该文件系统。
  - 同一个 filesystem 的某个 inode 只会对应到一个文件内容而已，因为一个文件占用一个 inode 之故，因此我们可以通过判断 inode 号码，来确定不同文件名是否为相同的文件喔！

- 其它 Linux 支持的文件系统与 VFS

  - Linux VFS (Virtual Filesystem Switch)
  - 其实，整个 Linux 的系统都是通过一个名为 Virtual Filesystem Switch 的核心功能去读取 filesystem 的。也就是说，整个 Linux 认识的 filesystem 其实都是 VFS 在进行管理，我们使用者并不需要知道每个 partition 上面的 filesystem 是什么~ VFS 会主动地帮我们做好读取的动作呢~

- XFS 文件系统简介

  - CentOS 7 开始，默认的文件系统已经由原本的 EXT4 变成了 XFS 文件系统了，为啥 CentOS 要舍弃对 Linux 支持度最完整的 EXT 家族而改用 XFS 呢？这是有一些原因存在的。

  - EXT 家族当前较伤脑筋的地方：支持度最广，但格式化超慢！

  - XFS 文件系统的配置

  - XFS 文件系统的描述数据观察

    - `xfs_info 挂载点|装置文件名` 

    - 找出系统 /boot 这个挂载点底下的文件系统的 superblock 记录：

      `df -T /boot; xfs_info /dev/vda2` 



7.2 文件系统的简单操作

- 磁盘与目录的容量

  - df ：列出文件系统的整体磁盘使用量
  - du ：评估文件系统的磁盘使用量（常用在推估目录所占容量）
  - 在 Linux 底下如果 df 没有加任何选项，那么默认会将系统内所有的文件系统都以 Kbytes 的容量列出来！
  - 执行 du 没有加任何选项时，则 du 会分析目前所在目录的文件与目录所占用的磁盘空间。

- 实体链接与符号链接：ln

  - 在 Linux 底下的链接文件有两种，一种是类似 Windows 的快捷方式功能的文件，可以让你快速地链接到目标文件（或目录）；另一种则是通过文件系统的 inode 链接来产生新文件名，而不是产生新文件，这种称为实体链接（hard link）。

  - Hard Link (实体链接，硬式链接或实际链接) 

    - hard link 只是在某个目录下新增一笔文件名链接到某 inode 号码的关联记录而已。
    - hard link 的限制：不能跨 Filesystem；不能 link 目录。

  - Symbolic Link (符号链接，亦即是快捷方式)

  - 由于 Hard Link 的一些限制，实际上 Symbolic Link 使用的较广。

  - `ln [-sf] 来源文件 目标文件` 

  - 关于目录的 link 数量

    - 当我们建立一个新目录名称为 /tmp/testing 时，基本上会有三个东西，那就是 

      - /tmp/testing
      - /tmp/testing/. 
      - /tmp/testing/.. 

      而其中 /tmp/testing 与 /tmp/testing/. 其实是一样的，都代表该目录；/tmp/testing/.. 则代表 /tmp 这个目录。所以说，当我们建立一个新的目录时，新的目录的 link 数为 2，而上层目录的 link 数则会增加 1 。



7.3 磁盘的分区、格式化、检验与挂载

- 观察磁盘分区状态
  - lsblk，列出系统上的所有磁盘列表，list block device 。
  - blkid，列出装置的 UUID 等参数。UUID，Universally Unique IDentifier，全局单一标识符。
  - parted，列出磁盘的分区表类型与分区信息。
    - `parted device_name print` 
- 磁盘分区：gdisk/fdisk
  - MBR 分区表请使用 fdisk 分区，GPT 分区表请使用 gdisk 分区。
  - gdisk
    - 你应该要通过 lsblk 或 blkid 先找到磁盘，再用 parted /dev/xxx print 来找出内部的分区表类型，之后才用 gdisk 或 fdisk 来操作系统。
    - 这个 gdisk 只有 root 才能执行，此外，请注意，使用的装置文件名不要加上数字，因为 partition 是针对整个磁盘装置，而不是某个 partition 呢！所以执行 `gdisk /dev/vda1` 就会发生错误啦！要使用 `gdisk /dev/vda` 才对！
  - 用 gdisk 新增分区槽
    - 用 gdisk 新增几个分区后，使用 `cat /proc/partitions` 可以看到在 Linux 核心中还没有出现新增的分区，这是因为 Linux 此时还在使用这颗磁盘，为了担心系统出问题，所以分区表并没有被更新。这个时候我们有两个方式可以来处理，其中一个是重新启动，另外一个则是通过 partprobe 这个指令来处理。
  - partprobe 更新 Linux 核心的分区表信息
  - 用 gdisk 删除一个分区槽
    - 万分注意，不要去删除一个正在使用中的分区槽！例如，我们的系统现在已经使用了 /dev/vda2 ，那如果你要删除 /dev/vda2 的话，必须要先将 /dev/vda2 卸除，否则直接删除该分区的话会出问题。
  - fdisk
    - 处理 MBR 分区表就得要使用 fdisk 啰！不过 MBR 分区表未来应该会慢慢地被淘汰，毕竟现在磁盘容量随便都大于 2T 了。不过依旧有些旧系统，以及虚拟机的使用上面还是有小磁盘存在的空间。
    - fdisk 跟 gdisk 使用的方式几乎是一样！此外，fdisk 有时会使用磁柱（cylinder）作为分区的最小单位，与 gdisk 默认使用 sector 不太一样。另外，不要忘了 MBR 分区是有限制的（Primary，Extended，Logical ...）！
- 磁盘格式化（建立文件系统）
  - 分区完毕后自然就是要进行格式化，创建文件系统啰！格式化的指令非常简单，那就是 mkfs，make filesystem 这个指令啦！这个指令其实是个综合的指令。
  - XFS 文件系统 mkfs.xfs
  - XFS 文件系统 for RAID 效能优化（Optional）
    - 这里你大概先有个概念即可，等到 14 章看完后，未来回到这里应该就能够看懂了！多看几次，多做几次，操作系统的练习是这样才能学得会！
  - EXT4 文件系统 mkfs.ext4
  - 其它文件系统 mkfs
    - mkfs\[tab\]\[tab\] 
- 文件系统检验
  - 我们知道文件系统运行时会有磁盘与内存数据异步的状况发生，因此莫名其妙的死机非常可能导致文件系统的错乱。如果文件系统真的发生错乱的话，那该如何是好？不同的文件系统救援的指令不太一样，我们主要针对 xfs 及 ext4 这两个主流来说明而已喔！
  - xfs_repair 处理 XFS 文件系统
  - fsck.ext4 处理 EXT4 文件系统
    - fsck 是个综合指令，如果针对 ext4 的话，建议直接使用 fsck.ext4 来检测比较妥当！
  - 由于 xfs_repair/fsck.ext4 在扫描磁盘的时候，可能会造成部分 filesystem 的修订，所以执行 xfs_repair/fsck.ext4 时，被检查的 partition 务必不可挂载到系统上！亦即是需要在卸除的状态喔！
- 文件系统挂载与卸除
  - 挂载点是目录，而这个目录是进入磁盘分区槽（其实是文件系统啦！）的入口就是了。不过要进行挂载前，你最好先确定几件事：
    - 单一文件系统不应该被重复挂载在不同的挂载点（目录）中；
    - 单一目录不应该重复挂载多个文件系统；
    - 要作为挂载点的目录，理论上应该都是空目录才是。
  - mount
  - 挂载 xfs/ext4/vfat 等文件系统
  - 挂载 CD 或 DVD 光盘
  - 挂载 vfat 中文 U 盘（USB 磁盘）
  - 重新挂载根目录与挂载不特定目录
    - 将 / 重新挂载，并加入参数 rw 与 auto ：`mount -o remount,rw,auto /` 
    - 将 /var 这个目录挂载到 /data/var 底下 ：`mkdir /data/var; mount --bind /var /data/var` ，从此进入 /data/var 就是进入 /var 的意思喔！
  - umount (将装置文件卸除)
- 磁盘/文件系统参数修订
  - mknod 
  - xfs_admin 修改 XFS 文件系统的 UUID 与 Label name 
    - uuidgen，产生新的 UUID 。
  - tune2fs 修改 ext4 的 label name 与 UUID



7.4 设定开机挂载

- 开机挂载 /etc/fstab 及 /etc/mtab 

  - /etc/fstab 是开机时的配置文件，不过，实际 filesystem 的挂载是记录到 /etc/mtab 与 /proc/mounts 这两个文件当中的。每次我们在更动 filesystem 的挂载时，也会同时更动这两个文件喔！ 

- 特殊装置 loop 挂载（镜像文件不刻录就挂载使用）

  - 如果有光盘镜像文件，或者是使用文件作为磁盘的方式时，那就得使用特别的方法来将它挂载起来，不需要刻录啦！

  - 挂载 光盘/DVD 镜像文件

    - `mount -o loop /tmp/CentOS-7.0-1406-x86_64-DVD.iso /data/centos_dvd` 
    - 如此一来我们不需要将这个文件刻录成光盘或者是 DVD 就能够读取内部的数据了！换句话说，你也可以在这个文件内动手脚去修改文件的！这也是为什么很多镜像文件提供后，还得要提供验证码（MD5）给使用者确认该镜像文件没有问题！

  - 建立大文件以制作 loop 装置文件

    - 既然能够挂载 DVD 这个镜像文件，那么我能不能制作出一个大文件，然后将这个文件格式化后挂载呢？好问题！这是个有趣的动作，而且还能够帮助我们解决很多系统的分区不良的情况呢！举例来说，如果当初在分区时，你只有分区出一个根目录，假设你已经没有多余的容量可以进行额外地分区，偏偏根目录的容量还很大，此时你就能够制作出一个大文件，然后将这个文件挂载！如此一来，感觉上你就多了一个分区槽啰，用途非常的广泛啦！

    - ```
      dd if=/dev/zero of=/srv/loopdev bs=1M count=512
      mkfs.xfs -f /srv/loopdev
      blkid /srv/loopdev
      mount -o loop UUID="XXX-XXX-XXX" /mnt
      ```



7.5 内存置换空间（swap）之创建

- 使用实体分区槽创建 swap 
  - 建立 swap 分区槽的方式是非常简单的，通过这四个步骤就搞定啰：
    1. 分区
    2. 格式化：`mkswap 装置文件名` 
    3. 使用：`swapon 装置文件名` ，将 swap 装置启动
    4. 观察：通过 `free` 与 `swapon -s` 指令来观察一下内存的使用吧！
- 使用文件创建 swap 



7.6 文件系统的特殊观察与操作

- 磁盘空间之浪费问题
- 利用 GNU 的 parted 进行分区行为（Optional）



7.7 重点回顾

- 一个可以被挂载的数据通常称为文件系统，filesystem，而不是分区槽（partition）喔！
- 磁盘的使用必需要经过：分区、格式化与挂载，分别惯用的指令未：gdisk，mkfs，mount 三个指令。
- 分区时，应使用 parted 检查分区表格式，再判断使用 fdisk/gdisk 来分区，或直接使用 parted 分区。
- 为了效能，XFS 文件系统格式化时，可以考虑加上 agcount/su/sw/extsize 等参数较佳。



鸟哥的 Changelog: Chapter 7

- 2017-09-04：许多朋友都发现这个错误，就是 hardlink 不要 link 目录的解释怪怪的~ 今天终于修改了一下！



&nbsp;

### 第八章 文件与文件系统的压缩，打包与备份



8.1 压缩文件的用途与技术



8.2 Linux 系统常见的压缩指令

- 虽然 Linux 文件的属性基本上是与文件名没有没有绝对关系的，但是为了便于人们识别，适当的扩展名还是必要的。常见的压缩文件扩展名有：

  - \*.Z ，           compress 程序压缩的文件
  - \*.zip ，        zip 程序压缩的文件
  - \*.gz ，         gzip 程序压缩的文件
  - \*.bz2 ，       bzip2 程序压缩的文件
  - \*.xz ，          xz 程序压缩的文件
  - \*.tar ，         tar 程序打包的数据，并没有压缩过
  - \*.tar.gz ，    tar 程序打包的文件，其中经过 gzip 的压缩
  - \*.tar.bz2 ，  tar 程序打包的文件，其中经过 bzip2 的压缩
  - \*.tar.xz ，     tar 程序打包的文件，其中经过 xz 的压缩

  Linux 上常见的压缩指令就是 gzip，bzip2 以及最新的 xz，至于 compress 已经退流行了。

- tar 指令可以将很多文件打包成为一个文件，甚至是目录也可以。不过，单纯的 tar 功能仅是打包而已，并没有提供压缩的功能。后来，GNU 计划中，将整个 tar 与压缩的功能结合在一起，如此一来提供使用者更方便并且更强大的压缩与打包功能！

- gzip，zcat/zmore/zless/zgrep

- bzip2，bzcat/bzmore/bzless/bzgrep

- xz，xzcat/xzmore/xzless/xzgrep



8.3 打包指令：tar

- tar

  - 其实最简单的使用 tar ，只要记住底下的方式即可：

    - 压    缩：`tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称` 
    - 查    询：`tar -jtv -f fimename.tar.bz2` 
    - 解压缩：`tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录` 

    那个 filename.tar.bz2 是我们自己取的文件名，tar 并不会主动地产生建立的文件名喔！我们要自己定义，所以扩展名就显得很重要了！如果不加 [ -z \| -j \| -J ] 的话，文件名最好取为 \*.tar 即可。如果是 -j 选项，表示有 bzip2 的支持，因此文件名最好就取为 \*.tar.bz2 。类似的，使用 -z 或 -J 分别表示使用 gzip 或 xz 来进行压缩打包的文件。

  - 此外，在使用 tar 命令时需要注意：

    -  -c（建立打包文件），-t（察看打包文件的内容），-x（解打包或解压缩的功能）不可同时出现在一串指令行中 
    - -z（通过 gzip 进行压缩/解压缩），-j（通过 bzip2 进行压缩/解压缩），-J（通过 xz 进行压缩/解压缩）不可以同时出现在一串指令行中 

  - 使用 tar 加入 -z，-j 或 -J 的参数备份 /etc/ 

    - 加上 -p 这个选项是为了保存原本文件的权限与属性！在备份重要的系统数据时，这些原本文件的权限需要做完整的备份比较好。

  - 查阅 tar 文件的数据内容（可查看文件名）与备份文件名是否有根目录的意义

  - 将备份的数据解压缩，并考虑特定目录的解压缩动作（-C 选项的应用）

  - 仅解开单一文件的方法

  - 打包某目录，但不含该目录下的某些文件之作法

    - 通过 -\-exclude 选项

  - 仅备份比某个时刻还要新的文件

    - 通过 -\-newer 或 -\-newer-mtime 选项

  - 基本名称：tarfile，tarball ？

    - tar 打包出来的文件有没有进行压缩所得到文件称呼不同喔！如果仅是打包而已，这个文件我们称呼为 tarfile 。如果还有进行压缩的支持，我们就称呼为 tarball 。这只是一个基本的称为而已，不过很多书籍与网络都会使用到这个 tarball 的名称，所以在这里介绍介绍。
    - tar 除了可以将资料打包成为文件之外，还能够将文件打包到某些特别的装置去，比如用 tar 来使用磁带机（tape）进行备份。

  - 特殊应用：利用管线命令与数据流

    - `cd /tmp; tar -cvf - /etc | tar -xvf -` ，这个动作有点像是 `cp -r /etc /tmp` ，将 /etc 底下的资料直接 copy 到目前所在的路径，也就是 /tmp 底下。其中指令里面的 - 就是表示那个被打包的文件啦！可以简单地将 - 想成是在内存中的一个装置（缓冲区），由于我们不想让中间文件存在，所以就以这种方式来进行复制的行为啦！

  - 例题：系统备份范例

  - 解压缩后的 SELinux 课题

    - SELinux 是比较特别的细部权限设定，相关的介绍我们会在 16 章好好地介绍一下。在这里，你只要先知道 SELinux 的权限问题可能会让你的系统无法存取某些配置文件内容，导致影响到系统的正常使用权。



8.4 XFS 文件系统的备份与还原

- 使用 tar 通常是针对目录树系统来进行备份的工作，那么如果想要针对整个文件系统来进行备份与还原呢？由于 CentOS 7 已经使用 XFS 文件系统作为默认值，所以那两个好用的 xfsdump 与 xfsrestore 工具对 CentOS 7 来说，就是挺重要的工具软件了。
- XFS 文件系统备份 xfsdump
  - 用 xfsdump 备份完整的文件系统
  - 用 xfsdump 进行累积备份（Incremental backups）
- XFS 文件系统还原 xfsrestore
  - 用 xfsrestore 观察 xfsdump 后的备份数据内容
  - 简单复原 level 0 的文件系统
  - 复原累积备份资料
  - 仅还原部分文件的 xfsrestore 互动模式



8.5 光盘写入工具

- 鸟哥是认为 DVD/CD 虽然还是有存在的价值，不过越来越少人使用了。虽然很少使用，不过某些特别的情况下，没有这东西又不行。那文本模式的刻录行为要怎么处理呢？通常的做法是这样的：
  - 先将所需要备份的数据创建成为一个镜像文件（iso），利用 mkisofs 指令来处理；
  - 将该镜像文件刻录至光盘或 DVD 中，利用 cdrecord 指令来处理。
- mkisofs ：建立镜像文件
  - 制作一般数据光盘镜像文件
  - 制作/修改可开机光盘镜像文件
    - isoinfo
    - rsync
      - rsync 可以完整地复制所有的权限属性等数据，也能够进行镜像处理，相当好用的指令喔！
- cdrecord：光盘刻录工具
  - 新版的 CentOS 7 使用的是 wodim 这个文字界面指令来进行刻录的行为，不过为了兼容于旧版的 cdrecord 这个指令，因此 wodim 也有连结到 cdrecord 就是了！因此，你还是可以使用 cdrecord 这个指令。不过鸟哥建议还是改用 wodim 比较干脆！
  - 基本上光盘刻录的指令越来越简单，虽然有很多的参数可以使用，不过，鸟哥认为，学习上面的语法就很足够了！一般来说，如果有刻录的需求，大多还是使用图形界面的软件来处理比较妥当~ 使用文字界面的刻录，真的大部分都是刻录数据光盘较多。



8.6 其它常见的压缩与备份工具

- dd
  - 我们在第七章当中的特殊 loop 装置挂载时，使用过 dd 这个指令对吧？不过，这个指令可不只是制作一个文件而已喔~ 这个dd指令最大的功效，鸟哥认为，应该是在于备份啊！因为 dd 可以读取磁盘装置的内容（几乎是直接读取扇区 sector），然后将整个装置备份成一个文件呢！真的是相当的好用啊~
  - xfs_growfs
- cpio



8.7 重点回顾



&nbsp;

## 第三部分 学习 Shell 和 Shell scripts



### 第九章 vim 程序编辑器



- 系统管理员的重要工作就是得要修改与设定某些重要软件的配置文件，因此至少得学会一种以上的文字接口的文书编辑器。

9.1 vi 与 vim

- 为何要学 vim 



9.2 vi 的使用

- 一般指令模式（command mode）
  - 以 vi 打开一个文件就直接进入一般指令模式了，这是默认的模式，也简称为一般模式。在这个模式中，你可以使用「上下左右」按键来移动光标，你可以使用「删除字符」或「删除整列」来处理文件内容，也可以使用「复制、粘贴」来处理你的文件数据。
- 编辑模式（insert mode）
  - 在一般模式中按下「i , I , o , O , a , A , r , R」中任何一个字母后会进入编辑模式，这时在画面的左下方会出现 INSERT 或 REPLACE 的字样，可以进行编辑。如果要退回到一般指令模式，则要按下「Esc」这个按键。
- 指令列命令模式（command-line mode）
  - 在一般模式中，输入「: , / , ?」三个中的任何一个按钮，就可以将光标移动到最底下那一列，进入指令列命令模式，在这个模式中可以提供你「搜寻资料」的动作。此外，读取、存盘、大量取代字符、离开 vi、显示行号等等动作也是在此模式中达成的！在进入这个模式后，按下 Esc 则回到一般指令模式。
- 简易执行范例
  - 存档（write）并离开（quit），在一般指令模式下输入「:wq 」即可存档离开。需要注意的是，如果你的文件权限不对，例如为 -r-\-r-\-r-\- 时，那么可能会无法写入，此时可以用 「:wq!」来强制写入，不过要在你的权限可以改变的情况下才能成立。
- 按键说明
  - 一般指令模式可用的按钮说明：移动光标；搜寻与取代；删除、复制与粘贴；
  - 一般指令模式切换到编辑模式的可用的按钮说明：进入插入模式（Insert mode）或进入取代模式（Replace mode）；
  - 一般指令模式切换到指令列模式的可用按钮说明：指令列模式的储存、离开等指令；vim 环境的变更；
  - 在 vi 中，数字是很有意义的！数字通常代表重复做几次的意思！也有可能是代表去到第几个什么什么的意思，举例来说，要删除 50 列，则是用 「50dd」，数字加在动作之前~ 那我要向下移动 20 列呢？那就是 「20j」或者是「20↓」。
  - OK！会这些指令就已经很厉害了，因为常用到的指令也只有不到一半！通常 vi 的指令除了上面鸟哥注明的常用的几个外，其它是不用背的，你可以做一张简单的指令表在你的屏幕墙上，一有疑问，可以马上的查询呦！这也是当初鸟哥使用 vim 的方法啦！
- 一个案例练习
- vim 的暂存文件、救援回复与开启时的警告讯息



9.3 vim 的额外功能

- 目前大部分的 distributions 都以 vim 取代 vi 的功能。如果你使用 vi 后，却看到画面的右下角有显示目前光标所在的行列号码，那么你的 vi 已经被 vim 所取代啰~ 为什么要用 vim 呢？因为 vim 具有颜色显示的功能，并且还支持许多的程序语法（syntax）。vim 的一般用法与 vi 一模一样，没有不同啦！
- 区块选择（visual block）
- 多文件编辑 
- 多窗口功能 
- vim 的挑字补全功能 
- vim 环境设定与记录：\~/.vimrc，\~/.viminfo
- vim 常用指令示意图



9.4 其它 vim 使用注意事项

- 中文编码的问题
- DOS 与 Linux 的断行字符
  - DOS（Windows 系统）使用的断行字符为 ^M\$，我们称为 CR 和 LF 两个符号；而在 Linux 下，则是仅有 LF (\$) 这个断行符号。
  - 我们说过，在 Linux 底下的指令在开始执行时，它的判断依据是「Enter」，而 Linux 的 「Enter」 为 LF 字符。不过，由于 DOS 的断行符号是 CRLF，也就是多了一个 ^M 的符号出来，在这样的情况下，如果是一个 shell script 的程序文件，将可能造成程序无法执行的状态~ 因为它会误判程序所下达的指令！
  - dos2unix
  - unix2dos
- 语系编码转换
  - iconv
  - `wget URL` ，下载 URL 所对应的文件



9.5 重点回顾



&nbsp;

### 第十章 认识与学习 BASH



10.1 认识 BASH 这个 Shell

- 硬件、核心与 Shell
- 为何要学文字接口的 shell ？
  - 文字接口的 shell ：大家都一样！
  - 远程管理：文字接口就是比较快！
  - Linux 的任督二脉：shell 是也！
- 系统的合法 shell 与 /etc/shells 功能
  - 由于早年的 Unix 年代，发展者众，所以由于 shell 依据发展者的不同就有许多的版本，例如常听到的 Bourne Shell (sh)、在 Sun 里头默认的 C SHell、商业上常用的 K SHell，还有 TCSH 等等，每一种 Shell 都各有其特点。至于 Linux 使用的这一种版本就称为 Bourne Again SHell（简称 BASH），这个 Shell 是 Bourne Shell 的增强版本，也是基于 GNU 架构下发展出来的呦！
  - /etc/shells 这个文件记录了系统上合法的 shell 。
- Bash shell 的功能
  - bash 主要的几个优点：
    - 命令编修能力（history）
      - 它能记忆使用过的指令！在很多 distribution 里头，默认的指令记忆功能可达到 1000 个！这么多的指令记录在哪里呢？在你的家目录内的 .bash_history 。不过，需要注意的是，\~/.bash_history 记录的是前一次登录以前所执行过的指令，而这一次登录所执行过的指令都被暂存在内存中，当你成功的注销系统后，该部分记忆的指令才会记录到 .bash_history 当中！
    - 命令与文件补全功能（[tab] 按键的好处）
    - 命令别名设置功能（alias）
    - 工作控制、前景背景控制（job control，foreground，background）
    - 程序化脚本（shell scripts）
    - 通配符（Wildcard）
- 查询指令是否为 Bash shell 的内建命令：type
  - 通过 type 这个指令，我们可以知道每个指令是否为 bash 的内建指令。
  - type 主要在找出可执行文件而不是一般文件文件名喔！所以，这个 type 也可以用来作为类似 which 指令的用途啦！找指令用的！
- 指令的下达与快速编辑按钮
  - [ctrl]+u / [ctrl]+k：分别是从光标处向前删除指令串（[ctrl]+u）及向后删除指令串（[ctrl]+k）
  - [ctrl]+a / [ctrl]+e：分别是让光标移动到整个指令串的最前面（[ctrl]+a）或最后面（[ctrl]+e）



10.2 Shell 的变量功能

- 什么是变量？

  - 变量的可变性与方便性
  - 影响 bash 环境操作的变量
  - 脚本程序设计（shell script）的好帮手

- 变量的取用与设定：echo，变量的设定规则，unset 

  - 变量的取用：echo

  - 变量的设定规则：

    1. 变量与变量内容以一个等号「=」来连结，如下所示：

       「myname=VBird」

    2. 等号两边不能直接接空格符，如下所示为错误：

       「myname = VBird」，「myname=Vbird Tsai」

    3. 变量名称只能是英文字母与数字，但是开头不能是数字；

    4. 变量内容若有空格符，可使用双引号「"」或单引号「'」将变量内容结合起来，但双引号内的特殊字符，如 \$ 等，可以保有原本的特性，而单引号内的特殊字符则仅为一般字符（纯文本）。

       「var="lang is \$LANG"」则「echo \$var」可得「lang is zh_TW.UTF-8」

       「var='lang is \$LANG'」则「echo \$var」可得「lang is \$LANG」

    5. 可用跳脱字符「\」将特殊符号（如 [Enter]，\$，\，空格符，' 等）变成一般字符，如：

       「myname=Vbird\ Tsai」

    6. 在一串指令的执行中，还需要借由其它额外的指令所提供的信息时，可以使用反单引号「\`指令\`」或「\$(指令)」。特别注意，那个 \` 是键盘上方的数字键 1 左边那个按键，而不是单引号！例如想要取得核心版本的设定：

       「version=\$(uname -r)」再「echo \$version」可得「3.10.0-1127.e17.x86_64」

    7. 若该变量为扩增变量内容时，则可用 "\$变量名称" 或 \${变量} 累加内容，如下所示：

       「PATH="\$PATH":/home/bin」或「PATH=\${PATH}:/home/bin」

    8. 若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量：

       「export PATH」

    9. 通常大写字符为系统默认变量，自行设定变量可以使用小写字符，方便判断（纯粹依照使用者兴趣与爱好）

    10. 取消变量的方法为使用 unset，「unset 变量名称」。例如取消 myname 的设定：

        「unset myname」

  - 若你有一个常去的工作目录名称为 /cluster/server/work/taiwan_2015/003/ ，如何进行该目录的简化？

    `work="/cluster/server/work/taiwan_2015/003/"; cd $work` ，未来要变更这个常去的工作目录时，只要变更 work 这个变量即可！而这个变量又可以在 bash 的配置文件（~/.bashrc）中直接指定，那么每次登陆只要执行 `cd $work` ，就能够去到所指定的工作目录。

- 环境变量的功能

  - 环境变量可以帮我们达到很多功能，包括家目录的变换啊、提示字符的显示啊、执行文件搜寻的路径啊等等。那么，既然环境变量有这么多的功能，那目前 shell 环境中有多少默认的环境变量呢？我们可以利用两个指令来查阅，分别是 env 与 export 。
  - 用 env 观察环境变量与常见环境变量说明 
    - env 是 environment 的简写，执行 `env` 会列出来所有的环境变量。
  - 用 set 观察所有变量（含环境变量与自定义变量）
    - 一般来说，无论是否为环境变量，只要跟我们目前这个 shell 的操作接口有关的变量，通常都会被设定为大写字符，也就是说，基本上在 Linux 默认的情况中，使用大写的字母来设定的变量一般为系统内所需要的变量。
    - PS1，提示字符的设定。
    - \$，关于本 shell 的 PID。想要知道我们 shell 的 PID ，就可以执行 `echo $$` ，出现的数字就是这个 shell 的 PID 号码。
    - ?，关于上个执行指令的回传值。当我们执行某些指令时，这些指令都会回传一个执行后的代码，一般来说，如果成功地执行该指令，则会回传一个 0 值，如果执行过程发生错误，就会回传错误代码，一般就是非 0 的数值。
    - OSTYPE，HOSTTYPE，MACHTYPE，主机硬件与核心的等级
  - export ：自定义变量转成环境变量
    - 子程序仅会继承父程序的环境变量，而不会继承父程序的自定义变量。
    - 如果你想让自定义变量变成环境变量，继续在子程序中使用，那么就执行 `export 变量名称` 。如果仅执行 `export` ，那么会把所有的环境变量显示出来。
    - 那如何将环境变量转成自定义变量呢？可以使用本章后续介绍的 declare 呢！

- 影响显示结果的语系变量（locale）

- 变量的有效范围

  - 在某些不同的书籍会谈到全局变量（global variable）与局部变量（local variable）。在鸟哥的这个章节中，基本上你可以这样看待：环境变量=全局变量，自定义变量=局部变量。

- 变量键盘读取、数组与宣告：read，array，declare 

  - read 
  - declare/typeset 
    - declare 或 typeset 是一样的功能，就是在宣告变量的类型。如果使用 declare 后面并没有接任何参数，那么 bash 就会主动地将所有的变量名称与内容通通叫出来，就好像使用 set 一样啦！
    - 在默认情况下，bash 对变量有两个基本的定义：
      - 变量类型默认为字符串，所以若不指定变量类型，则 1+2 为一个字符串，而不是计算式。
      - bash 环境中的数值运算，默认最多仅能达到整数形态，所以 1/3 结果是 0；
    - declare 也可以宣告数组的属性，不过，数组也是在 shell script 比较常用啦！比较有趣的是，如果你不小心用 declare 将变量设定为只读，通常得要注销再登录才能复原该变量类型了！
  - 数组（array）变量类型

- 与文件系统及程序的限制关系：ulimit

  - bash 是可以限制用户的某些系统资源的，包括可以开启的文件数量，可以使用的 CPU 时间，可以使用的内存总量等等。如何设定？用 ulimit 吧！

- 变量内容的删除、取代与替换（Optional）

  - 变量内容的删除与取代
  - 变量的测试与内容替换
    - 基本上这种变量的测试也能够通过 shell script 内的 if ... then ... 来处理，不过既然 bash 有提供这么简单的方法来测试，那我们也可以多学一些嘛！不过这种变量测试通常是在程序设计当中比较容易出现，如果这里暂时看不懂就先略过，未来有用到判断变量值时，再回来看看吧！^_^



10.3 命令别名与历史命令

- 我们知道在早期的 DOS 年代，清楚屏幕上的信息可以使用 cls 来清除，但是在 Linux 里面，我们则是使用 clear 来清除画面的。那么是否可以让 cls 等于 clear 呢？可以啊！
- 命令别名设定：alias，unalias 
  - 命令别名与变量有什么不同呢？命令别名是新创一个新的指令，你可以直接下达该指令的，至于变量则需要使用类似 echo 指令才能够呼叫出变量的内容。
- 历史命令：history 
  - HISTSIZE：目前环境下，内存中记录的历史命令最大笔数。
  - HISTFILESIZE：HISTFILE (一般为 \~/.bash_history) 文件中记录的最大命令笔数。
  - 那么 history 这个历史命令只可以让我查询命令而已吗？当然不止，我们可以利用相关的功能来帮我们执行命令呢！
    - `!number` ，执行第 number 笔命令。
    - `!command` ，由最近的指令向前搜寻指令串开头为 command 的那个指令，并执行。
    - `!!` ，执行上一个指令，相当于按 ↑ 按键后，再按 Enter 键。



10.4 Bash Shell 的操作环境

- 路径与指令搜寻顺序

  - 指令执行时搜索的顺序

    1. 以相对/绝对路径执行指令，例如 `/bin/ls` 或 `./ls` ；
    2. 由 alias 找到该指令来执行；
    3. 由 bash 内建的指令来执行；
    4. 通过 \$PATH 这个变量的顺序搜寻到的第一个指令来执行。

    举例来说，要想了解 ls 执行时搜寻的顺序，其实通过 `type -a ls` 也可以查询的到啦！

- bash 的进站与欢迎讯息：/etc/issue ，/etc/motd 

- bash 的环境配置文件

  - 你是否会觉得奇怪，怎么我们什么动作都没有进行，但是一进入 bash 就取得一堆有用的变量了？这是因为系统有一些环境配置文件的存在，让 bash 在启动时直接读取这些配置文件，以规划好 bash  的操作环境啦！而这些配置文件又可以分为全体系统的配置文件以及用户个人偏好配置文件。要注意的是，我们前几个小节谈到的命令别名啦、自定义的变量啦，在你注销 bash 后就会失效，所以你想要保留你的设定，就得要将这些设定写入配置文件才行。

  - login 与 non-login shell

    - 为什么要介绍 login，non-login shell 呢？这是因为这两个取得 bash 的情况中，读取的配置文件数据并不一样所致。由于我们需要登录系统，所以先谈谈 login shell 会读取哪些配置文件？一般来说，login shell 其实只会读取这两个配置文件：
      1. /etc/profile：这是系统整体的设定，最好不要修改这个文件；
      2. \~/.bash_profile 或 \~/.bash_login 或 \~/.profile：属于使用者个人设定，你要改自己的数据就写入这里！

  - /etc/profile (login shell 才会读) 

    - 反正你只要记得，bash 的 login shell 情况下所读取的整体环境配置文件其实只有 /etc/profile，但是 /etc/profile 还会呼叫出其它的配置文件，所以让我们的 bash 操作接口变得非常的友善啦！

  - \~/.bash_profile (login shell 才会读)

    - bash 在读完了整体环境设定的 /etc/profile 并借此呼叫其它配置文件后，接下来则是会读取使用者的个人配置文件。在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有三个，依序分别是：1）\~/.bash_profile ；2）\~/.bash_login ；3）\~/.profile 。其实 bash 的 login shell 设定只会读取这三个文件中的其中一个，按照读取的顺序，哪一个先读到就结束。会有这三个文件，其实是因为其它 shell 转换过来的使用者的习惯而已。

  - source：读入环境配置文件的指令

    - 由于 /etc/profile 与 \~/.bash_profile 都是在取得 login shell 的时候才会读取的配置文件，所以，如果你将自己的偏好设定写入上述文件后，通常都是得注销再登录后，该设定才会生效。那么，能不能直接读取配置文件而不注销登录呢？可以的！那就得要利用 source 这个指令了！

    - 利用 source 或小数点（.）都可以将配置文件的内容读进来目前的 shell 环境中，例如：

      `source ~/.bashrc` ，`. ~/.bashrc` 

  - \~/.bashrc (non-login shell 会读) 

  - 其它相关配置文件

    - /etc/man_db.conf
  - \~/.bash_history
    - \~/.bash_logout
    - 这个文件记录了当用户注销 bash 后，系统再帮用户做完什么动作后才离开。

- 终端机的环境设定：stty，set

  - 因为鸟哥的工作经常在 Windows/Linux 之间切换，在 Linux 底下使用 vim 时，却也经常不小心按了 [ctrl]+s ，问题来了，按下这个组合键后，整个 vim 就不能动了（整个画面锁死），请问鸟哥该如何处理？

    参考一下 stty -a 的输出中，有个 stop 的项目就是按下 [ctrl]+s ，那么恢复成 start 就是 [ctrl]+q 啊！因此，按下 [ctrl]+q 应该就可以让整个画面重新恢复正常啰！

  - 除了 stty 之外，其实我们的 bash 还有自己的一些终端机设定值呢？那就是利用 set 来设定的！

- 通配符与特殊符号

  - 在 bash 的操作环境中还有一个非常有用的功能，那就是通配符（wildcard），它让我们利用 bash 处理数据就更方便了！
  - 通配符（wildcard）：\* 、? 、[ ] 、[ - ] 、[^ ] 。
  - 除了通配符之外，bash 环境中的特殊符号：# 、\ 、\| 、; 、~ 、\$ 、& 、! 、/ 、>, \>\> 、<,\<\< 、' ' 、" " 、`` 、( ) 、{ } 。理论上，你的文件名尽量不要使用到上述的字符啦！



10.5 数据流重导向

- 什么是数据流重导向

  - standard output 与 standard error output

  - 数据流重导向可以将 standard output (简称 stdout) 与 standard error output (简称 stderr) 分别传送到其它的文件或装置去，而分别传送所用的特殊字符则如下所示：

    1. 标准输入（stdin）          ：代码为 0，使用 < 或 \<\< ；
    2. 标准输出（stdout）       ：代码为 1，> 或 \>\> ；
    3. 标准错误输出（stderr）：代码为 2，使用 2> 或 2\>\> ；

  - 1>，1\>\>，2>，2\>\> 的含义：

    - 1>  ：以覆盖的方法将 stdout 输出到指定的文件或装置上；
    - 1\>\>：以累加的方法将 stdout 输出到指定的文件或装置上；
    - 2>  ：以覆盖的方法将 stderr 输出到指定的文件或装置上；
    - 2\>\>：以累加的方法将 stderr 输出到指定的文件或装置上；

    如果仅存在 > ，则默认代表 1> 。

  - /dev/null 垃圾桶黑洞装置与特殊写法

    - 这个黑洞装置 /dev/null 可以吃掉任何导向这个装置的信息喔！

    - 如果要将正确与错误数据（stdout，stderr）通通写入同一个文件去呢？这个时候就得要使用特殊的写法了！

      `find /home -name .bashrc > list 2>&1` 或 `find /home -name .bashrc &> list` ，将指令执行的正确与错误数据全写入名为 list 的文件中。

      若使用 `find /home -name .bashrc > list 2> list` ，由于两股数据同时写入一个文件，又没有特殊的语法，此时两股数据可能会交叉写入该文件内，造成次序的错乱。

  - standard input：< 与 \<\<

    - 了解了 stderr 与 stdout 后，那么那个 < 又是什么呢？以最简单的说法来说，那就是将原本需要由键盘输入的数据，改由文件内容来取代的意思。
    - \<\< 代表的是结束的输入字符，例如 `cat > catfile << "eof"` ，用 cat 直接将输入的讯息输出到 catfile 中，且当由键盘输入 eof 时，该次输入就结束。
    - 利用 \<\< 右侧的控制字符，我们可以终止一次输入，而不必输入 [ctrl]+d 来结束哩！

  - 既然有 2>&1 来将 2> 转到 1> 去，那么应该也会有 1>&2 吧？没错，就是这个概念！

    `echo "error message" 2> /dev/null 1>&2` 

- 命令执行的判断依据：；、&&、\|\| 

  - `cmd ; cmd`（cmd，command，不考虑指令相关性的连续指令下达）
  - \$? (指令回传值) 与 && 或 \|\| 
    - `cmd1 && cmd2` 
    - `cmd1 || cmd2` 
    - `ls /tmp/abc || mkdir /tmp/abc && touch /tmp/abc/hehe` ，无论 /tmp/abc 是否存在，都会建立 /tmp/abc/hehe 文件。Linux 底下的指令都是由左往右执行的。 



10.6 管线命令（pipe）

- `ls -al /etc | less` ，这个管线命令「\|」仅能处理由前面一个指令传来的正确信息，也就是 standard output 的信息，对于 standard error 并没有直接处理的能力。

- 在每个管线后面接的第一个数据必定是指令喔！而且这个指令必须要能够接受 standard input 的数据才行，这样的指令才可以视为管线命令，例如 less，more，head，tail 等都是可以接受 standard input 的管线命令。至于 ls，cp，mv 等就不是管线命令了，因为 ls，cp，mv 并不会接受来自 stdin 的数据。也就是说，管线命令有两个比较需要注意的地方：

  - 管线命令仅会处理 standard output，对于 standard error output 会予以忽略；
  - 管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行；

- 想一想，如果你硬要让 standard error 可以被管线命令使用，那该如何处理？其实就是透过上一小节的数据流重导向即可！让 2>&1 加入指令中，就可以让 2> 变成 1> 啰！

- 撷取命令：cut ；grep 

  - 什么是撷取命令啊？就是将一段数据经过分析后，取出我们想要的，或者是经由分析关键词，取得我们想要的那一行。不过，要注意的是，一般来说，撷取讯息通常是针对一行一行来分析的，并不是整篇讯息分析的喔~ 
  - cut
    - cut 不就是切吗？没错啦！这个指令可以将一段讯息的某一段给它切出来，处理的讯息是以行为单位喔！
    - cut 主要的用途在于将同一行里面的数据进行分解！最常使用在分析一些数据或文字数据的时候！不过 cut 在处理多空格相连的数据时，可能会比较吃力一点，所以某些时刻可能会使用下一章的 awk 来取代 cut 。
  - grep
    - 前面的 cut 是将一行讯息当中，取出某部分我们想要的，而 grep 则是分析一行讯息，若当中有我们所需要的信息，就将该行拿出来~ 

- 排序命令：sort 、wc 、uniq 

  - sort 
    - sort 可以帮我们进行排序，而且可以依据不同的数据型态来排序喔！例如数字与文字的排序就不一样（默认是以文字型态来排序的）。此外，排序的字符与语系的编码有关。
  - uniq 
    - 如果我排序完成了，想要将重复的资料仅列出一个显示，可以怎么做呢？使用 uniq 指令可以用来将重复的行删除掉，只显示一个。
  - wc 
    - 如果我想要知道 /etc/man_db.conf 这个文件里面有多少字？多少行？多少字符的话，怎么做呢？可以利用 wc 这个指令来达成喔！它可以帮我们计算输出的讯息的整体数据。

- 双向重导向：tee

  - tee 会同时将数据流分送到文件与屏幕（screen），而输出到屏幕的，其实就是 stdout，那就可以让下个指令继续处理喔！

- 字符转换命令：tr 、col 、join 、paste 、expand

  - tr
    - tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换！
    - 除了前面讲过的 dos2unix 之外，我们也可以使用 tr 来将 ^M 去除，^M可以使用 \\r 来代替。
  - col
    - 虽然 col 有其它特殊的用途，不过，很多时候，它可以用来简单地处理，将 [tab] 按键取代成为空格键。
  - join
    - 处理两个文件之间的数据，而且，主要是在处理两个文件当中，有相同数据的那一行，才将它们加在一起。
  - paste 
    - 这个 paste 就要比 join 简单多了，相对于 join 必须要比对两个文件的数据相关性，past 就直接将两行贴在一起，且中间默认以 [tab] 键隔开。 
  - expand
    - 将 [tab] 键转成空格键。
    - unexpand：将空白转成 [tab] 。（这里空白应该也就是指空格）

- 分区命令：split 

  - 如果你有文件太大，导致一些便携式装置无法复制的问题，找 split 就对了！它可以帮你将一个大文件，依据文件大小或行数来分区，就可以将大文件分区成为小文件了！
  - 在重定向中，如果命令需要 stdout/stdin 时，但偏偏没有文件，有的只是 - ，那么这个 - 就会被当成 stdin 或 stdout 。
  - 在 Windows 操作系统下，你要将文件分区需要如何作？伤脑筋吧！在 Linux 底下就简单得多了！你要将文件分区的话，那么就使用 split 的 -b size 来限制一个分区文件的大小，如果是行数的话，那么就使用 split 的 -l line 来分区。

- 参数代换：xargs 

  - xargs 用来产生某个指令的参数。它可以读入 stdin 的数据，并且以空格符或断行字符作为分辨，将 stdin 的数据分隔成为 arguments 。因为是以空格符作为分隔，所以，如果有一些文件名或者是其它意义的名词内含有空格符的时候，xargs 可能就会误判了~ 它的用法其实也还蛮简单的！
  - xargs 真的是很好用的一个玩意儿，很多指令其实并不支持管线命令，因此我们可以通过 xargs 来提供该指令引用 standard input 之用。

- 关于减号 - 的用途

  - 在管线命令当中，常常会使用到前一个指令的 stout 作为这次的 stdin，某些指令需要用到文件名（例如 tar）来进行处理时，该 stdin 与 stdout 可以利用减号 - 来替代，例如：

    `mkdir /tmp/homeback; tar -cvf - /home | tar -xvf - -C /tmp/homeback` 



10,7 重点回顾

- 用户登录取得的默认 shell 记录于 /etc/passwd 的最后一个字段。
- 管线命令的重点是：管线命令仅会处理 standard output ，对于 standard error output 会予以忽略。管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行。
- 本章介绍的管线命令主要有：cut，grep，sort，wc，uniq，tee，tr，col，join，paste，expand，split，xargs 等。



鸟哥的 Changelog: Chapter 10

- 2016-04-21：修订了 sort 的语法，原本的 `-k 3` 不对，`-k 3,3` 才是正确的。



&nbsp;

### 第十一章 正则表达式与文件格式化处理



- 正则表达式并不是一个工具程序，而是一个字符串处理的标准依据，如果你想要以正则表达式的方式处理字符串，就得使用支持正则表达式的工具程序才行，这类的工具程序有很多，例如 vi，sed，awk 。
- 本章使用者需要多加练习，因为目前很多的套件都是使用正则表达式来达成其过滤、分析的目的，为了未来主机管理的便利性，使用者至少要能看得懂正则表达式的意义。



11.1 开始之前：什么是正则表达式 

- 什么是正则表达式 
- 正则表达式对于系统管理员的用途
- 正则表达式的广泛用途
- 正则表达式与 Shell 在 Linux 当中的角色定位
- 延伸的正则表达式
  - 正则表达式的字符串表示方法依照不同的严谨度而分为：基础正则表达式与延伸正则表达式。
- 正则表达式与通配符是完全不一样的东西！因为通配符（wildcard）代表的是 bash 操作接口的一个功能，但正则表达式则是一种字符串处理的表示方法！这两者要分得很清楚才行喔！



11.2 基础正则表达式

- 语系对正则表达式的影响

  - 由于一般我们在练习正则表达式时，使用的是兼容于 POSIX 的标准，因此就使用 C 这个语系。所以，这章中的很多练习都是使用 LANG=C 这个语系数据来进行的喔！
  - 另外，为了要避免语系编码所造成的英文与数字的撷取问题，有些特殊的符号我们得了解一下的。在这些特殊符号中 [:alnum:]，[:alpha:]，[:upper:]，[:lower:]，[:digit:] 这几个一定要知道代表什么意思。

- grep 的一些进阶选项

- 基础正则表达式练习

  - 例题一，搜寻特定字符串

  - 例题二，利用中括号 [] 来搜寻集合字符

  - 例题三，行首与行尾字符：^，\$ 

    - ^ 在字符集合（括号 []）之内与之外是不同的！在 [] 内代表反向选择，在 [] 之外则代表定位在行首的意义，例如 `'^[^a-zA-Z]'` 表示开头不是英文字母的字符串。

    - '\\.\$' ，行尾结束为小数点。因为小数点在正则表达式中具有其它意义，所以必须要使用跳脱字符（\）来加以解除其特殊意义。

    - '^\$' ，表示空白行。

      `grep -v '^$' /etc/rsyslog.conf | grep -v '^#'` ，找出 /etc/rsyslog.conf 中不是空白行，不是以 # 开头的内容。

  - 例题四、任意一个字符 . 与重复字符 \*

    - 在第十章 bash 中，我们知道通配符 \* 可以用来代表任意（0或多个）字符。但是正则表达式不是通配符，两者之间是不相同的。. 和 \* 这两个符号在正则表达式中的意义如下：
      - . （小数点）：代表一定有一个任意字符的意思。
      - \* （星号）   ：代表重复前一个字符，0 到无穷多次的意思，为组合形态。
    - o\* 代表的是拥有空字符或一个 o 以上的字符，特别注意，因为允许空字符就是有没有字符都可以的意思，因此 `gren -n 'o*' regular_express.txt` 将会把所有的数据都打印到屏幕上。
    - .\* 代表 0 个或多个任意字符。

  - 例题五、限定正则表达式中连续字符范围，{}

    - 举例来说，如果想要找出两个到五个 o 的连续字符串，该怎么做？这就得要使用限定范围的字符 {} 了。但因为 { 与 } 的符号在 shell 是有特殊意义的，因此必须要使用跳脱字符 \ 来让它失去特殊意义才行，例如找到两个 o 的字符串，'o\\{2\\}' 。

- 基础正则表达式字符汇整（characters）
  - ^word ：待搜寻的字符串（word）在行首。
  - word\$ ：待搜寻的字符串（word）在行尾。
  - . ：代表一定有一个任意字符。
  - \\ ：跳脱字符，将特殊符号的特殊意义去除。
  - \* ：重复 0 个到无穷多个的前一个 RE 字符。
  - [afl] ：字符集合的 RE 字符，代表 a 或 f 或 l 的意思。
  - [A-Z] ：字符集合的 RE 字符，代表 A 到 Z 这两个字符之间的所有连续字符，包括 A 和 Z。
  - \\{n,m\\} ：连续 n 到 m 个的前一个 RE 字符。若为 \\{n\\} 则是连续 n 个的前一个 RE 字符。若为 \\{n,\\} 则是，连续 n 个以上的前一个 RE 字符。
  - 再次强调：正则表达式的特殊字符与一般在指令列输入指令的通配符并不相同。例如在通配符当中的 \* 代表的是 0 至无限多个字符的意思，但是在正则表达式当中 \* 则是重复 0 到无穷多个的前一个 RE 字符的意思~使用的意义并不相同，不要搞混了！
  - 举例来说，不支持正则表达式的 ls 这个工具中，若使用 `ls -l *` 代表的是任意文件名的文件，而 `ls -l a*` 代表的是以 a 开头的任何文件名的文件。但在正则表达式中，我们要找到含有以 a 开头的文件，则必须要这样（需搭配支持正则表达式的工具）：` ls | grep -n '^a.*'` 
- sed 工具
  - 在了解了一些正则表达式的基础应用后，有两个东西可以玩一玩的，那就是 sed 和 awk，这两个家伙可是相当的有用啊！我们先来谈一谈 sed，sed 本身是一个管线命令，可以分析 standard input 的啦！而且 sed 还可以将数据进行取代、删除、新增、撷取特定行等功能。
  - 以行为单位的新增/删除功能
  - 以行为单位的取代与显示功能
  - 部分数据的搜寻并取代的功能
  - 直接修改文件内容（危险动作）



11.3 延伸正则表达式

- 事实上，一般读者只要了解基础型的正则表达式大概就已经相当足够了，不过，某些时刻为了要简化整个指令操作，了解一下使用范围更广的延伸型正则表达式会更方便呢！举个简单的例子，在上一节中我们要除去空白行与行首为 \# 的行，使用的是：

   `grep -v '^$' regular_express.txt | grep -v '^#'` 

  需要使用到管线命令来搜寻两次，那么如果使用延伸型的正则表达式，可以简化为：

   `egrep -v '^$|^#' regular_express.txt` 

- grep 默认仅支持基础正则表达式，如果要使用延伸型正则表达式，可以使用 grep -E ，不过更建议直接使用 egrep 。直接区分指令比较好记忆，其实 egrep 与 grep -E 是类似命令别名的关系啦！

- 延伸型正则表达式的几个特殊符号：

  - \+   ：重复一个或一个以上的前一个 RE 字符。
  - ?    ：零个或一个的前一个 RE 字符。
  - \|   ：用或的方式找出数个字符串。
  - ()   ：找出群组字符串。'g(la\|oo)d' ，代表 glad 或 good 。
  - ()+ ：多个重复群组的判别。'A(xyz)+C'，开头是 A，结尾是 C，中间有一个以上的 "xyz" 字符串的意思。



11.4 文件的格式化与相关处理

- 接下来让我们来将文件进行一些简单地编排吧！底下这些动作可以将你的讯息进行排版的动作，不需要重新以 vim 去编辑，通过数据流重导向配合底下介绍的 printf 功能，以及 awk 指令，就可以让你的讯息以你想要的模样来输出了。
- 格式化打印：printf 
  - printf 不是管线命令。
  - printf 的使用相当的广泛喔！包括后面会提到的 awk 以及 C 程序语言当中使用的屏幕输出，都是利用 printf 呢！
- awk ：好用的数据处理工具
  - awk 也是一个非常棒的数据处理工具！相对于 sed 常常用作于一整个行的处理，awk 则比较倾向于一行当中分成数个字段来处理。
  - awk 后面接两个单引号并加上大括号 {} 来设定想要对数据进行的处理动作。awk 可以处理后续接的文件，也可以读取来自前个指令的 standard output 。
  - `last -n 5 | awk '{print $1 "\t" $3}'` 在 awk 的括号内，每一行的字段都是有变量名称的，那就是 \$1，\$2，\$3... 等变量名称，此外 \$0 代表一整行数据的意思。
  - 整个 awk 的处理流程是：
    1. 读入第一行，并将第一行的资料填入 \$0，\$1，\$2 … 等变量当中；
    2. 依据条件类型的限制，判断是否需要进行后面的动作；
    3. 做完所有的动作与条件类型；
    4. 若还有后续的行的数据，则重复上面 1-3 的步骤，直到所有的数据都读完为止。
  - awk 的内建变量：
    - NF ：每一行（\$0）拥有的字段总数。
    - NR：目前 awk 所处理的是第几行数据。
    - FS ：目前的分隔字符，默认是空格键。
  - awk 的逻辑运算符
- 文件比对工具
  - 什么时候会用到文件的比对？通常是同一个软件包的不同版本之间比较文件的差异。
  - diff
    - 对比两个文件之间的差异，并且以行为单位来比对的，一般是用在 ASCII 纯文本文件的比对上。
  - cmp
    - 相对于 diff 的广泛用途，cmp 似乎就用得没这么多了\~ cmp 主要也是在比对两个文件，但主要利用字节单位去比对的。因此，当然也可以比对 binary file 啰~（还是要再次提醒，diff 主要是以行为单位比对，cmp 则是以字节为单位去比对，这并不相同。）
  - patch
    - 这个指令与 diff 有密不可分的关系。我们可以利用 diff 来比对两个文件之间的差异，更可进一步利用这个功能来制作修补文件（patch file）。
- 文件打印准备：pr



11.5 重点回顾



11.7 参考资料

- [Shell 和 Shell Script](http://www.study-area.org/linux/system/linux_shell.htm) 



鸟哥的 Changelog: Chapter 11

- 2019-05-23：感谢网友 marjune 的来信，提到了正则表达式当中许多中介符号的意义：GNU 正则表达式，鸟哥做了一些修订（在这章 12.2.3 的例题五、限定连续 RE 字符范围 {} 中，对 { 、\\{ 的描述进行了一点修改）



&nbsp;

### 第十二章 学习 Shell Scripts 



12.1 什么是 shell scripts

- shell script 是利用 shell 的功能所写的一个程序，这个程序是使用纯文本文件，将一些 shell 的语法与指令（含外部指令）写在里面，搭配正则表达式、管线命令与数据流重导向等功能，以达到我们所想要的处理的目的。
- 简单地说，shell script 就像是早期 DOS 年代的批处理文件（.bat），最简单的功能就是将许多指令汇整在一起，让使用者很轻易地就能够 one touch 的方法去处理复杂的动作（执行一个文件 “shell script” ，就能够一次执行多个指令）。而且 shell script 更提供数组、循环、条件与逻辑判断等重要功能，让用户也可以直接以 shell 来撰写程序，而不必使用类似 C 程序语言等传统程序撰写的语法。
- 干嘛学习 shell scripts 
  - 自动化管理的重要依据
  - 追踪与管理系统的重要工作
  - 简单入侵检测功能
  - 连续指令单一化
  - 简易的数据处理
  - 跨平台支持与学习历程较短
- 第一支 script 的撰写与执行
  - 假设写的这个 script 程序的文件名是 /home/dmtsai/shell.sh，那如何执行这个文件？很简单，有这几种方法：
    - 直接指令下达：shell.sh 文件必须要具备可读与可执行（rx）的权限，然后：
      - 绝对路径：使用 /home/dmtsai/shell.sh 来下达指令；
      - 相对路径：假设工作目录在 /home/dmtsai/，则使用 ./shell.sh 来执行；
      - 变量 PATH 功能：将 shell.sh 放在 PATH 指定的目录内，例如：\~/bin/ 。
    - 以 bash 程序来执行：通过 `bash shell.sh` 或 `sh shell.sh` 来执行。
  - 撰写第一支 script
    - 在武侠世界中，无论是哪个门派，要学武功都要从扫地与蹲马步做起，那么要学程序呢？呵呵，肯定是由秀出 Hello World! 这个字眼开始的！
    - `sh hello.sh` ，执行这个 hello.sh，另外，也可以利用 `chmod a+x hello.sh; ./hello.sh` 来执行这个 script 。
- 撰写 shell script 的良好习惯建立



12.2 简单的 shell script 练习

- 简单范例

  - 对谈式脚本：变量内容由用户决定

  - 随日期变化：利用 date 进行文件的建立

  - 数值运算：简单的加减乘除

    - 我们可以使用 declare 来定义变量的类型，当变量定义成整数后才能够惊喜加减乘除运算。此外，我们也可以使用 `$((计算式))` 来进行数值运算，不过，在 bash shell 里默认仅支持到整数的数据而已。

    - `total=$((${firstnu}*${secnu}))` 等效于 `declare -i total=${firstnu}*${secnu}` 

    - 如果你想要计算含有小数点的数据时，可以通过 bc 这个指令的协助。例如：

      `echo "123.123\*55.9" | bc` 

  - 数值运算：通过 bc 计算 pi 

- script 的执行方式差异（source，sh script，./script）

  - 利用直接执行的方式来执行 script 
    - 该 script 会使用一个新的 bash 环境来执行脚本内的指令，也就是说，使用这种执行方式时，script 是在子程序的 bash 内执行的！
  - 利用 source 来执行脚本：在父程序中执行 



12.3 善用判断式

- 在第十章中，我们提到过 \$? 这个变量所代表的意义，此外，也通过 &&、\|\| 来作为前一个指令执行回传值对于后一个指令是否要进行的依据。是否有更简单的方式可以来进行条件判断呢？有的，那就是 test 这个指令。

- 利用 test 指令的测试功能

- 利用判断符号 []

  - 除了 test 之外，我们还可以利用判断符号 []（就是中括号啦）来进行数据的判断。举例来说，如果我们想知道 \${HOME} 这个变量是否为空，可以这样做：

    `[ -z "${HOME}" ]; echo $?` 

    使用中括号必须要特别注意，因为中括号用在很多地方，包括通配符与正则表达式等，如果要在 bash 的语法当中使用中括号作为 shell 的判断式时，必须要注意中括号的两端需要有空格符来分隔喔！

  - 在 bash 中使用中括号来判断时， `[ "$HOME" == "$MAIL" ]` ，你会发现鸟哥在这个判断式中，使用了两个等号「==」，其实在 bash 当中使用一个等号与两个等号的结果是一样的，不过在一般惯用程序的写法中，一个等号代表变量的设置，两个等号则是代表逻辑判断（是与否之意）。由于我们在中括号内重点在于判断而非设定变量，因此鸟哥建议你还是使用两个等号较佳。

  - 利用 [] 来进行判断时，还要注意：

    - 在中括号 [] 内的每个组件都需要有空格键来分隔；
    - 在中括号内的变量，最好都以双引号括起来；
    - 在中括号内的常数，最好都以单引号或双引号括起来。

  - 利用 [] 来进行判断时，使用的方式与 test 几乎一模一样！

- shell script 的默认变量（\$0，\$1，\$2 …）

  - ```
    /path/to/scriptname  opt1  opt2  opt3  opt4
            $0            $1    $2    $3    $4
    ```

  - 执行的脚本文件名为 \$0 这个变量，后面接的参数依次为变量 \$1，\$2 … 。除了这些数字的变量之外，还有一些较为特殊的变量可以在 script 内使用：\$# 、 \$@ 、 \$\* 。

  - shift：造成参数变量的偏移

    - shift 会移动变量，而且 shift 后面可以接数字，代表拿掉最前面的几个变量参数，默认为 1 。



12.4 条件判断式 

- 利用 if ... then

  - 单层、简单条件判断式

    ```
    if [ 条件判断式 ]; then
      cmd
    fi
    ```

    

  - 多重、复杂条件判断式

    ```
    if [ 条件判断式 ]; then
          cmd
    else
          cmd
    fi
    ```

    更复杂的情况

    ```
    if [ 条件判断式一 ]; then
          cmd
    elif [ 条件判断式二 ]; then
          cmd
    else
          cmd
    fi
    ```

    

- 利用 case ...... esac 判断

  - case ... in ... esac 的语法如下：

    ```
    case $变量名称 in
      "第一个变量内容")
          程序段
          ;;
      "第二个变量内容")
          程序段
          ;;
      *)
          程序段
          exit 1
          ;;
    esac
    ```

    

- 利用 function 功能

  - function 的语法：

    ```
    function fname() {
        cmd
    }
    ```

    这个 fname 就是我们自定义的执行指令名称，而程序段就是它执行的内容。要注意的是，因为 shell script 的执行方式是由上而下，由左而右，因此在 shell script 当中， function 的设定一定要在程序的最前面，这样才能够在执行时被找到。

  - 另外，function 也是拥有内建变量的，他的内建变量与 shell script 很类似，函数名称代表为 \$0，而后续接的变量也是用 \$1，\$2 … 来取代。但这些 \$0，\$1，\$2 … 和 shell script 的 \$0，\$1，\$2 … 是不同的，作用的范围不一样。



12.5 循环（loop）

- 除了 if ... then .. fi 这种条件判断式之外，循环可能是程序当中最重要的一环了~ 循环可以不断地执行某个程序段落，直到用户设定的条件达成为止。除了这种依据判断式达成与否的不定循环之外，还有另外一种已经固定要跑多少次的循环形态，可称为固定循环的形态。

- while do done，until do done（不定循环）

  - while 循环

    ```
    while [ condition ]
    do
        cmd
    done
    ```

    当 condition 条件成立时，就进行循环，直到 condition 的条件不成立才停止。

  - until 循环

    ```
    until [ condition ]
    do
        cmd
    done
    ```

    当 condition 条件成立时，就终止循环，否则就持续执行循环体中的 cmd 。

- for … do … done （固定循环）

  - for 这种循环，则是已经知道要进行几次循环的状态，它的语法是：

    ```
    for var in con1 con2 con3 …
    do
        cmd
    done
    ```

    以上面的这个例子来说，第一次循环时 \$var 的内容为 con1；第二次循环时 \$var 的内容为 con2；第三次循环时 \$var 的内容为 con3 ...

  - \$(seq …) ，seq 是连续（sequence）的缩写之意，代表后面接的两个数值是一直连续的，比如：`$(seq 1 100)` 表示 1，2，3，…，100。此外，也可以使用 `{1..100}` 来取代 `$(seq 1 100)` ，那个大括号内的前面/后面用两个字符，中间以两个小数点来代表连续出现的意思！

- for … do … done 的数值处理

  - for 循环还有另外一种写法，语法如下：

    ```
    for ((初始值；限制值；执行步阶))
    do
        cmd
    done
    ```

    这种语法适合于数值方式的运算当中。

- 搭配随机数与数组的实验



12.6 shell script 的追踪与 debug

- `sh [-nvx] script.sh` ，其中选项 -n，-v，-x 的含义分别为：
  - -n：不要执行 script.sh ，仅查询语法的问题；
  - -v：再执行 script.sh 前，先将 script.sh 的内容输出到屏幕上；
  - -x：将使用到的 script.sh 内容显示到屏幕上，这是很有用的参数！
- 熟悉 sh 的用法，将可以使你在管理 Linux 的过程中得心应手！至于在 shell script 的学习方法上，需要多看，多模仿，并加以修改成自己的样式，这是最快的学习手段了！网络上有相当多的朋友在开发一些相当有用的 scripts，若是你可以将对方的 scripts 拿来，并且改成适合自己主机的样子，那么学习的效果会是最快的呢！



12.7 重点回顾



鸟哥的 Changelog: Chapter 12

- 2017-03-29：网友建议将 \$@ 改成 "\$@" 的相关说明~ 鸟哥测试一下，确实有点差异喔！尤其是参数内有空白时，差异最大！



&nbsp;

## 第四部分 Linux 使用者管理



### 第十三章 Linux 账号管理与 ACL 权限设定



13.1 Linux 的账号与群组

- 使用者标识符：UID 与 GID
- 使用者账号
  - /etc/passwd 文件结构
  - /etc/shadow 文件结构
- 关于群组：有效与初始群组、groups，newgrp
  - /etc/group 文件结构
  - 有效群组（effective group）与初始群组（initial group）
  - groups ：有效与支持群组的观察
  - newgrp ：有效群组的切换
  - /etc/gshadow



13.2 账号管理

- 新增与移除使用者：useradd，相关配置文件，passwd，usermod，userdel

  - useradd 

  - useradd 参考文件

  - passwd 

    - root 用户要帮一般账号建立密码需要使用「passwd 账号」的格式，使用「passwd」表示修改自己的密码。

  - chage 

    - ```
      useradd agetest
      echo "agetest" | passwd --stdin agetest
      chage -d 0 agetest
      chage -l agetest | head -n 3
      ```

  - usermod 

  - userdel

    - `userdel -r vbird2` ，将 vbird2 连同它的家目录也一起删除。

- 用户功能

  - id
  - finger
    - 默认没有安装这个指令，与 dos2unix 命令类似，在挂载光盘后用 rpm 可以安装。
  - chfn 
  - chsh 

- 新增与移除群组

  - groupadd 
  - groupmod 
  - groupdel 
  - gpasswd ：群组管理员功能 

- 账号管理实例

- 使用外部身份认证系统



13.3 主机的细部权限规划：ACL 的使用

- 什么是 ACL 与如何支持启动 ACL

  - ACL（Access Control List），主要目的是在提供传统的 owner，group，others 的 read，write，execute 权限之外的细部权限设定。ACL 可以针对单一使用者，单一文件或目录来进行 r，w，x 的权限规范，对于需要特殊权限的使用状况非常有帮助。

  - 那 ACL 主要可以针对哪些方面来控制权限呢？它主要可以针对以下三个项目：

    - 使用者（user）：可以针对使用者来设定权限；
    - 群组（group）：针对群组为对象来设定其权限；
    - 默认属性（mask）：还可以针对在该目录下建立新文件/目录时，规范新数据的默认权限。

  - 如何启动 ACL

    - 事实上，原本 ACL 是 unix-like 操作系统的额外支持项目，但因为近年以来 Linux 系统对权限细部设定的热切需求，因此目前 ACL 几乎已经默认加在所有常见的 Linux 文件系统的挂载参数中（ext2/ext3/ext4/xfs 等等），所以你无须进行任何动作，ACL 就可以被你使用啰！不过，如果你不放心系统是否真的有支持 ACL 的话，也可以检查一下核心挂载时显示的信息：

      `dmesg | grep -i acl` 

- ACL 的设定技巧：getfacl，setfacl 

  - setfacl 指令用法介绍及最简单的 u:账号:权限 设定
  - getfacl 指令用法
  - 特定的单一群组的权限设定：g:群组名:权限
  - 针对有效权限设定：m:权限
  - 使用默认权限设定目录未来文件的 ACL 权限继承 d:[u\|g]:[user\|group]:权限



13.4 使用者身份切换

- 平常使用一般账号登录系统，等有需要进行系统维护或软件更新时才转为 root 的身份来动作，那如何让一般使用者转变身份成为 root 呢？主要有两种方式：

  - 以 `su -` 直接将身份变成 root 即可，但是这个指令却需要 root 的密码，也就是说，如果你要以 su 变成 root 的话，你的一般使用者就必须要有 root 密码才行；
  - 以 `sudo 指令` 执行 root 的指令串，由于 sudo 需要事先设定妥当，且 sudo 需要输入用户自己的密码，因此多人共管同一部主机时，sudo 要比 su 来得好喔！至少 root 密码不会流出去！

- su

  - `su -` 
  - `su - -c "head -n 3 /etc/shadow"` 
  - `su -l vbird1` 或 `su - vbird1` 

- sudo

  - sudo  的执行仅需要自己的密码，甚至可以设定不需要密码即可执行 sudo 呢！由于 sudo 可以让你以其它用户的身份执行指令（通常是使用 root 的身份来执行指令），因此并非所有人都能够执行 sudo ，而是仅有规范到 /etc/sudoers 内的用户才能够执行 sudo 这个指令喔！

  - sudo 的指令用法

    - `sudo -u sshd touch /tmp/mysshd` 

    - ```
      sudo -u vbird1 sh -c "mkdir ~vbird1/www; cd ~vbird1/www; \
      echo 'This is index.html file' > index.html"
      ```

    - sudo 可以让你切换身份来进行某项任务，在上面的第一个例子中，我们的 root 使用 sshd 的权限去创建一个文件，因为我们无法使用 `su - sshd` 去切换系统账号（该系统账号的 shell 是 /sbin/nologin），这个时候 sudo 就非常好用了，立刻以 sshd 的权限在 /tmp 底下建立文件。至于上面的第二个例子则使用了多重指令串（通过分号 ; 来延续指令进行），使用 sh -c 的方法来执行一连串的指令。

  - visudo 与 /etc/sudoers

    - 单一用户可进行 root 所有指令，与 sudoers 文件语法
    - 利用 wheel 群组以及免密码的功能处理 visudo
    - 有限制的指令操作
    - 通过别名设置 visufo
    - sudo 的时间间隔问题
    - sudo 搭配 su 的使用方式



13.5 用户的特殊 shell 与 PAM 模块

- 特殊的 shell，/sbin/nologin
- PAM 模块简介
- PAM 模块设置语法
- 常用 PAM 模块简介
- 其它相关的 PAM 文件



13.6 Linux 主机上的用户讯息传递

- 查询使用者：w，who，last，lastlog
- 使用者对谈：write，mesg，wall 
- 使用者邮件信箱：mail 



13.7 CentOS 7 环境下大量创建账号的方法

- 一些账号相关的检查工具
  - pwck
  - pwconv
  - pwunconv
  - chpasswd
- 大量创建账号模板（适用 passwd -\-stdin 选项）



13.8 重点回顾



13.10 参考资料

- [远程连接服务器](http://linux.vbird.org/linux_server/0310telnetssh.php)



鸟哥的 Changelog: Chapter 13

- 2016-10-04：passwd -i 后面应该是接天数，而不是接日期！感谢网友讨论区的回报！



&nbsp;

### 第十四章 磁盘配额（Quota）与进阶文件系统管理



14.1 磁盘配额（Quota）的应用与实作

- 什么是 Quota
  - Quota 的一般用途
  - Quota 的使用限制
  - Quota 的规范设定项目
- 一个 XFS 文件系统的 Quota 实作范例
- 实作 Quota 流程-1：文件系统的支持与观察
- 实作 Quota 流程-2：观察 Quota 报告资料
- 实作 Quota 流程-3：限制值设定方式
- 实作 Quota 流程-4：project 的限制（针对目录限制）（Optional）
- XFS quota 的管理与额外指令对照表
- 不更动既有系统的 quota 实例



14.2 软件磁盘阵列（Software RAID）

- 什么是 RAID
  - RAID (Redundant Arrays of Independent Disks, RAID) ，独立容错式磁盘阵列。（注：本地 PDF 上这个名词解释是错的，鸟哥 2017 年 3 月修改了这一处。）
  - 整个 RAID 由于选择的等级（level）不同，而使得整合后的磁盘具有不同的功能，基本常见的 level 有这几种：
    - RAID-0（等量模式，stripe），效能最佳。
    - RAID-1（镜像模式，mirror），完整备份。
    - RAID 1+0 或 RAID 0+1 。目前储存设备厂商最推荐 RAID 1+0 的方法。
    - RAID 5，效能与数据备份的均衡考虑。
    - RAID 6，RAID 5的升级，由于 RAID 5 仅能支持一颗磁盘的损毁，因此发展出了 RAID 6，它使用两颗磁盘的容量作为 parity 的储存，因此整体的磁盘容量就会少两颗，但允许出错的磁盘数量就可以达到两颗了。
  - Spare Disk，预备磁盘的功能。
  - 磁盘阵列的优点
- software，hardware RAID 
- 软件磁盘阵列的设定
  - 以 mdadm 创建 RAID
  - 格式化与挂载使用 RAID
- 仿真 RAID 错误的救援模式
  - 设定磁盘为错误（fault）
  - 将出错的磁盘移除并加入新磁盘
- 开机自动启动 RAID 并自动挂载
- 关闭软件 RAID



14.3 逻辑卷轴管理员（Logical Volume Manager）

- LVM 的重点在于可弹性地调整 filesystem 的容量，而并非在于效能与数据保全上面。需要文件的读写效能或者是数据的可靠性，请参考前面的 RAID 。LVM 可以整合多个实体 partition 在一起，让这些 partitions 看起来就像是一个磁盘一样，而且还可以在未来新增或移除其它的实体 partition 到这个 LVM 管理的磁盘当中。如此一来，整个磁盘空间的使用上，实在是相当的具有弹性啊！
- 什么是 LVM：PV，PE，VG，LV 的意义
  - PV, Physical Volume，实体卷轴
  - VG, Volume Group，卷轴群组
  - PE, Physical Extent，实体范围区块
  - LV, Logical Volume，逻辑卷轴
  - 实作流程
- LVM 实作流程
  - Disk 阶段（实际的磁盘）
  - PV 阶段
  - VG 阶段
  - LV 阶段
  - 文件系统阶段
- 放大 LV 容量
- 使用 LVM thin Volume 让 LVM 动态自动调整磁盘使用率
- LVM 的 LV 磁盘快照
- LVM 相关指令汇整与 LVM 的关闭



14.4 重点回顾



鸟哥的 Changelog: Chapter 14

- 2017-03-29：将 RAID 的名称做个修订~ 感谢网友的建议



&nbsp;

### 第十五章 例行性工作排程（crontab）



15.1  什么是例行性工作排程

- 排程，schedule，对应的大陆这边简体中文含义应该是调度的意思，在 24.1.5 中的核心原始码下的次目录有提到「kernel：定义核心的程序、核心状态、线程、程序的排程（schedule）、程序的讯号（signal）等」，在本地 PDF 上 p1031 页，其中「程序」在大陆这边简体中文的含义应该也就是指进程。  
- Linux 的例行性工作是如何进行排程的呢？所谓的排程就是将这些工作安排执行的流程之意！咱们的 Linux 排程就是通过 crontab 与 at 这两个东西！
- Linux 工作排程的种类：at，crontab
- CentOS Linux 系统上常见的例行性工作
  - 进行登录文件的轮替（log rotate）
  - 登录文件分析 logwatch 的任务
  - 建立 locate 的数据库
  - man page 查询数据库的建立
  - RPM 软件登录文件的建立
  - 移除暂存文件
  - 与网络服务有关的分析行为



15.2 仅执行一次的工作排程

- atd 的启动与 at 运行的方式
  - `systemctl restart atd`
  - `systemctl enable atd`
  - `systemctl status atd`
  - at 的运行方式
- 实际运行单一工作排程
  - 当我们使用 at 时，会进入一个 at shell 的环境来让用户下达工作指令，此时，建议你最好使用绝对路径来下达指令，这样比较不容易出现问题。
  - at 工作的管理
    - `atq`
    - `atrm jobnumber`
    - 可以利用 atq 来查询，利用 atrm 来删除错误的指令，利用 at 来直接下达单一工作排程！不过有个问题需要处理一下，如果你是在一个非常忙碌的系统下运行 at，能不能指定你的工作在系统较闲的时候才进行呢？可以的，那就使用 batch 指令吧！
  - batch：系统有空时才进行背景任务
    - `uptime`
    - `batch`
    - `jobs`
    - `kill -9 %1 %2 %3 %4` 



15.3 循环执行的例行性工作排程

- 相对于 at 是仅执行一次的工作，循环执行的例行性工作排程则是由 cron (crond) 这个系统服务来控制的。刚刚谈过 Linux 系统上面原本就有非常多的例行性工作，因此这个系统服务是默认启动的。
- 使用者的设定
  - `crontab -e`
  - `crontab -l`
  - `crontab -r` 
- 系统的配置文件：/etc/crontab，/etc/cron.d/\* 
  - crond 服务读取配置文件的位置
    - /etc/crontab 
    - /etc/cron.d/\* 
    - /var/spool/cron/\* 
- 一些注意事项
  - 资源分配不均的问题
  - 取消不要的输出项目
  - 安全的检验
  - 周与日月不可同时并存



15.4 可唤醒停机期间的工作任务

- anacron 可以主动帮你进行时间到了但却没有执行的排程喔！
- 什么是 anacron
  - anacron 并不是用来取代 crontab 的，anacron 存在的目的就在处理非 24 小时一直启动的 Linux 系统的 crontab 的执行！以及因为某些原因导致的超过时间而没有被执行的排程工作。其实 anacron 也是每个小时被 crond 执行一次，然后 anacron 再去检测相关的排程任务有没有被执行，如果有超过期限的工作在，就执行该排程任务，执行完毕或无须执行任何排程时，anacron 就停止了。
- anacron 与 /etc/anacrontab 
  - anacron 其实是一支程序并非一个服务。这支程序在 CentOS 当中已经进入 crontab 的排程喔！同时 anacron 会每个小时被主动执行一次。
  - 如果每个周日需要执行的动作是放置在 /etc/crontab 的话，那么该动作只要过期了就过期了，并不会被抓回来重新执行。但如果是放置在 /etc/cron.weekly/ 目录下，那么该工作就会定期，几乎一定会在一周内执行一次。如果你关机超过一周，那么开机后的数小时内，该工作就会主动的被执行喔！因为 /etc/anacrontab 的定义。
  - 基本上 crontab 与 at 都是定时去执行，过了时间就过了，不会重新来一遍。anacron 则是定期去执行，某一段周期地执行。因此两者可以并行，不会互相冲突啦！



15.5 重点回顾



 &nbsp;

### 第十六章 进程管理与 SELinux 初探



16.1 什么是进程（process）

- 在 Linux 系统当中，触发任何一个事件时，系统都会将它定义成为一个进程，并且给予这个进程一个 ID ，称为 PID ，同时依据启发这个进程的用户与相关属性关系，给予这个 PID 一组有效的权限设定。从此之后，这个 PID 能够在系统上面进行的动作，就与这个 PID 的权限有关了！
- 进程与程序（process & program）
  - 子进程与父进程
    - Parent PID (PPID) 
    - `ps -l` 
  - fork and exec：进程呼叫的流程
    - 在 Linux 的进程呼叫通常称为 fork-and-exec 的流程！进程都会借由父进程以复制（fork）的方式产生一个一模一样的子进程，然后被复制出来的子进程再以 exec 的方式来执行实际要进行的程序，最终就成为一个子进程的存在。
  - 系统或网络服务：常驻在内存的进程
    - 常驻在内存当中的进程通常都是负责一些系统所提供的功能，以服务用户各项任务，因此这些常驻程序就会被我们称为：服务（daemon）。
- Linux 的多人多任务环境
  - 多人环境
  - 多任务行为
  - 多重登录环境的七个基本终端窗口
  - 特殊的进程管理行为
  - bash 环境下的工作管理（job control）
    - `cp file1 file2 &` ，将 file1 这个文件复制为 file2 ，且放置于背景中执行，也就是说执行这一个命令之后，在这一个终端接口仍然可以做其它的工作，而当放入背景的这一个指令执行完毕之后，系统将会在你的终端接口显示完成的消息！
  - 多人多任务的系统资源分配问题考虑



16.2 工作管理（job control）

- 这个工作管理（job control）是用在 bash 环境下的，也就是说：当我们登陆系统取得 bash shell 之后，在单一终端机接口下同时进行多个工作的行为管理。
- 什么是工作管理？
  - 要进行 bash 的 job control 必须要注意到的限制是：
    - 这些工作所触发的进程必须来自于你 shell 的子进程（只能管理自己的 bash）；
    - 前景：你可以控制与下达指令的这个环境称为前景的工作（foreground）；
    - 背景：可以自行运行的工作，你无法使用 [ctrl]+c 终止它，可使用 bg/fg 呼叫该工作；
    - 背景中执行的进程不能等待来自 terminal/shell 的输入（input）。
- job control 的管理
  - 直接将指令丢到背景中执行的 &
    - 工作号码（job number）只与你这个 bash 环境有关，但是他既然是个指令触发的咚咚，所以当然一定是一个进程，因此你会观察到 job number 也搭配一个 PID 。
  - 将目前的工作丢到背景中暂停：[ctrl]+z
  - 观察目前的背景工作状态：jobs
    - `jobs -l` 
  - 将背景工作拿到前景来处理：fg
  - 让工作在背景下的状态变成运行中：bg
  - 管理背景当中的工作：kill
    - `kill -signal %jobnumber` 
    - `kill -l` ，列出目前 kill 能够使用的讯号 signal 有哪些，常用的有：
      - -1：SIGHUP，重新读取一次参数的配置文件，类似 reload ；
      - -9：SIGKILL，立刻强制删除一个工作；
      - -15：SIGTERM，以正常的进程终止方式终止一项工作；
      - 除了上面 3 个常用的 signal，另外 2 个较常用的：
        - -2：SIGINT，代表由键盘输入 [ctrl] + c 时同样的动作；
        - -19：SIGSTOP，相当于键盘输入 [ctrl] + z 来暂停一个进程的执行；
    - kill 后面接的数字默认会是 PID ，如果想要管理 bash 的工作控制，就得要加上 %数字 了。
- 脱机管理问题
  - 这个脱机对应大陆简体中文应该是离线的意思，比如远程连接 Linux 主机，然后再脱机（离线）。
  - nohup ：这个 nohup 可以让你在脱机或注销登录后，还能够让先前下达的指令继续执行。
    - `nohup [指令与参数]` 
    - `nohup [指令与参数] &` 
    - nohup 并不支持 bash 内建的指令，因此你的指令必须要是外部指令才行。
    - 如果你想让在背景的工作在你注销后还能够继续地执行，那么使用 nohup 搭配 & 是不错的方式。



16.3 进程管理

- 进程的观察
  - 如何查阅系统上面正在运行当中的进程呢？很简单啊！利用静态的 ps 或者是动态的 top，此外，还能以 pstree 来查阅进程树之间的关系喔！
  - ps ：将某个时间点的进程运行情况撷取下来
    - 鸟哥个人认为 ps 这个指令的 man page 不是很好查阅，建议你直接背两个比较不同的选项：一个是只能查阅自己 bash 进程的 `ps -l` ，一个则是可以查阅所有系统运行的进程 `ps aux` ，注意，你没看错，没有那个减号「-」。
    - 仅观察自己的 bash 相关进程：`ps -l` 
      - `ps -l` 仅列出与你操作环境（bash）有关的进程，亦即最上层的父进程会是你自己的 bash 而没有延伸到 systemd（后续会介绍）这支进程。
    - 观察系统所有进程：`ps aux` 
    - `ps -lA` ，显示出所有的进程。`ps axjf` ，列出类似进程树的进程显示，还可以使用 `pstree` 来列出这个进程树。
    - 除此之外，我们还必须要知道的是僵尸（zombie）进程是什么？通常，造成僵尸进程的原因是因为该进程应该已经执行完毕，或者是因故应该要终止了，但是该进程的父进程却无法完整地将该进程结束掉，而造成那个进程一直存在内存当中。如果你发现在某个进程的 CMD 后面还接上 \<defunct\> 时，就代表该进程是僵尸进程啦！
    - 事实上，通常僵尸进程都已经无法管控，而直接交给 systemd 这支进程来负责，偏偏 systemd 是系统第一支执行的进程，它是所有进程的父进程！我们无法杀掉该进程的（杀掉它，系统就死掉了！）所以啰，如果产生僵尸进程，而系统过一阵子还没有办法通过核心非经常性的特殊处理来将该进程删除时，那你只好通过 reboot 的方式来将该进程抹去了！
  - top ：动态观察进程的变化
    - 相对于 ps 是撷取一个时间点的进程状态，top 则可以持续侦测进程运行的状态！
    - 在 top 执行的过程中可以使用一些按键指令。
    - `echo $$` ，输出当前 bash 的 PID 。
    - `top -d 2 -p $(echo $$)` 
  - pstree
    - `pstree -A` 
    - `pstree -Aup` 
- 进程的管理
  - 那么进程之间是如何互相管理的呢？其实是通过给予该进程一个讯号（signal），去告知该进程你想要让它做什么，因此这个讯号就很重要啦！
  - 那么到底有多少 signal 呢？可以使用 `kill -l` 或者是 `man 7 signal` 来查询。
  - 那么我们如何传送一个讯号给某个进程呢？就通过 kill 或 killall 吧！
  - `kill -signal [PID|%jobnumber]` 
  - `killall -signal 指令名称` 
  - 要删除某个进程，我们可以使用 PID 或者是启动该进程的指令名称。而如果要删除某个服务呢？最简单的方法就是利用 killall，因为它可以将系统当中所有以某个指令名称启动的进程全部删除。
- 关于进程的执行顺序
  - Priority 与 Nice 值
    - Linux 给予进程一个 PRI (priority) ，这个 PRI 值越低代表越优先的意思。不过这个 PRI 值是由核心动态调整的，用户无法直接调整 PRI 值的。如果你想要调整进程的 PRI 时，就得要通过 Nice 值了，即 NI 。一般来说，PRI 与 NI 的相关性为：PRI(new) = PRI(old) + Nice 。
    - 关于 Nice 值，要注意到：
      - Nice 值可调整的范围为 -20~19；
      - root 可随意调整自己或他人进程的 Nice 值，且范围为 -20~19；
      - 一般使用者仅可调整自己进程的 Nice 值，且范围仅为 0~19（避免一般用户抢占系统资源）；
      - 一般使用者仅可将 Nice 值越调越高，例如本来 Nice 为 5，则未来仅能调整到大于 5。
    - 有两种方式可以给予某个进程 nice 值，分别是：
      - 一开始执行程序时就立即给予一个特定的 nice 值：用 nice 指令；
      - 调整某个已经存在的 PID 的 nice 值：用 renice 指令。
  - nice，新执行的指令给予新的 nice 值
    - `nice -n -5 vim &` 
  - renice，已存在进程的 nice 重新调整
    - `renice -5 PID` 
    - 整个 nice 值是可以在父进程 → 子进程之间传递的，另外，除了 renice 之外，其实按个 top 同样的也是可以调整 nice 值的。
- 系统资源的观察
  - free，观察内存使用情况。
    - `free -m` 
  - uname，查阅系统与核心相关信息
    - `uname -a` 
  - uptime，观察系统启动时间与工作负载
  - netstat，追踪网络或插槽文件（socket file）
    - 除了网络上的联机之外，其实 Linux 系统上面的进程是可以接收不同进程所发送来的信息，那就是 Linux 上的插槽文件（socket file）。socket file 可以沟通两个进程之间的信息，因此进程可以取得对方传送过来的资料。
    - `netstat -tulnp` ，找出目前系统上已在监听的网络联机及其 PID 。
  - dmesg，分析核心产生的讯息
  - vmstat，侦测系统资源变化



16.4 特殊文件与进程

- 具有 SUID/SGUID 权限的指令执行状态
- /proc/\* 代表的意义
- 查询已开启文件或已执行进程开启的文件
  - fuser：借由文件（或文件系统）找出正在使用该文件的进程
  - lsof：列出被进程所开启的文件文件名
    - 相对于 fuser 是由文件或装置去找出使用该文件或装置的进程，反过来说，如何查出某个进程开启或者使用的文件与装置呢？那就是 lsof 啰~
  - pidof：找出某支正在执行的程序的 PID 



16.5 SELinux 初探

- 发现这章中「程序」对应的应该是「进程」的意思，在一些句子的语境中注意下。在 PDF 的 16.6 重点回顾中发现鸟哥把 process 称为「程序」。

- 什么是 SELinux

  - SELinux，Security Enhanced Linux，字面上的意思就是安全强化的 Linux。
  - 当初设计的目标：避免资源的误用
  - 传统的文件权限与账号关系：自主式访问控制，DAC (Discretionary Access Control) 
  - 以政策规则订定特定进程读取特定文件：委任式访问控制，MAC (Mandatory Access Control) 

- SELinux 的运行模式

  - 主体（Subject）

  - 目标（Object）

  - 政策（Policy）

    - targeted：针对网络服务限制较多，针对本机限制较少，是预设的政策；

    - minimum：由 target 修订而来，仅针对选择的进程来保护；

    - mls：完整的 SELinux 限制，限制方面较为严格；

      &nbsp;

  - 安全性本文（Security context）：主体能不能存取目标，除了政策指定之外，主体与目标的安全性本文必须一致才能够顺利存取。

  - 主体如何取得目标的资源访问权限：

    1. 主体进程必须要通过 SELinux 政策内的规则放行后，就可以与目标资源进行安全性本文的比对。
    2. 若比对失败，则无法存取目标，若比对成功，则可以开始存取目标。但最终能否存取目标，还是与文件系统的 rwx 权限设定有关。如此一来，加入 SELinux 之后，出现权限不符的情况时，你就得一步一步地分析可能的问题了。

  - 安全性本文（Security context）

    - 观察安全性本文可使用  `ls -Z` 。安全性本文主要用冒号分为三个字段：

      identify(身份):role(角色):type(类型)

      在预设的 targeted 政策中，Identify 与 Role 字段基本上是不重要的，重要的在于这个类型（type）字段。基本上，一个主体进程能不能读取到这个文件资源，与类型字段有关。

  - 进程与文件 SELinux type 字段的相关性

- SELinux 三种模式的启动、关闭与观察

  - 并非所有的 Linux distributions 都支持 SELinux ，所以你必须要先观察一下你的系统版本为何。鸟哥这里介绍的 CentOS 7.x 本身就有支持 SELinux ，所以你不需要自行编译 SELinux 到你的 Linux 核心中。目前 SELinux 依据启动与否，共有三种模式，分别如下：
    - enforcing    ：强制模式，代表 SELinux 运行中，且已经正确地开始限制 domain/type 了；
    - permissive ：宽容模式，代表 SELinux 运行中，不过仅会有警告讯息，并不会实际限制 domain/type 的存取；
    - disabled     ：关闭，SELinux 并没有实际运行；
  - 并不是所有的进程都会被 SELinux 所管制，只有受限制的进程才会被 SELinux 管制。那如何观察进程有没有受限（confined）呢？很简单啊，就通过 `ps -eZ` 去撷取。
  - `getenforce` ，显示目前 SELinux 的模式。
  - `sestatus` ，观察 SELinux 的政策（Policy）为何。
  - SELinux 的配置文件，/etc/selinux/config 。`vim /etc/selinux/config` ，若有需要修改预设政策的话，就直接修改 SELINUX=enforcing 那一行即可喔！
  - SELinux 的启动与关闭
    - 如果你已经在 Enforcing 的模式，但是可能由于一些设定的问题导致 SELinux 让某些服务无法正常的运行，此时你可以将 Enforcing 的模式改为宽容（permissive）的模式，让 SELinux 只会警告无法顺利联机的讯息，而不是直接抵挡主体进程的读取权限。
    - `setenforce [0|1]` ，0（转成 permissvie，宽容模式），1（转成 Enforcing，强制模式）。

- SELinux 政策内的规则管理

  - SELinux 各个规则的布尔值查询， getsebool 
    - 如果想要查询系统上面全部规则的启动与否（on/off，亦即布尔值），很简单，通过 `setstatus -b` 或 `getsebool -a` 均可。
  - SELinux 各个规则规范的主体进程能够读取的文件 SELinux type 查询，seinfo , sesearch 
  - 修改 SELinux 规则的布尔值，setsebool 

- SELinux 安全本文的修改
  - 使用 chcon 手动修改文件的 SELinux type
  - 使用 restorecon 让文件恢复正确的 SELinux type 
  - semanage 默认目录的安全性本文查询与修改
  
- 一个网络服务案例及登录文件协助

  - curl ：简单的终端机浏览器



16.6 重点回顾



鸟哥的 Changelog: Chapter 16

- 2016-07-08：重点回顾第三点，PID 1 应该是 systemd，之前写错成 init 了
- 2016-10-24：感谢网友在讨论区的回应，SELinux 的 seinfo 选项没有 -A 了，使用 -\-all 来取代啰！
- 2018-01-29：根据网友回报，nice 值的 -n N ，那个 N 指的是再加上的数值，之前鸟哥的说法不好，要更新喔！



&nbsp;

## 第五部分 Linux 系统管理员



### 第十七章 认识系统服务（daemons）



17.1 什么是 daemon 与服务（service）

- 早期 System V 的 init 管理行为中 daemon 的主要分类（Optional）
- systemd 使用的 unit 分类
  - systemd 的配置文件放置目录
  - systemd 的 unit 类型分类说明



17.2 通过 systemctl 管理服务

- 通过 systemctl 管理单一服务（service unit）的启动/开启启动与观察状态

  - `systemctl status atd.service`

  - `systemctl stop atd.service`

  - 服务启动/关闭与观察的练习

    - ```
      systemctl status chronyd.service
      systemctl stop chronyd.service
      systemctl disable chronyd.service
      systemctl status chronyd.service
      ```

  - 强迫服务注销（mask）的练习

    - `systemctl mask cups.service`
    - `systemctl unmask cups.service`

- 通过 systemctl 观察系统上所有的服务

  - `systemctl` 
  - `systemctl list-unit-files` 
  - `systemctl list-units --type=service --all` 

- 通过 systemctl 管理不同的操作环境（target unit）

  - `systemctl list-units --type=target --all` 
  - `systemctl get-default` 
  - `systemctl set-default multi-user.target` 
  - `systemctl isolate multi-user.target` 
  - `systemctl isolate graphical.target` 
  - `systemctl poweroff` 
  - `systemctl reboot` 
  - `systemctl suspend` 
  - `systemctl hibernate` 
  - `systemctl rescue` 
  - `systemctl emergency` 

- 通过 systemctl 分析各服务之间的相依性

  - `systemctl list-dependencies` 
  - `systemctl list-dependencies --reverse` 
  - `systemctl list-dependencies graphical.target` 

- 与 systemd 的 daemon 运行过程相关的目录简介

- 关闭网络服务



17.3  systemctl 针对 service 类型的配置文件

- systemctl 配置文件相关目录简介
- systemctl  配置文件的设定项目简介
- 两个 vsftpd 运行的实例
- 多重的重复设定方式：以 getty 为例
- 自己的服务自己作



17.4 systemctl 针对 timer 的配置文件



17.5 CentOS 7.x 预设启动的服务简易说明



17.6 重点回顾



&nbsp;

### 第十八章 认识与分析登录文件



18.1 什么是登录文件

- 详细而确实地分析以及备份系统的登录文件，是一个系统管理员应该要进行的任务之一。什么是登录文件呢？简单地说就是记录系统活动信息的几个文件，例如何时、何地（来源 IP）、何人（什么服务名称）、做了什么动作（讯息登录啰）。换句话说就是，记录系统在什么时候由哪个程序做了什么样的行为时，发生了何种的事件等等。
- CentOS 7 登录文件简易说明
  - 登录文件的重要性
  - Linux 常见的登录文件文件名
  - 登录文件所需相关服务（daemon）与程序
  - CentOS 7.x 使用 systemd 提供的 journalctl 日志管理
- 登录文件内容的一般格式



18.2 rsyslog.service ：记录登录文件的服务

- rsyslog.service 的配置文件：/etc/rsyslog.conf
  - 基本上，rsyslogd 针对各种服务与讯息记录在某些文件的配置文件就是 /etc/rsyslog.conf，这个文件规定了：什么服务（1）的什么等级讯息（2）需要被记录在哪里（装置或文件）（3），这三个咚咚。
  - 服务名称
  - 讯息等级
  - 讯息记录的文件名或装置或主机
  - 服务、daemon 与函数名称
  - rsyslog.conf 语法练习
  - CentOS 7.x 预设的 rsyslog.conf 内容
  - 自行增加登录文件文件功能
- 登录文件的安全性设置
- 登录文件服务器的设置



18.3 登录文件的轮替（logrotate）

- logrotate 的配置文件
- 实际测试 logrotate 的动作
- 自定义登录文件的轮替功能



18.4 systemd-journald.service 简介

- 使用 journalctl 观察登录信息
- logger 指令的应用
- 保存 journal 的方式



18.5 分析登录文件

- CenOS 预设提供的 logwatch 
- 鸟哥自己写的登录文件分析工具



18.6 重点回顾



鸟哥的 Changelog: Chapter 18

- 2016-11-23：依据讨论区 eZioPan 网友提供的建议，原本 .! 以及相关说明有点错误，已经订正！感谢 eZioPan 兄！
  - .! ：有点反向选择的感觉，代表忽略大于等于这个等级的讯息！亦即是低于这个等级的才会被记录的意思



&nbsp;

### 第十九章 开机流程、模块管理与 Loader



19.1Linux 的开机流程分析

- 开机流程一览

- BIOS，boot loader 与 kernel 载入
  - BIOS ，开机自我测试与 MBR/GPT
  - Boot Loader 的功能
  - 加载核心侦测硬件与 initramfs 的功能
    - 虚拟文件系统（Initial RAM Disk 或 Initial RAM Filesystem）一般使用的文件名为 /boot/initrd 或 /boot/initramfs ，这个文件的特色是它也能够通过 boot loader 来加载到内存中，然后这个文件会被解压缩并且在内存当中仿真成一个根目录，且此仿真在内存当中的文件系统能够提供一支可执行的程序，通过该程序来加载开机过程中所最需要的核心模块，通常这些模块就是 USB，RAID，LVM，SCSI 等文件系统与磁盘接口的驱动程序啦！等载入完成后，会帮助核心重新呼叫 systemd 来开始后续的正常开机流程。
  
- 第一支程序 systemd 及使用 default.target 进入开机程序分析
  - 常见的操作环境 target 与兼容于 runlevel 的等级：
  
    |  SystemV  |  systemd  |
    |  :----  |  :----  |
    | init 0 | systemctl poweroff |
    | init 1 | systemctl rescue |
    | init [234] | systemctl isolate multi-user.target |
    | init 5 | systemctl isolate graphical.target |
    | init 6 | systemctl reboot |
    
  - systemd 的处理流程
  
- systemd 执行 sysinit.target 初始化系统、basic.target 准备系统

- systemd 启动 multi-user.target 下的服务

  - 相容 systemV 的 rc-local.service
  - 提供 tty 界面与登入的服务

- systemd 启动 graphical.target 底下的服务

- 开机过程会用到的主要配置文件



19.2 核心与核心模块

- 核心模块与相依性
- 核心模块的观察
  - `lsmod` 
  - `modinfo` 
- 核心模块的加载与移除
  - `insmod` 
  - `rmmod` 
  - `modprobe` 
- 核心模块的额外参数设定：/etc/modprove.d/\*conf



19.3 Boot Loader：Grub2

- boot loader 的两个 stage
- grub2 的配置文件 /boot/grub2/grub.cfg 初探
- grub2 配置文件维护 /etc/default/grub 与 /etc/grub.d
- initramfs 的重要性与建立新 initramfs 文件
- 测试与安装 grub2
- 开机前的额外功能修改
- 关于开机画面与终端机画面的图形显示方式
- 为个别选单加上密码



19.4 开机过程的问题解决

- 忘记 root 密码的解决之道
- 直接开机就以 root 执行 bash 的方法
- 因文件系统错误而无法开机



19.5 重点回顾



鸟哥的 Changelog: Chapter 19

- 2016-12-28：网友 eZioPan 在讨论区讨论了一篇 initramfs 的解法，请大家参考，鸟哥觉得很棒！所以旧版文章移动到这里啰！
- 2017-12-19：原先 insmod … vfat.ko 的指令是错误的！因为 vfat.ko.xz 这样的文件名才是对的！哇，又压缩了！感谢网友的说明！



&nbsp;

### 第二十章 基础系统设置与备份策略



20.1 系统基本设置

- 网络设定（手动设定与 DHCP 自动获得）

  - `ifconfig -a` ，列出系统上所有的网卡。

  - 手动设定 IP 网络参数

    - ```
      nmcli connection show
      nmcli connection show eth0
      nmcli connection modify eth0
      nmcli connection up eth0
      nmcli connection show eth0
      ```

    - `nmcli connection down eth0` ，停用 eth0 。

  - 自动取得 IP 参数

  - 修改主机名

    - `hostnamectl` 

- 日期与时间设定

  - 时区的显示与设定
    - `timedatectl` 
  - 时间的调整
  - 用 ntpdate 手动网络校时

- 语系设定

  - `localectl` 
  - `locale` 

- 防火墙简易设定



20.2 服务器硬件数据的收集

- 以系统内建 dmidecode 解析硬件配备
  - `dmidecode -t 1` 
  - `dmidecode -t 17` 
- 硬件资源的收集与分析
  - `gdisk`
  - `dmesg`
  - `vmstat`
  - `lspci`
  - `lsusb`
  - `iostat` 
- 了解磁盘的健康状态
  - SMART，Self-Monitoring, Analysis and Reporting Technology System，主要用来监测目前常见的 ATA 与 SCSI 界面的磁盘。只是，要被监测的磁盘也必须要支持 SMART 的协议才行。
  - `smartctl -a /dev/sda` 



20.3 备份要点

- 备份资料的考虑
  - 备份因素考虑
- 哪些 Linux 数据具备有备份的意义
  - 操作系统本身需要备份的文件
  - 网络服务的数据库方面
  - 推荐需要备份的目录
  - 不需要备份的目录
- 备份用储存媒体的选择



20.4 备份的种类、频率与工具的选择

- 完整备份之累积备份（Incremental backup）
  - 还原的考虑
  - 累积备份的原则
  - 累积备份使用的备份软件
    - 完整备份常用的工具有 dd，cpio，xfsdump/xfsrestore，tar 等。
- 完整备份之差异备份（Differential backup）
  - 使用 tar 的 -N 选项来备份
    - `tar -N '2015-09-01' -jpcv -f /backupdata/home.tar.bz2 /home` 
  - 通过 rsync 来进行镜像备份
    - `rsync -av /home /backupdata/` 
- 关键数据备份



20.5 鸟哥的备份策略

- 每周系统备份的 script
- 每日备份数据的 script
- 远程备援的 script
  - 使用 rsync 上传备份数据



20.6 灾难复原的考虑

- 硬件损毁，且具有完整备份的数据时
- 由于软件的问题产生的被攻破资安事件



20.7 重点回顾



&nbsp;

### 第二十一章 软件安装：原始码与 Tarball



21.1 开放源码的软件安装与升级简介

- 什么是开放源码、编译程序与可执行文件
  - 用 file 指令来查看文件属性
- 什么是函数库
- 什么是 make 与 configure
- 什么是 Tarball 的软件
- 如何安装与升级软件



21.2 使用传统程序语言进行编译的简单范例

- 单一程序：打印出 Hello World

  - 编辑程序代码，亦即原始码

  - 开始编译与测试执行

    - ```
      gcc hello.c
      ll hello.c a.out
      ./a.out
      ```

    - ```
      gcc -c hello.c
      ll hello*
      gcc -o hello hello.o
      ll hello*
      ./hello
      ```

- 主、子程序链接：子程序的编译

  - 撰写所需要的主、子程序

  - 进行程序的编译与链接（Link）

    - ```
      gcc -c thanks.c thanks_2.c
      ll thanks*
      gcc -o thanks thanks.o thanks_2.o
      ll thanks*
      ./thanks
      ```

    - 此外，如果你想要让程序在执行的时候具有比较好的效能，或者是其它的除错功能时，可以在编译的过程里面加入适当的参数，例如：

      ```
      gcc -O -c thanks.c thanks_2.c
      gcc -Wall -c thanks.c thanks_2.c
      ```

      `-O` 为产生优化的参数。`-Wall` 为产生更详细的编译过程信息。

- 呼叫外部函数库：加入连结的函数库

  - 编译时加入额外函数库连结的方式

    - ```
      gcc sin.c -lm -L/lib -L/lib64
      ./a.out
      ```

    - `gcc sin.c -lm -I/usr/include` ，`-I/path` 后面接的路径（Path）就是设定要去搜寻 C 源程序中相关的 include 文件的目录啦！不过，默认值是放置在 /usr/include 底下，除非你的 include 文件放置在其它路径，否则也可略过这个选项。

- gcc 的简易用法（编译、参数与链接）

  - 我们通常称 `-Wall` 或者 `-O` 这些非必要的参数为旗标（FLAGS），因为我们使用的是 C 程序语言，所以有时候也会简称这些旗标为 CFLAGS ，这些变量偶尔会被使用的喔！尤其是在后面会介绍的 make 相关的用法时，更是重要得很呐！^_^



21.3 用 make 进行宏编译

- 为什么要用 make

  - makefile

    ```
    vim makefile
    main: main.o haha.o sin_value.o cos_value.o
    	gcc -o main main.o haha.o sin_value.o cos_value.o -lm
    ```

    在 makefile 中我们仅写出 main 需要的目标文件，结果 make 会主动地去判断每个目标文件相关的原始码文件，并直接予以编译，最后再直接进行链接的动作！此外，如果我们更动过某些原始码文件，则 make 也可以主动地判断哪一个原始码与相关的目标文件有更新过，并仅更新该文件，如此一来，将可大大地节省很多编译的时间呢！

  - 使用 make 的好处：

    - 简化编译时所需要下达的指令；
    - 若在编译完成之后，修改了某个原始码文件，则 make 仅会针对被修改了的文件进行编译，其它的 object file 不会被更动；
    - 最后可以依照相依性来更新（update）可执行文件。

- makefile 的基本语法与变量

  - 鸟哥在这里仅列出一些基本的规则，重点在于让读者们未来在接触原始码时，不会太紧张啊！基本的 makefile 规则是这样的：

    ```
    目标（target）: 目标文件1 目标文件2
    <tab> gcc -o 欲建立的执行文件 目标文件1 目标文件2
    ```

    - 在 makefile 当中的 # 代表批注；
    - \<tab\> （\<tab\> 按键）需要在命令行（例如 gcc 这个编译程序指令）的第一个字符；
    - 目标（target）与相依文件（就是目标文件）之间需要以「:」隔开。

  - makefile 中的变量与 bash shell script 中的变量语法有点不太相同，它的变量基本语法为：

    - 变量与变量内容以「=」隔开，同时两边可以有空格；
    - 变量左边不可以有 \<tab\> ；
    - 变量与变量内容在「=」两边不能具有「:」；
    - 在习惯上，变量最好是以「大写字母」为主；
    - 运用变量时，以 \${变量} 或 \$(变量) 使用；
    - 在该 shell 的环境变量是可以被套用的，例如提到的 CFLAGS 这个变量；
    - 在指令行模式也可以给予变量；

  - 由于 gcc 在进行编译的行为时，会主动地去读取 CFLAGS 这个环境变量，所以，你可以直接在 shell 定义出这个环境变量，也可以在 makefile 文件里去定义，更可以在指令行当中给予这个咚咚呢！

  - 此外，还有一个特殊的变量需要了解的喔：

    - \$@ ：代表 makefile 中目前的目标（target）



21.4 Tarball 的管理与建议

- 使用原始码管理软件所需要的基础软件
  - gcc 或 cc 等 C 语言编译程序（compiler）
  - make 及 autoconfig 等软件
  - 需要 Kernel 提供的 Library 以及相关的 Include 文件
  - 目前的 Linux distribution 大多已经偏向于桌面计算机的使用（非服务端），他们希望使用者能够按照厂商自己的希望来安装相关的软件即可，所以通常默认是没有安装 gcc 或者是 make 等软件的。所以，如果你希望未来可以自行安装一些以 Tarball 方式释出的软件时，记得请自行挑选想要安装的软件名称喔！例如在 CentOS 或者是 Red Hat 当中，记得选择 Development Tools 以及 Kernel Source Development 等相关字眼的软件集群呢。
- Tarball 安装的基本步骤
  - 大部分的 tarball 软件安装的指令下达方式：
    - ./configure
    - make clean
    - make
    - make install
- 一般 Tarball 软件安装的建议事项（如何移除？升级？）
  - 时至今日，老实说，真的不太需要有 tarball 安装了！CentOS/Fedora 有个 RPM 补遗计划，就是俗称的 EPEL 计划，相关网址说明如下：https://fedoraproject.org/wiki/EPEL 。一般学界会用到的软件都在里头~除非你要用的软件是专属软件（要钱的）或者是比较冷门的软件，否则都有好心的网友帮我们打包好啦！
- 一个简单的范例，利用 ntp 来示范
  - 解压缩下载的 tarball ，并参阅 README/INSTALL 文件
  - 检查 configure 支持参数，并实际创建 makefile  规则文件
  - 最后开始编译与安装
- 利用 patch 更新原始码
  - 测试旧版程序的功能
  - 查阅 patch file 内容
  - 更新原始码，并且重新编译程序



21.5 函数库管理

- 函数库按照是否被编译到程序内部而分为动态与静态函数库。
- 动态与静态函数库
  - 静态函数库的特色
  - 动态函数库的特色
- ldconfig 与 /etc/ld.so.conf
  - 如果我们将用到的动态函数库先加载到内存中（快取，cache），如此一来，当软件要取用动态函数库时，就不需要从硬盘里读出啰！这样就可以增进动态函数库的读取速度！这个时候就需要 ldconfig 与 /etc/ld.so.conf 的协助了。
- 程序的动态函数库解析：ldd
  - 如何判断某个可执行的 binary 文件含有什么动态函数库呢？很简单，利用 ldd 就可以晓得了！



21.6 检验软件正确性

- md5sum / sha1sum / sha256sum



21.7 重点回顾



&nbsp;

### 第二十二章 软件安装 RPM，SRPM 与 YUM



22.1 软件管理员简介

- 厂商先在他们的系统上面编译好了我们用户所需要的软件，然后将这个编译好是可执行软件直接释出给用户来安装，如此一来，由于我们本来就使用产商的 Linux distribution，那么使用厂商提供的编译过的可执行文件就没有问题啦！

  如果在安装的时候还可以加上一些与这些程序相关的信息，将他建立成为数据库，那不就可以进行安装、反安装、升级与验证等等的相关功能啰？确实如此，在 Linux 上面至少就有两种常见的这方面的软件管理员，分别是 RPM 与 Debian 的 dpkg 。CentOS 主要是以 RPM 为主。

- Linux 界 的两大主流：RPM 与 DPKG 

- 什么是 RPM 与 SRPM

  - RPM，RedHat Package Manager 。当初这个软件管理的机制是由 Red Hat 这家公司发展出来的，RPM 是以一种数据库记录的方式将你所需要的软件安装到你的 Linux 系统的一套管理机制。
  - SRPM，Source RPM 。也就是这个 RPM 文件里面含有原始码，特别要注意的是，这个 SRPM 所提供的软件内容并没有经过编译，它提供的是原始码喔！SRPM 的扩展名是以 ***.src.rpm 这种格式来命名的。
  - 通常一个软件在释出的时候，都会同时释出该软件的 RPM 与 SRPM。RPM 文件必须要在相同的 Linux 环境下才能够安装，而 SRPM 既然是原始码的格式，自然我们就可以透过修改 SRPM 内的参数配置文件，然后重新编译产生能适合我们 Linux 环境的 RPM 文件。如此一来，就可以将该软件安装到我们的系统当中，而不必与原作者打包的 Linux 环境相同了，这就是 SRPM 的用处了。

- 什么是 i386，i586，i686，noarch，x86_64

- RPM 的优点

- RPM 属性相依的克服方式：YUM 在线升级

  - CentOS 先将释出的软件放置到 YUM 服务器内，然后分析这些软件的相依属性问题，将软件内的记录信息写下来（header）。然后再将这些信息分析后记录成软件相关性的清单列表。这些列表数据与软件所在的本机或网络位置可以称呼为容器或软件仓库或软件库（repository）。当客户端有软件安装的需求时，客户端主机会主动地向网络上面的 yum 服务器的软件库网址下载清单列表，然后通过清单列表的数据与本机 RPM 数据库已存在的软件数据相比较，就能够一口气安装所有需要的具有相依属性的软件了。



22.2 RPM 软件管理程序：rpm

- RPM 的使用其实不难，只要使用 rpm 这个指令即可，鸟哥最喜欢的就是 rpm 指令的查询功能了，可以让我很轻易地就知道某个系统有没有安装鸟哥要的软件呢！
- 事实上，下一小节要讲的 yum 就可以直接用来进行安装的动作，基本上 rpm 这个指令真的就只剩下查询与检验的功能啰！
- RPM 默认安装的路径
- RPM 安装（install）
  - 因为安装软件是 root 的工作，因此你得要是 root 身份才能够操作 rpm 指令。
  - `rpm -ivh package_name` 
  - 对于 rpm 的安装选项与参数，通常鸟哥建议直接使用 -ivh 就好了，如果安装的过程中发现问题，一个一个去将问题找出来，尽量不要使用暴力安装法，也就是通过 -\-force 去强制安装，因为可能会发生很多不可预期的问题呢！除非你很清楚地知道使用上面的参数后，安装的结果是你预期的！
- RPM 升级与更新（upgrade/freshen）
  - `rpm -Uvh` 
  - `rpm -Fvh` 
- RPM 查询（query）
  - RPM 在查询的时候，其实查询的地方是在 /var/lib/rpm/ 这个目录下的数据库文件啦！另外 RPM 也可以查询未安装的 RPM 文件内的信息喔！
- RPM 验证与数字签名（Verify/signature）
  - 鸟哥之前的主机曾经由于安装一套软件，导致被攻击成为跳板。会发现的原因是系统中只要出现 \*.patch 的扩展名时，使用 `ls -l` 就是显示不出来该文件名（该文件名确实存在）。找了好久，用了好多工具都找不出问题，最终利用 `rpm -Va` 找出来，原来好多 binary program 被更动过，连 init 都被恶搞！此时，赶紧重新安装 Linux 并移除那套软件，之后就比较正常了。所以说，这个 `rpm -Va` 是个好功能喔！
  - 数字签名（digital signature）
- RPM 的反安装与重建数据库（erase/rebuilddb）
  - `rpm -e 软件名` 
  - `rpm --rebuilddb` ，重建 RPM 数据库 /var/lib/rpm/ 



22.3 YUM 在线升级机制

- 利用 yum 进行查询、安装、升级与移除功能

  - 查询功能：`yum [list|info|search|provides|whatprovides] 参数` 
  - 安装/升级功能：`yum [install|update] 软件` 
  - 移除功能：`yum [remove] 软件` 
  - yum 是架构在 rpm 上面所发展起来的，所以，鸟哥认为你还是得需要了解 rpm 才行！不要学了 yum 之后就将 rpm 的功能忘记了呢！

- yum 的配置文件

  - 修改软件库产生的问题与解决之道

- yum 的软件群组功能

  - `yum grouplist` 
  - `yum groupinfo "Scientific Support"` 
  - `yum groupinstall "Scientific Support"` 

- EPEL/ELRpo 外挂软件以及自定义配置文件

  - 在 Fedora 基金会里面发展了一个外加软件计划（Extra Packages for Enterprise Linux, EPEL），这个计划主要是针对 Red Hat Enterprise Linux 的版本来开发的，刚刚好 CentOS 也是针对 RHEL 的版本来处理的嘛！所以也就能够支持该软件库的相关软件相依环境了。
  - 使用本机的原版光盘

- 全系统自动升级

  - `yum -y update` 

- 管理的抉择：RPM 还是 Tarball

  - 优先选择原厂的 RPM 功能
  - 选择软件官网释出的 RPM 或者是提供的软件库网址
  - 利用 Tarball 安装特殊软件
  - 用 Tarball 测试新版软件
  - 所以说，如果有 RPM 的话，那么还是以 RPM 安装优先，毕竟管理上比较便利，但是如果软件的架构差异性太大，或者是无法解决相依属性的问题，那么与其花大把的时间与精力在解决属性相依的问题上，还不如直接以 tarball 来安装，轻松又惬意！ 

- 基础服务管理：以 Apache 为例

  - 在默认的情况下，你无须修改服务的配置文件，都通过系统默认值来处理你的服务即可。那么有个江湖口诀你可以将它背下来：

    1. 安装：`yum install 你的软件` 

    2. 启动：`systemctl start 你的软件` 

    3. 开机启动：`systemctl enable 你的软件` 

    4. 防火墙：

       ```
       firewall-cmd --add-service="你的服务"
       firewall-cmd --permanent --add-service="你的服务"
       ```

    5. 测试：用软件去查阅你的服务正常与否~



22.4 SRPM 的使用：rpmbuild  (Optional)

- 利用默认值安装 SRPM 文件（-\-rebuild/-\-recompile）
- SRPM 使用的路径与需要是软件
- 配置文件的主要内容（\*.spec）
- SRPM 的编译指令（-ba/-bb）
- 一个打包自己软件的范例



22.5 重点回顾



&nbsp;

### 第二十三章 X Window 设置介绍



23.1 什么是 X Window System

- X Window 的发展简史
- 主要组件：X Server/X Client/Window Manager/Display Manager
  - X Server ：硬件管理、屏幕绘制与提供字型功能
  - X Client ：负责 X Server 要求的事件之处理
  - X Window Manager ：特殊的 X Client ，负责管理所有的 X client 软件
    - GNOME (GNU Network Object Model Environment) 
    - KDE (K Desktop Environment) 
    - twm (Tab Window Manager) 
    - XFCE (XForms Common Environment) 
  - Display Manager ：提供登入需求
- X Window 的启动流程
- X 启动流程测试
- 我是否需要启动 X Window System



23.2 X Server 配置文件解析与设置

- 解析 xorg.conf 设置

- 字型管理

- 显示器参数微调

  - 重新启动 X 窗口：

    ```
    systemctl isolate multi-user.target
    systemctl isolate graphical.target
    ```



23.3 显示适配器驱动程序安装范例

- NVidia
- AMD (ATI)
- Intel



23.4 重点回顾



&nbsp;

### 第二十四章 Linux 核心编译与管理



24.1 编译前的任务：认识核心与取得核心原始码

- 什么是核心（Kernel）
  - Kernel
  - 核心模块（kernel module）的用途
  - 自制核心 - 核心编译
  - 关于驱动程序 - 是厂商的责任还是核心的责任？
- 更新核心的目的
  - Linux 核心特色，与默认核心对终端用户的角色
  - 核心编译的可能目的
    - 新功能的需求
    - 原本核心太过臃肿
    - 与硬件搭配的稳定性
    - 其它需求（如嵌入式系统）
- 核心的版本
- 核心原始码的取得方式
- 核心原始码的解压缩/安装/观察
  - 核心原始码的解压缩与放置目录
  - 核心原始码下的次目录



24.2 核心编译的前处理与核心功能选择

- 硬件环境检视与核心功能要求
- 保持干净原始码：make mrproper
- 开始挑选核心功能：make XXconfig
  - `make menuconfig` 
  - `make oldconfig`
  - `make xconfig` 
  - `make gconfig` 
  - `make config` 
  - 通过既有的设置来处理核心项目与功能的选择
- 核心功能细项选择



24.3 核心的编译与安装

- 编译核心与核心模块

  - ```
    make -j 4 clean
    make -j 4 bzImage
    make -j 4 modules
    ```

- 实际安装模块

  - `make modules_install` 

- 开始安装新核心与多重核心选单（grub）

  - 移动核心到 /boot 且保留旧核心文件
  - 建立相对应的 Initial Ram Disk (initrd) 
  - 编辑开机选单（grub）
  - 重新以新核心开机、测试、修改



22.4 额外（单一）核心模块编译

- 编译前注意事项
- 单一模块编译
  - 硬件开发商提供的额外模块
  - 利用旧有的核心原始码进行编译
- 核心模块管理



24.5 以最新核心版本编译 CentOS 7.x 的核心



24.6 重点回顾



&nbsp;

&nbsp;





## Linux 架设篇 2018年1月的更新



### 第零章 谈 Linux 应用及本书编辑与学习方式



### 第一章 小型云系统与主机安全强化流程



1.1 小型云系统的安装与基础设定



1.2 基本的安全强化动作

- 减少启动的网络服务
  - 检查你的系统上面有没有启动对外公开的网络服务，最简单的办法就是使用 netstat 这个指令即可。
  - 列出目前系统上面正在监听的网络端口，仅 TCP 与 UDP 端口：`netstat -tulnp` 
  - 减少网际网络的连线服务
- 让系统软件保持在最新的状态
  - `yum -y update`
- 用 logwatch 分析登录文件
  - `yum install logwatch` 
- 以 nmap 观察本身系统网络端口
  - 使用 netstat 可以查阅到本身服务器的网络服务，不过，如果想要知道区网内的其它主机服务，又或是想要侦测自己服务器是否有其它的端口时，可以通过 nmap 这个指令来处理喔！
  - nmap 软件说明之名称为：Network exploration tool and security / port scanner，顾名思义，这个东西是被系统管理员用来管理系统安全性核查的工具。
  - 不要侦测别人的环境



1.3 管理员的管理态度



### 这一部分内容参考资料

[鸟哥的Linux私房菜 - 服务器架设篇目录 - 2018年1月更新](http://linux.vbird.org/linux_server/) 





&nbsp;

&nbsp;

## Linux 架设篇 第三版 2011年



### 第一部分 架站前的进修专区



#### 序言

<img src="https://gitee.com/haokaimo/Picture/raw/master/Linux-VbirdTsai/VBird-LinuxServer-3rd-Preface-4Parts-TheFirst2PartsContain10Chapters-TheChapter11NeedToSpendMoreTime-EspeciallySSH.JPG" alt="VBird-LinuxServer-3rd-Preface-4Parts-TheFirst2PartsContain10Chapters-TheChapter11NeedToSpendMoreTime-EspeciallySSH" style="zoom:77%;" />



&nbsp;

#### 第一章 架设服务器之前的准备工作

&nbsp;

#### 第二章 基础网络概念



2.1 网络是个什么玩意儿

- 什么是网络
- 电脑网络组成元件
- 电脑网络区域范围
  - 区域网络（Local Area Network，LAN）
  - 广域网络（Wide Area Network，WAN）
- 电脑网络通讯协定：OSI 七层协定
- 电脑网络通讯协定：TCP/IP 
  - 四层：应用层、传送层、网络层、链接层



2.2 TCP/IP 的链接层相关协定

- 广域网络使用的设备
- 区域网络使用的设备-以太网络
- 以太网络的传输协定：CSMA/CD
- MAC 的封装格式
- MTU 最大传输单位
- 集线器、交换机与相关机制



2.3 TCP/IP 的网络层相关封包与资料

- IP 封包的封装
  - IPv4，32位地址
  - IPv6，128位地址
  - 目前主流媒体大多还是使用 IPv4，因此本文主要谈到的 IP 都是对 IPv4 而言。
  - 只要知道 IP 封包的表头中含有 TTL，Protocol，来源地址与目的地址 也就够了
- IP 地址的组成与分级
  - 同一个网域的定义是：在同一个物理网段内，主机的 IP 具有相同的 Net_ID，并且具有独特的 Host_ID。
  - 在同一网段内，Net_ID 是不变的，而 Host_ID 则是不可重复，此外，Host_ID 在二进制的表示法当中，不可同时为 0，也不可同时为 1。因为全为 0 表示整个网段的地址（Network IP），全为 1 则表示为广播的地址（Broadcast IP）。
  - Class A : 0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx    0.xx.xx.xx - 127.xx.xx.xx
  - Class B : 10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx    128.xx.xx.xx - 191.xx.xx.xx
  - Class C : 110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx    192.xx.xx.xx - 223.xx.xx.xx
  - Class D : 1110xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx    224.xx.xx.xx - 239.xx.xx.xx
  - Class E : 1111xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx    240.xx.xx.xx - 255.xx.xx.xx
  - 只需记 Class A，B，C 即可。能够用来设定在一般系统上面的，就只有 Class A，B，C 三种等级的 IP。

- IP 的种类与取得方式

  - 在 IPv4 里面就只有两种 IP 的类别，分别是：
    - Public IP ：公共 IP，经由 INTERNIC 所统一规划的 IP，有这种 IP 才可以连上 Internet ；
    - Private IP ：私有 IP 或保留 IP，不能直接连上 Internet 的 IP，主要用于区域网络内的主机连接规划。
  - 早在 IPv4 规划的时候就担心 IP 会有不足的情况，而为了应对某些企业内部的网络设定，于是就有了私有 IP (Private IP) 的产生了。私有 IP 也分别在 A，B，C 三个 Class 当中各保留一段作为私有 IP 网段：
    - Class A : 10.0.0.0 - 10.255.255.255
    - Class B : 172.16.0.0 - 172.31.255.255
    - Class C : 192.168.0.0 - 192.168.255.255
  - 特殊的 loopback IP 网段
    - 这个属于 Class A 的 lo 网域，当初被用来作为测试操作系统内部环回所用的一个网域，同时也能够提供给系统内部原本就需要使用网络介面的服务（daemon）所用。
    - 利用这个内部环回网络，可以测试下在你的机器上面设定的服务器环境到底可不可以顺利运行。这个网段在 127.0.0.0/8 的这个 Class A，而且默认的主机的 IP 是 127.0.0.1。所以当你启动了你的 WWW 服务器，然后在你的主机的 X-Window 上面执行 http://localhost 就可以直接看到你的主页啰！

- Netmask，子网络与 CIDR (Classless Interdomain Routing)

  - Netmask 是用来定义出网域的最重要的一个参数了。用来完成子网的切分。

  - A，B，C Class 的 Netmask ：

    - Class A : 11111111.00000000.00000000.00000000    (255.0.0.0)
    - Class B : 11111111.11111111.00000000.00000000    (255.255.0.0)
    - Class C : 11111111.11111111.11111111.00000000    (255.255.255.0)

  - 一般来说，如果知道了 Network 以及 Netmask 之后，就可以定义出该网域的所有 IP 了。我们常常会以 Network 以及 Netmask 来表示一个网域，例如这样的写法：

    ```
    Network/Netmask
    192.168.0.0/255.255.255.0
    192.168.0.0/24  <==因为 Net_ID 共有 24 个 bits
    ```

  - 老实说，你无需理会啥是无等级域间路由啦，只要知道，那个 Network/Netmask 的写法，通常就是 CIDR 的写法！然后你也要知道如何通过 Netmask 去计算出 Network，Broadcast 及可用的 IP 等，那你的 IP 概念就相当完整了！^_^

- 路由概念

  - 每部主机都有自己的路由表

- 观察主机路由：route

  - `route`
  - `route -n`  （将主机的名称以 IP 的方式显示）

- IP 与 MAC ：链接层的 ARP 与 RARP 协议

  - ARP (Address Resolution Protocal)，网络地址解析协议

  - RARP (Revers ARP)，反向网络地址解析协议

  - 如何取得自己本机的网卡卡号（MAC）？

    ```
    在 Linux 环境下：
    ifconfig eth0
    
    在 Windows 环境下：
    ipconfig /all
    ```

  - 如何取得本机的 ARP 表格内的 IP/MAC 对应资料呢？就通过 arp 这个指令吧！

    - `arp -n` 

  - 发送 ARP 封包取得的 IP/MAC 对应，这个记录的 ARP table 是动态的数据（一般保留 20 分钟），它会随着你的网域里面电脑的 IP 更动而变化。

- ICMP 协议

  - ICMP (Internet Control Message Protocol) 是一个错误侦测与回报的机制，最大的功能就是可以确保我们网络的连接状态与连接的正确性。
  - 那我们是如何利用 ICMP 来检验网络的状态呢？最简单的指令就是 ping 与 traceroute 了，这两个指令可以通过 ICMP 封包的辅助来确认与回报网络主机的状态。
  - 在设定防火墙的时候，我们最容易忽略的就是这个 ICMP 封包了，因为只会记住 TCP/UDP 而已~ 事实上，ICMP 封包可以帮助连线的状态回报，除了 ICMP 的类别 8（Echo Request，请求回应讯息）可以考虑关闭之外，基本上，ICMP 也不应该全部都挡掉喔！



2.4 TCP/IP 的传输层相关封包与资料

- 可靠连接的 TCP 协议

  - 在 TCP 封包的表头资料中，各个项目以 Source Port，Destination Port 及 Code 算是比较重要的内容。（应该可以再加上 Sequence Number（封包序号），Acknowledge Number（回应序号））。Code即 Control Flag，控制标志码，共 6 个 bit ，分别代表 6 个控制码，若为 1 则启动。这 6 个控制码分别为：URG (Urgent)，ACK (Acknowledge)，PSH (Push function)，RST (Reset)，SYN (Synchronous)，FIN (Finish) 。

  - 通讯端口

    - 在 TCP 表头资料中，最重要的就属那 16 位的两个咚咚，即来源端口与目标端口。由于是 16 位，因此来源端口与目标端口最大可达 65535 。

  - 特权端口（Privileged Ports）

    - Internet 上面已经有很多规划好的固定 port (well-known port)，这些 port number 通常小于 1024，且是提供给许多知名的网络服务软件用的。在我们的 Linux 环境下，各网络服务与 port number 的对应默认给它写在 /etc/services 文件内喔！
    - 小于 1024 的端口要启动时，启动者的身份必须要是 root 才行，所以才叫做特权端口嘛！这个限制挺重要的，大家不要忘记喔！不过，如果是 client 端的话，由于 client 端都是主动向 server 端要资料，所以 client 端的 port number 就使用随机取一个大于 1024 且没有在使用的 port number。

  - Socket Pair

    - 由于网络是双向的，要达成连线的话得要服务器和用户端均提供 IP 与 端口才行。因此，我们常常将这个成对的资料称为 Socket Pair 。
    - 来源 IP + 来源端口（Source Address + Source Port）
    - 目的 IP + 目的端口（Destination Address + Destination Port）
    - 由于 IP 与端口常常连在一起说明，因此网络地址常常使用 「IP:port」来说明。例如想要连上鸟哥的网站时，正确的鸟哥网站写法应该是「linux.vbird.org:80」才对！

- TCP 的三次握手（Three-way handshake）

    - 由于网络是双向的，所以无论是服务器端还是用户端，都必须要通过一次 SYN 与 ACK 来建立连接，所以总共会进行三次交谈（SYN，SYN/ACK，ACK）。

    - 鸟哥上课谈到 TCP 最常做的事就是叫一个同学起来，实际表演三次握手给大家看：

      1. 鸟哥说：A 同学你在不在？

      2. A 同学说：我在！那鸟哥你在不在？

      3. 鸟哥说：我也在！

       这时两个人就确认彼此都可以通到对方在讲啥,这就是可靠连接啦!

- 非连接导向的 UDP 协议

  - UDP 比较适合需要即时反应的一些资料流，例如影像即时传送软件等。
  - UDP 传输协议不考虑连接要求、连接终止与流量控制等特性，所以使用的时机是当资料的正确性不是很重要的情况，例如网络摄像机。
  - 很多软件其实是同时提供 TCP 与 UDP 的传输协议的，举例来说，查询主机名称的 DNS 服务就同时提供了 UDP/TCP 协议。由于 UDP 较为快速，所以我们 client 端可以先使用 UDP 来与服务器连接。但是当使用 UDP 连接却还是无法取得正确的资料时，便转换为较为可靠的 TCP 传输协议来进行资料的传输。这样可以同时兼顾快速与可靠的传输。
  - 那么上课时怎么介绍 UDP 呢？很简单喔！鸟哥就会说：现在老师是在进行 UDP 传送，因为老师一直讲一直讲，俺也没有注意到你有没有听到，也不需要等待你的回应封包！就这样一直讲！当然，你没有听到鸟哥讲啥，我也不会知道...
  
- 网络防火墙与 OSI 七层协议

  - 如果以 OSI 七层协议来说，每一层可以抵挡的资料有：
    - 第二层：可以针对来源与目标的 MAC 进行抵挡；
    
    - 第三层：主要针对来源与目标的 IP，以及 ICMP 的类别（type）进行抵挡；
    
    - 第四层：针对 TCP/UDP 的端口进行抵挡，也可以针对 TCP 的状态（code）来处理。
    
  - 更多的防火墙资讯我们会在第九章防火墙与第七章认识网络安全中进行说明喔！
    



2.5 连上 Internet 前的准备事项

  - 用 IP 上网？主机名称上网？DNS 系统？
  - 一组可以连上 Internet 的必要网络参数
    - 一组合理的网络设定需要哪些资料呢？就是：IP、Netmask、Network、Broadcast、Gateway、DNS。由于 Network 与 Broadcast 可以经由 IP/Netmask 的计算而得到，因此需要设定属于你 PC 端的网络参数主要就是：IP、Netmask、Default Gateway、DNS 这四个！



2.6 重点回顾



2.7 本章习题

- 为何 ISP 有时会谈到「申请固定 8 个 IP，其中只有 5 个可以用」，你觉得问题出在哪里？如果以网域的观念来看，它的 netmask 会是多少？

  因为如果是一个网域的话，那么八个 IP 前后（Host_ID 全为 0 与 1 的情况）为 Network 及 Broadcast，加上一个在 ISP 处的 Gateway，所以仅有 5 个可以用。

  因为有 8 个 IP，所以其 netmask 后 8 bits 为 11111000，故 netmask 为 255.255.255.248 。



参考资料：[第二章链接](http://linux.vbird.org/linux_server/0110network_basic.php) 



&nbsp;

#### 第三章 区域网络架构简介

&nbsp;

#### 第四章 连上 Internet

&nbsp;

#### 第五章 Linux 常用网络指令



5.1 网络参数设定使用的指令

- 任何时候如果你想做好你的网络参数设定，包括 IP 参数、路由参数与无线网络等等，就得要了解底下这些相关的指令才行！其中以 ifconfig 及 route 这两个指令算是比较重要的喔！当然，比较新鲜的作法，可以使用 ip 这个汇整的指令来设定 IP 参数啦！
  - ifconfig
  - ifup, ifdown
  - route
  - ip
- 手动/自动设定与启动/关闭 IP 参数：ifconfig, ifup, ifdown
- 路由修改：route
- 网络参数综合指令：ip
  - 这个 ip 指令的功能可多了，基本上，他就是整合了 ifconfig 与 route 这两个指令啰~ 不过，ip 可以达成的功能却又多更多，如果你有兴趣的话，请自行 vi/sbin/ifup，就知道整个 ifup 就是利用 ip 这个指令来达成的。
  - 事实上，这个 ip 指令实在是太博大精深了！刚接触 Linux 网络的朋友，可能会看到有点晕~ 不要紧啦！你先会使用 ifconfig，ifup，ifdown 与 route 即可，等以后有经验了，再继续回来完 ip 这个好玩的指令吧！有兴趣的话，也可以自行参考 ethtool 这个指令喔！（man ethtool）
- 无线网络：iwlist，iwconfig
  - 这两个指令你必须要有无线网卡才能够进行喔！它们的应用我们在第四章里面的无线网卡设定谈了很多，所以这里我们不再详谈。
- 手动使用 DHCP 自动取得 IP 参数：dhclient



5.2 网络侦错与观察指令

- 其实我们在第四章谈到的五个检查步骤已经是相当详细的网络侦错流程了！只是还有些重要的侦测指令也得要了解一下才好！
- 两部主机两点沟通：ping
- 两主机间各节点分析：traceroute
- 查看本机的网络连接与后门：netstat
- 侦测主机名称与 IP 对应：host，nslookup
  - 更建议使用 dig 这个指令



5.3 远端连线指令与即时通讯软件

- 终端机与 BBS 连接：telnet
  - telnet 是早期我们在个人电脑上面要连接到服务器工作时，最重要的一个软件了！它不但可以直接连接到服务器上面，还可以用来连接 BBS 呢！非常棒，不过 telnet 本身的资料在传送的时候是使用明码，所以资料在 Internet 上面跑的时候会比较危险一点，怕被人监听。更详细的资料我们会在第十一章远程连接服务器中做介绍。
- FTP 连接软件：ftp，lftp
- 图形界面的即时通讯软件：pidgin（gaim 的延伸）



5.4 文字界面网页浏览

- 文字浏览器：links
  - 这个指令可以让我们来浏览网页，但鸟哥认为，它的最大功能是在查阅 Linux 本机上面以 HTML 语法写成的文件资料（document）。
- 文字界面下载器：wget
  - 如果说 links 是在进行网页的浏览，那么 wget 就是在进行网页资料的取得。举例来说，我们的 Linux 核心是放置在 www.kernel.org 内，主要同时提供 ftp 与 http 来下载。我们知道可以使用 lftp 来下载资料，但如果想要用浏览器下载呢？那就利用 wget 吧！



5.5 封包撷取功能

- 很多时候由于我们的网络连接出现问题，使用类似 ping 的软件功能却又无法找出问题点，最常见的是因为路由与 IP 转换后所产生的一些困扰（请参考防火墙与 NAT 主机部分），这个时候要怎么办？最简单的方法就是分析封包的流向啰！通过分析封包的流向，我们可以了解一条连接应该是如何进行双向的连接动作，也就会清楚地了解到可能发生的问题所在了！
- 文字界面封包撷取器：tcpdump
  - 说实在的，对于 tcpdump 这个软件来说，你甚至可以说它就是个骇客软件，因为它不但可以分析封包的流向，连封包的内容也可以进行监听，如果你使用的传输资料是明码的话，不得了，在 router 或 hub 上面就可能被人家监听走了！
  - 这个 tcpdump 必须使用 root 身边执行。
- 图形界面封包撷取器：wireshark
  - wireshark 这套软件早期称为 ethereal，目前同时提供文字界面的 tethereal 以及图形界面的 wireshark 两个咚咚。
- 任意启动 TCP/UDP 封包的端口连接：nc，netcat
  - 这个 nc 指令可以用来作为某些服务的检测，因为它可以连接到某个 port 来进行沟通，此外，还可以自行启动一个 port 来倾听其它用户的连接呐！非常的不错！如果在编译 nc 软件的时候给予 GAPING_SECURITY_HOLE 的参数的话，嘿嘿，这个软件还可以用来取得用户端的 bash 哩！可怕吧！我们的 CentOS 预设并没有给予上面的参数，所以我们不能够用来作为骇客软件~ 但是 nc 用来取代 telnet 也是个非常棒的功能了！（有的系统将执行文件 nc 改名为 netcat 啦！）



&nbsp;

#### 第六章 Linux 网络侦错

&nbsp;

### 第二部分 主机的简易资安防护措施



#### 第七章 网络安全与主机基本防护：限制端口，网络升级与 SELinux 

&nbsp;

#### 第八章 路由概念与路由器

&nbsp;

#### 第九章防火墙与 NAT 服务器

&nbsp;

#### 第十章 申请合法的主机名称

&nbsp;

### 第三部分：区域网络内常见的服务器架设



#### 第十一章 远程连接服务器 ssh，xdmcp，vnc，xrdp



11.1 远程连接服务器

- 什么是远程连接服务器
  - 很多人会说，我用 FTP 也要输入账号密码来登录啊？那与这章谈到的登录有何不同？最大的不同在于取得的 shell 能进行的工作啦！用 ssh/telnet/VNC 等方式取得的文字或图形 shell 能够进行很多系统管理的任务，与单纯的 FTP 能进行的工作当然不同！
  - 连接服务器的功能作用之一：分享 Unix Like 主机的运算能力
  - 服务器类型（Server）：有限度的开放连接
  - 工作站类型（Workstation）：只对内网开放
- 有哪些可供登录的类型
  - 文字界面明码：telnet，rsh 等为主，目前非常少用；
  - 文字界面密码：ssh 为主，已经取代上述的 telnet，rsh 等明码方式；
  - 图形界面：Xdmcp，VNC，RDP 等较为常见。
  - 至于图形界面的连接服务器，比较简单的有 Xdmcp (X Display Manager Control Protocol)，架设 Xdmcp 很简单，不过用户端的软件比较少。另外一款目前很常见的图形连接服务器就是 VNC (Virtual Network Computing)，通过 VNC server/client 软件来进行连接。如果你想要使用类似 Windows 的远程桌面连接，该功能使用的是 RDP (Remote Desktop Protocol)，那你可得要架设 RDP 服务器才行。
  - 图形界面最大的优点是图形啊，不过，因为是通过图形来传送，传输的资料量相当的大，所以速度与安全性都有待考量，因此，我们仅建议你将图形界面的远程登入服务器开放在内部网域（LAN）就好了！
  - 资料传送的明码与密码
  - 说 ssh 比较安全，其实是通过 ssh 通道传输讯息时，该讯息在网络上面比较安全，因此资料是加密过的，即使被窃取，对方可能也不会知道资料内容为何，因此资讯比较安全。但这不代表 ssh 这个通讯协议就比较安全喔！两者意义不同！
  - 由于明码传输的 telnet，rsh 等连接服务器已经被 ssh 取代，并且在一些实际应用上已经很少看到 telnet 与 rsh 了，因此本章在文字界面上着重介绍 ssh 的应用，包括以 rsync 借由 ssh 通道来进行异地备份的任务等等。至于图形界面则会介绍 Xdmcp，VNC 与 RDP 喔！因为很多工作站使用者需要显示他们在工作站实作后的图形呈现，因此这部分也是很重要的呢！



11.2 文字界面连接服务器：SSH 服务器

- SSH (Secure SHell Protocol，安全的壳程序协议) 

- 特别注意：这个 SSH 协议在默认的状态中，本身就提供两个服务器功能：

  1. 一个就是类似 telnet 的远程连接使用 shell 的服务器，以及是俗称的 ssh ；
  2. 另一个就是类似 FTP 服务的 sftp-server，提供更安全的 FTP 服务。

- 连接加密技术简介

  - 目前常见的网络封包加密技术通常是借由所谓的非对称金钥系统来处理的。主要是通过两把不一样的公钥与私钥（Public and Private Key）来进行加密与解密的过程。
  - 目前 SSH 的协议版本有两种，分别是 version1 与 version2，其中 V2 由于加上了连接检测的机制，可以避免连接期间被插入恶意的攻击码，因此比 V1 还要更加的安全。所以啰，请尽量使用 V2 版本即可，不要使用 V1 啰，无论是哪种版本，都还是需要公私钥加密系统的。
  - SSH 的连接行为简介
    1. 服务器建立公钥文件
    2. 用户端主动连接要求
    3. 服务器传送公钥文件给用户端
    4. 用户端记录/比对服务器的公钥资料及随机计算自己的公私钥
    5. 回传用户端的公钥资料到服务器
    6. 开始双向加解密

- 启动 SSH 服务

  - 事实上，在我们使用的 Linux 系统当中，默认就已经含有 SSH 所有需要的软件了，这包含了可以产生密码等协议的 OpenSSL 软件与 OpenSSH 软件。所以呢，要启动 SSH 真的是太简单了，就直接给它启动就是了！此外，在目前的 Linux Distributions 当中，都是默认启动 SSH 的。无论如何，我们还是得说一说这个启动的方式吧，直接启动就是以 SSH daemon，简称为 sshd 来启动的。

    `/etc/init.d/sshd restart` 

  - 这个 sshd 可以同时提供 shell 与 ftp 喔！而且都是架构在 port 22 上面的呢！

- ssh 用户端连接程序 - Linux 用户

  - ssh ：直接登录远端主机的指令
    - SSH 在 client 端使用的是 ssh 这个指令，这个指令可以指定连接的版本（version1，version2），还可以指定非正规的 ssh port（正规 ssh port 为 22）。
    - 一般使用 ssh 登录远端主机，都会填写 `ssh 账号@主机IP` 的格式，意思就是说使用该主机的某账号登录的意思。但是很多朋友不喜欢写账号，亦即使用 `ssh 主机IP` 的格式，如果不写账号的话，那么会以本地端电脑的账号来尝试登入远端。也就是说，如果近端与远端具有相同的账号，那么不写账号也没有关系，但为了以后习惯着想，还是一开始就使用类似 email 的方式来登录远端主机，这样的习惯比较好啦！
  - 服务器公钥记录文件：~/.ssh/known_hosts
  - 模拟 FTP 的文件传输方式：sftp
    - ssh 是登录远程服务器进行工作，那如果你只是想要从远程服务器下载或上传文件呢？那就不是使用 ssh 啦，而必须要使用 sftp 或 scp 。这两个指令也都是使用 ssh 的通道（port 22），只是模拟成 FTP 与复制的动作而已。
    - 我们先谈谈 sftp ，这个指令的用法与 ssh 很相似，只是 ssh 是用在登录而 sftp 在上传/下载文件而已。`sftp student@localhost` ，进入 sftp 之后，那就跟一般 FTP 模式下的操作方法没什么两样了。sftp 这个界面下的指令可分为：
      - 针对远方服务器主机（Server）的行为
      - 针对本地（Client）的行为（都加上l，L的小写）
      - 针对资料上传/下载的行为
    - 就整体而言，sftp 在 Linux 底下，如果不考虑图形界面，那么它已经可以取代 FTP 了呢！因此，在不考虑到图形界面的 FTP 软件时，可以直接关掉 FTP 的服务，而改以 sftp-server 来提供 FTP 的服务吧！
    - 如果你不喜欢使用文字界面进行 FTP 传输，那么还可以通过图形界面来连接到 sftp-server 哩！你可以利用二十一章提到的 Filezilla 来进行连接的啦！
  - 文件异地直接复制：scp
    - 通常使用 sftp 是因为可能不知道服务器上面有什么文件名的文件存在，如果已经知道服务器上的文件名了，那么最简单的文件传输则是通过 scp 这个指令喔！
    - 其实上传或下载的重点是那个冒号（:）啰！连接在冒号后面的就是远程主机的文件，因此，如果冒号在前，代表的就是从远程主机下载下来，如果冒号在后，则代表本机资料上传啦！而如果想要复制目录的话，那么可以加上 -r 选项！

- ssh 用户端连接程序 - Windows 用户

  - 与 Linux 不同的是，默认的 Windows 并没有 ssh 的用户端程序，因此所有的程序都得要下载第三方软件才行。常见的软件主要有 pietty，psftp 及 filezilla 等。
  - 直接连接的 pietty
    - 在 Linux 底下想要连接 ssh 服务器，可以直接利用 ssh 这个指令。在 Windows 操作系统下就得要使用 pietty 或 putty 这两个玩意儿。putty 的官方网站上有很多软件可以使用，包括 putty/pscp/psftp 等等，它们分别对应了 ssh/scp/sftp 这三个指令就是了。而鸟哥用的 pietty 则是台湾的林弘德先生根据 putty 所改版而成的。由于 pietty 除了完整的相容于 putty 外，还提供了选单与较为完整的文字编码，实在很好用呢，所以底下鸟哥就以 pietty 来作为介绍啰。
  - 使用 sftp-server 的功能：psftp
    - 在 putty 的官方网站上也提供 psftp 这支程序，这支程序的重点则在使用 sftp-server。使用的方式可以直接点选 psftp 这个文件，让它直接启动。
  - 图形化界面的 sftp 用户端软件：Filezilla
    - SSH 所提供的 sftp 功能只能利用纯文字界面的 psftp 来连接吗？有没有图形界面的软件呢？当然有！那就是非常有用的 Filezilla 啰！Filezilla 是图形界面的一个 FTP 用户端软件，使用上非常的方便，至于详细的安装与使用流程请参考二十一章的 vsftpd 的说明喔！

- sshd 服务器细部设定

  - 基本上，所有的 sshd 服务器的详细设定都放在 /etc/ssh/sshd_config 里面！不过，每个 Linux distribution 的默认设定都不太相同，所以我们有必要来了解一下整个设定值的意义为何才好！同时请注意，在默认的档案内，只要是默认有出现且被注解的设定值（设定值前面加 #），即为预设值！你可以依据它来修改的哩！
  - 基本上 CentOS 默认的 sshd 服务已经算是挺安全的了，不过还不够！建议你将 root 的登录权限取消，将 ssh 版本设定为 2。其它是设定值就请依照你自己的喜好来设定了。通常不建议进行随便修改啦！另外，如果你修改过 /etc/ssh/sshd_config 这个文件，那么就必须要重新启动一次 sshd 这个 daemon 才行！亦即是 `/etc/init.d/sshd restart` 。

- 制作不用密码可立即登录的 ssh 用户

  - 我们可以将 Client 产生的 Key 给它拷贝到 Server 当中，所以，以后 Client 登录 Server 时，由于两者在 SSH 要连接的讯号传递中，就已经比对过 Key 了，因此，可以立即进入资料传输界面中，而不需要再输入密码呢！在实作上的步骤可以是：
    - 用户端建立两把钥匙
    - 用户端放置好私钥文件
    - 将公钥放置服务器端的正确目录与文件中
  - 在建立金钥系统的步骤中你要记得的是：
    - Client 必须制作出 Public & Private 这两把 keys，且 Private 需放到 ~/.ssh/ 内；
    - Server 必须要有 Public Key，且放置到使用者家目录下的 ~/.ssh/authorized_keys，同时目录的权限（.ssh/）必须是 700，而档案权限则必须为 644，同时档案的拥有者与群组都必须与该账号吻合才行。

- 简易安全设定

  - 服务器软件本身的设定强化：/etc/ssh/sshd_config
  - TCP wrapper 的使用：/etc/hosts.allow，/etc/hosts.deny
  - iptables 的使用：iptables.rule，iptables.allow
  - 鸟哥呼吁大家，不要开放 SSH 的登录权限给所有 Internet 上面的主机~ 这很重要喔~ 因为如果对方可以 ssh 进入你的主机，那么 ... 太危险了~



11.3 最原始图形界面：Xdmcp 服务的启用

- X Window 的 Server/Client 架构与各元件
  - X Server：这组程序主要负责的是屏幕画面的绘制与显示。
  - X Client：这组程序主要负责的是资料的运算。
  - 鸟哥常常开玩笑地说，X Server 就是画布，而 X Client 就是手拿画笔的画家。你得要先有画布（管理好所有可显示的硬件后），之后画家的想法（计算出来的绘图数据）才能够绘制到画布上！
  - Window Manager (WM) ：一组控制所有 X client 的管理程序，并同时提供例如工作列、背景桌面、虚拟桌面、视窗大小、视窗移动与重叠显示等任务。
  - Display Manager (DM) ：提供使用者登录的画面以让使用者可以借由图形界面登录。
  - 目前新释出的 Linux distributions 中，通常启动图形界面让使用者登录的方式中，都是先执行 Display Manager 程序，该程序会主动载入一个 X Server 程序，然后再提供一个等待输入账号密码的界面程序，之后再根据使用者的选择去启动所需要的 Window Manager 程序，最后就由使用者直接操作 WM 来玩图形界面啰。
  - X Window System 用在网络上的方式：XDMCP
- 设定 gdm 的 XDMCP 服务
- 用户系统为 Linux 的登录方式
  - 在不同的 X 环境下启动连接：直接用 X
  - 在同一个 X 底下启动另一个 X ：使用 Xnest
- 用户系统为 Windows 的登录方式：Xming
  - 由于 Window 本身并没有提供默认的 X server，因此我们得要自行安装 X server 在 Windows 上面才行。X-win32 与 Exceed 都属于商业软件，而 Xming 则属于轻量级的自由软件。
  - 重点在 Server 与 Client 的防火墙上



11.4 华丽的图形界面：VNC 服务器

- 默认的 VNC 服务器：使用 twm window manager
- VNC 的用户端连接软件
  - Linux 用户端程序：vncviewer
  - Windows 用户端程序：realvnc
- VNC 搭配本机的 Xdmcp 画面
- 开机就启动 VNC server 的方法
- 同步的 VNC：可以通过图示同步教学



11.5 模拟的远程桌面系统：XRDP 服务器

- Xdmcp 与 VNC 原则上资料都没有加密，因此上面的动作大多仅适合区域网络内运行，不要连上 Internet 比较好。那如果你真的想要通过加密的方式运行 VNC，那可能得要通过下一小节的介绍才能够有好的处理结果。那么我们知道 Windows 的远程桌面（Remote Desktop Procotol，RDP） 其实是具有连接加密功能的，所以，能不能在 Linux 上面装一个 RDP Server 呢？是可以的，那就是 XRDP 服务器。



11.6 SSH 服务器的进阶应用

- 启动 ssh 在非正规端口（非 port 22）

  - 设定 ssh 在 port 22 及 23 两个端口的设定方式
  - 非正规端口的连接方式

- 以 rsync 进行同步镜像备份

  - 我们曾在基础篇的 Linux 的备份策略中谈到，常用的备份指令包括 tar，dd，cp 等等，不过当时并未介绍网络，所以有个很棒的网络工具没有介绍，那就是这个地方要谈到的 rsync 啦！这个 rsync 可以作为一个相当棒的异地备援系统的备份指令喔！因为 rsync 可以达到类似镜像（mirror）的功能呢！

  - rsync 最早是想要取代 rcp 这个指令的，因为 rsync 不但传输的速度快，而且它在传输时，可以比对本地端与远端主机欲复制的文件内容，而仅复制两端有差异的文件而已，所以传输的时间就相对地降低很多！此外 rsync 的传输方式至少可以通过三种方式来运行：

    - 在本机上直接运行，用法就与 cp 几乎一模一样，例如：

      `rsync -av /etc /tmp` ，将 /etc 的资料备份到 /tmp/etc 内。

    - 通过 rsh 或 ssh 的通道在 server/client 之间进行资料传输，例如：

      `rsync -av -e ssh user@rsh.server:/etc /tmp` ，将 rsh.server 的 /etc 备份到本地主机的 /tmp 内。

    - 直接通过 rsync 提供的服务（daemon）来传输，此时 rsync 主机需要启动 873 port ：

      1. 你必须要在 server 端启动 rsync，看 /etc/xinetd.d/rsync 即可；
      2. 你必须编辑 /etc/rsyncd.conf 设定文件；
      3. 你必须设定好 client 端连接的密码资料；
      4. 在 client 端可以利用：`rsync -av user@hostname::/dir/path /local/path` 

    其实这三种传输模式差异在于有没有冒号（:）而已，本地端传输不需要冒号，通过 ssh 或 rsh 时，就得要利用一个冒号（:），如果是通过 rsync daemon 的话，就得要两个冒号（::）。应该不难理解啦，因为本地端处理很简单，而我们的系统本来就有提供 ssh 的服务，所以底下鸟哥将直接介绍利用 rsync 通过 ssh 来备份的动作喔。 

- 通过 ssh 通道加密原本无加密的服务

- 以 ssh 通道配合 X server 传递图形界面



参考资料：[第十一章链接](http://linux.vbird.org/linux_server/0310telnetssh.php) 



&nbsp;

#### 第十二章 网络参数控管者：DHCP 服务器

&nbsp;

#### 第十三章 文件服务器一：NFS 服务器

&nbsp;

#### 第十四章 账号控管：NIS 服务器

&nbsp;

#### 第十五章 时间服务器：NTP 时间服务器

&nbsp;

#### 第十六章 文件服务器之二：SAMBA 服务器

&nbsp;

#### 第十七章 区网控制着：Proxy 服务器

&nbsp;

#### 第十八章 网络磁盘装置：iSCSI 服务器

&nbsp;

### 第四部分 常见网际网络服务器架设



#### 第十九章 主机名称控制者：DNS 服务器

&nbsp;

#### 第二十章 WWW 服务器

&nbsp;

#### 第二十一章 文件服务器之三：FTP 服务器

&nbsp;

#### 第二十二章 邮件服务器 Postfix

&nbsp;

### 这一部分内容参考资料

[鸟哥的Linux私房菜 - 服务器架设篇目录 - 第3版 - 2011年更新](http://linux.vbird.org/linux_server/index_old.php) 



&nbsp;

&nbsp;

## 附录



> **版权声明：本文采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh) 许可协议，若转载请注明出处**。

