---
title: '计算机网络-自顶向下-第4版-笔记'
category: Computer Networks
tags: 
  - 'Computer Networks'
---

这份笔记是我 2020 年 2 月下旬为了回顾计算机网络方面的知识，重新阅读机械工业出版社的[《计算机网络-自顶向下方法-第 4 版》](https://book.douban.com/subject/1391207/)这本教材所记录，当前这本教材已出到 [第 7 版](https://book.douban.com/subject/30280001/) 了，第 4 版是 2008 年出来的，但由于第 4 版的这本教材在我研一上课时有用过，而且计算机网络方面一些原理性的东西到现在几乎没什么变化，所以为了快速回顾相关的知识，我仍选择看下第 4 版的教材，主要查看了第 1 - 5 章，以及后面讲网络安全部分的第 8 章。不过，如果是初次通过这本教材来学习计算机网络的话，还是推荐看新版的教材。

<!-- more -->

笔记中所有的插图来自这本教材 [第 6 版](https://book.douban.com/subject/26176870/) 的一个电子版，第 6 版的中文版是 2014年出来的，而我看的这个第 4 版教材的电子版中插图不怎么清晰，在对比第 6 版的电子版时，发现这些插图和第 4 版中的内容完全对得上。



&nbsp;

## 第 1 章 计算机网络和因特网

1. 计算机网络领域已经发展得相当成熟，许多基础性的重要问题已经研究得较为清楚。例如：

   - 运输层的基础性问题包括：**建立在不可靠的网络层上的可靠通信、连接建立/拆除与握手、拥塞和流量控制以及多路复用**。
   - 网络层的两个基础性问题是：**在两台路由器之间找到 “好的” 路径，处理大量异构网络的互联**。
   - 数据链路层的基础性问题是：**共享多路访问信道**。
   - 在网络安全中，**提供机密性、鉴别和报文完整性的技术都基于密码学基本理论**。

   &nbsp;
   
   本书在指明基础性网络问题的同时，还研究了解决这些问题的方法。**掌握了这些原则的学生将获得具有长「保质期」的知识**，在今天的网络标准和协议已经过时的很长时间后，其中的原则将仍然重要且中肯。我们相信，因特网将学生引入网络之门后，再结合强调基础性问题及其解决方案的方法，会使他们迅速地理解几乎任何网络技术。



2. 本书的第 1 章提供了对计算机网络的概述，该章介绍了许多重要的概念与术语，为本书的其余部分奠定了基础。其它所有的章节都直接依赖于第 1 章的内容。**在讲解完第 1 章之后，我们推荐按顺序讲解第 2 章到第 5 章，这样就在教学中体现了自顶向下的思想，这几章中任何一章都用到前面各章的内容**。

   在完成前 5 章的教学工作之后，教师就有了相当大的灵活性。**最后 4 章之间没有任何相关性**，因此可以以任何顺序进行教学。然而，最后 4 章中的每一章都依赖于前 5 章。许多教师教授前 5 章，然后讲授后 4 章之一作为点睛之笔。



3. 端系统、分组交换机和其它因特网部件，都要运行控制因特网中信息接收和发送的一系列协议（protocol）。TCP（Transmission Control Protocol，传输控制协议）和 IP（Internet Protocol，网际协议）是因特网中最为重要的协议。**因特网主要的协议统称为 TCP/IP**。



4. 因特网标准（Internet standard）由因特网工程任务组（Internet Engineering Task Force，IETF）研发 [IETF 2007]，IETF 的标准文档被称为请求评论（Request For Comment，RFC）。**RFC 最初是作为普通的请求评论（因此而得名），以解决因特网先驱者们面临的体系结构问题**。RFC 文档往往是技术性很强并相当详细的。它们定义了诸如 TCP、IP、HTTP、SMTP这样的协议。



5. 因特网的第二种描述方法（根据基础设施向分布式应用程序提供的服务）是很重要的，因特网具体构成部件的发展日益由新应用程序的需求所驱动，因此，请记住，因特网是一种基础设施，新应用程序正在其上不断地被发明和设置。（因特网的两种描述方法：一种是根据它的硬件和软件组件来描述，另一种是根据基础设施向分布式应用程序提供的服务来描述。）



6. **报文的交换以及当发送和接收这些报文时所采取的动作是一个协议的关键定义元素**：一个协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输和/或接收或其它事件方面所采取的动作。

   一般来说，因特网和计算机网络广泛地使用了协议。不同的协议用于完成不同的通信任务。当你阅读完这本书后将会知道，一些协议简单而直截了当，而另一些协议则复杂难懂。**掌握计算机网络领域知识的过程就是理解网络协议的构成、原理和工作的过程**。



7.  **端到端的选路过程也与一个不使用地图而喜欢问路的汽车驾驶员类似。在这个类比中加油站服务员和骑自行车的孩子就好比是路由器，他们大脑中的转发表已经由多年积累起来的经验进行了配置**。



8. 比率 La/R 被称为流量强度（a 是分组到达队列的平均速率，单位 pkt/s；R 是链路的传输速率，单位是 bps；假定所有的分组都是由 L 比特组成的）。如果 La/R > 1，则比特到达队列的平均速率超过从该队列传输出去的速率。**在这种情况下，队列的增加将趋于无界，并且排队时延将趋向无穷大。因此，流量工程中有一条金科玉律就是：设计系统时流量强度不能大于 1**。



9. 报文（message）；报文段（segment）；数据报（datagram）；帧（frame）；比特（bit）。 分组（packet）。



10. **尽管网络层包括了 IP 协议和一些选路协议，但它经常只被称为 IP 层**，这反映了 IP 是将因特网连接在一起的沾合剂这样一个事实。



11. OSI 参考模型的七层中比因特网的五层多了**表示层和会话层**。表示层的作用是使通信的应用程序能够解释交换数据的含义，它所提供的服务包括数据压缩、数据加密以及数据描述；会话层提供了数据交换的定界和同步功能，包括建立检查点和恢复方案的方法。

    因特网中没有 OSI 参考模型中建立的这两层，引起了一些有趣的问题：**这两层提供的服务不重要吗？如果某应用程序需要这些服务之一，将会怎样呢？因特网对这两个问题的回答是相同的：这留给应用程序开发者处理**。因此，应用程序开发者应决定这样的服务是否重要，如果重要，就应该在应用程序中构建该功能。



12. 大多数因特网拒绝服务攻击（Denial-of-Service，DoS）属于以下三种类型之一：弱点攻击；带宽洪泛；连接洪泛。分布式DoS（distributed DoS，DDoS）攻击中攻击者控制多个源并让每个源向目标猛烈发送流量。DDoS 攻击充分利用数以千计的受害主机组成的僵尸网络（botnet）在今天是屡见不鲜的，与来自单一主机的 DoS 攻击相比，DDoS 攻击更加难以检测和防御。



13. 有必要思考一下因特网是如何从一开始就陷入不安全的境地的。大体上讲，**答案是因特网最初就是基于「一群相互信任的用户连接到一个透明的网络上」这样的模型进行设计的，在这样的模型中，安全性是没有必要的。初始的因特网在许多方面都深刻地反映了这种相互信任的观念**。

    但是，今天的因特网并不涉及「相互信任的用户」。在进一步学习本书之前，已经有许多安全性相关的挑战：我们应当对抗嗅探、端点假冒、中间人攻击、DDoS攻击、恶意软件等。一定要牢记：**相互信任的用户之间的通信是一种例外，欢迎来到现代计算机网络世界**。





## 第 2 章 应用层

1. 应用程序体系结构（application architecture）由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。在选择应用程序体系结构时，应用程序研发者很可能利用现代网络应用程序中所使用的两种主流体系结构之一：**客户机/服务器体系结构或对等（P2P）体系结构**。



2. **运行在多个端系统上的程序的相互通信实际上是进程进行通信，而不是程序**。进程可以被认为是运行在端系统中的程序。进程间通信的规则由端系统上的操作系统确定，**本书中，我们对运行在同一台主机上的进程间的通信不感兴趣，而只关注运行在不同端系统（可能具有不同的操作系统）上的进程间的通信**。



3. 在给定的一对进程之间的通信会话中，发起通信（即在该会话开始时与其他进程联系）的进程被标示为客户机，在会话开始时等待联系的进程是服务器。



4. Web 的应用层协议是超文本传输协议（HyperText Transfer Protocol，HTTP），它是 Web 的核心。HTTP 协议由两部分程序实现：一个客户机程序和一个服务器程序，它们运行在不同的端系统中，**通过交换 HTTP 报文进行会话。HTTP 定义了这些报文的格式以及客户机和服务器是如何进行报文交换的**。



5. Web 页面是由对象组成。对象（object）简单来说就是文件，如 HTML 文件、JPEG 图形文件、Java 小程序或视频片段文件，这些文件可通过一个 URL 地址寻址。多数 Web 页面含有一个基本的 HTML 文件（base HTML file）以及几个引用对象。



6. 当用户请求一个 Web 页面（如点击一个超链接）时，浏览器向服务器发出对该页面所包含的对象的 HTTP 请求报文，服务器接受请求并用包含这些对象的 HTTP 响应报文进行响应。**HTTP 使用 TCP 作为它的支撑运输层协议**。



7. 服务器向客户机发送被请求的文件时，并不存储任何关于该客户机的状态信息。假如某个特定的客户机在短短几秒内两次请求同一个对象，服务器并不会因为刚刚为该用户提供了该对象就不再做出反应，而是重新发送该对象，就像该服务器已经完全忘记不久之前所做过的事一样。**因为一个 HTTP 服务器并不保存关于客户机的任何信息，所以我们说 HTTP 是一个无状态协议（stateless protocol）**。

   非持久连接和持久连接

   估算一下从客户机请求基本 HTML 文件开始到用户收到整个文件为止所花费的时间：**总的响应时间就是两个 RTT（Round-Trip Time，RTT） 加上服务器传输 HTML 文件的时间**。（一个 RTT 等于三次握手中的前两部分所耗费的时间。**完成了三次握手的前两个部分后，客户机将三次握手的第三部分（确认）与一个 HTTP 请求报文结合起来发送到该 TCP 连接**，一旦该请求报文到达服务器，服务器向该 TCP 连接发送 HTML 文件，该 HTTP 请求/响应又耗费掉一个 RTT。）



8. HTTP 报文格式

   HTTP 报文有两种：请求报文和响应报文。

   HTTP 请求报文：

   - HTTP 请求报文的第一行叫做请求行（request line），其后继的行叫做首部行（header line）。
   - 请求行有 3 个字段：方法字段、URL 字段和 HTTP 协议版本字段。
   - 方法字段可以取值 GET、POST、HEAD、PUT 和 DELETE。

   HTTP 响应报文：

   - 它分成三个部分：一个初始状态行（status line）、6 个首部行（header line），然后是实体主体（entity body）。实体主体部分是报文的主题，即它包含了所请求的对象本身。
   - 状态行有 3 个字段：协议版本、状态码和相应的状态信息。
   - 一些常见的状态码和相关短语：
     - 200 OK：请求成功，信息包含在返回的响应报文中。
     - 301 Moved Permanently：请求对象已经被永久转移了，新的 URL 定义在响应报文的 Location: 首部行中指定。客户机软件自动用新的 URL 获取该对象。
     - 400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解。
     - 404 Not Found：被请求的文档不在服务器上。
     - 505 HTTP Version Not Supported：服务器不支持请求报文使用的 HTTP 协议版本。
     - 304 Not Modified（它告诉缓存器可以使用该对象，向请求的浏览器转发该对象的拷贝。注：这个状态码在这本书中没有列举出来，是我在其它地方看到的，觉得也比较常见，于是添加到了这里。）
   
   &nbsp;

9. 用户与服务器的交互：cookie

   前面提到 HTTP 服务器是无状态的，这简化了服务器的设计，并且允许工程师们去开发可以同时处理数以千计 TCP 连接的高性能的 Web 服务器。**然而一个 Web 站点通常希望能够识别用户，即可能是因为服务器想限制用户的访问，又可能是因为它想把内容与用户身份关联起来**。为此，HTTP 使用了 cookie，它允许站点跟踪用户。目前，大多数商务 Web 站点都使用了 cookie。

   cookie 技术由 4 个组成部分：

   1. 在 HTTP 响应报文中有一个 cookie 首部行；
   2. 在 HTTP 请求报文中有一个 cookie 首部行；
   3. 在用户端系统中保留有一个 cookie 文件，由用户的浏览器管理；
   4. 在 Web 站点有一个后端数据库。
   
   &nbsp;

10. **Web 缓存器（Web cache）也叫代理服务器（proxy server），它是能够代表初始 Web 服务器来满足 HTTP 请求的网络实体**。Web 缓存器有自己的磁盘存储空间，并在该存储空间中保存最近请求过的对象的拷贝。

    可以配置用户的浏览器，使得用户的所有 HTTP 请求首先指向 Web 缓存器。一旦配置了浏览器，每个浏览器对一个对象的请求首先被定向到 Web 缓存器。举例来说。假设浏览器正在请求对象 http://www.someschool.edu/campus.gif ，将会发生如下情况：

    1. 浏览器建立一个到 Web 缓存器的 TCP 连接，并向 Web 缓存器中的对象发送一个 HTTP 请求。
    2. Web 缓存器检查本地是否存储了该对象拷贝，如果有，Web 缓存器就用 HTTP 响应报文向客户机浏览器返回该对象。
    3. 如果 Web 缓存器没有该对象，它就与该对象的初始服务器（www.someschool.edu）打开一个 TCP 连接。Web 缓存器则在 TCP 连接上发送获取该对象的 HTTP 请求。在收到请求后，初始服务器向该 Web 缓存器发送具有该对象的 HTTP 响应。
    4. 当 Web 缓存器接收该对象时，它在本地存储空间存储了一份拷贝，并用 HTTP 响应报文向客户机的浏览器发送该拷贝（通过已经建立在客户机浏览器和 Web 缓存器之间的 TCP 连接）。

    &nbsp;
    
    **注意到 Web 缓存器既是服务器又是客户机。当它接收浏览器的请求并发回响应时，它是服务器；当它向初始服务器发出请求并接收响应时，它是客户机**。

11. HTTP 协议有一种机制，允许缓存器证实它的对象是最新的，这种机制就是条件 GET（conditional GET）方法。如果请求报文使用 GET 方法并且请求报文中包含一个 If-modified-since: 首部行，那么这个 HTTP 请求报文就是一个条件 GET 请求报文。



12. 至此，我们已经讨论了第一个因特网协议（应用层协议）—— HTTP，我们学习了 HTTP 报文的格式，以及发送和接收 HTTP 报文时 Web 客户机和服务器所采取的动作，我们还学习了一些与 HTTP 协议有关的 Web 应用程序基础设施，包括缓存、cookie 和后端数据库。



13. HTTP 和 FTP 都是文件传输协议，并且有很多共同点。例如，它们都运行在 TCP 上。然后这两个应用层协议也有一些重要的区别，其中最显著的就是 **FTP 使用两个并行的 TCP 链接来传输文件，一个是控制连接（control connection），一个是数据连接（data connection）**。

    因为 FTP 协议使用一个分离的控制连接，所以我们也称 FTP 的控制信息是带外（out-of-band）传送的。而 HTTP 协议是在传输文件的 TCP 连接中发送请求和响应首部行的，因此，HTTP 也可以说是带内（in-band）发送控制信息的。



14. 因特网电子邮件系统有 3 个主要组成部分：用户代理（user agent）、邮件服务器（mail server）和简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）。

    SMTP 是因特网电子邮件中主要的应用层协议，**它使用 TCP 可靠数据传输服务，从发送方的邮件服务器向接受方方邮件服务器发送邮件**。

    HTTP 和 SMTP 的对比：

    - 相同点：当进行文件传送时，都使用持久连接。
    - 区别：
      1. HTTP 主要是一个拉协议（pull protocol），用户使用 HTTP 从该服务器拉取信息。而 SMTP 基本上是一个推协议（push protocol），即发送邮件服务器把文件推向接收邮件服务器。
      2. SMTP 要求每个报文（包括它们的主体）都使用 7 位 ASCII 码格式。如果某报文包含非 7 位 ASCII 字符（如具有重音的法文字符）或二进制数据（如图形文件），则该报文必须按照 7 位 ASCII 码进行编码。而 HTTP 数据则没有这个限制。
      3. HTTP 把每个对象封装到它自己的 HTTP 响应报文中，而因特网电子邮件把所有报文对象放在一个报文之中。

    &nbsp;

    邮件报文格式和 MIME（多用途因特网邮件扩展，Multipurpose Internet Mail Extension，MIME）

    

    从邮件服务器上传送邮件到本地 PC 的一些协议：第三版邮局协议（Post Office Protocol-Version 3，POP3）、因特网邮件访问协议（Internet Mail Access Protocol，IMAP）以及 HTTP。

    

    基于 Web 的电子邮件：使用这种服务，用户代理就是普通的浏览器，用户和其远程邮箱之间的通信则通过 HTTP 进行。当一个收件人想从他的邮箱中取一个报文时，该电子邮件报文从 Bob 的邮件服务器发送到他的浏览器，使用的是 HTTP 而不是 POP3 或者 IMAP 协议；当发件人要发送一封电子邮件报文时，该电子邮件报文从发送人的浏览器发送到他的邮件服务器，使用的是 HTTP 而不是 SMTP。然而，**发件人的邮件服务器在与其他的邮件服务器之间发送和接收邮件时，仍然使用 SMTP**。



15. DNS（Domain Name System，域名系统）是：**一个由分层的 DNS 服务器（DNS server）实现的分布式数据库；一个允许主机查询分布式数据库的应用层协议**。（DNS 服务器通常是运行 BIND（Berkeley Internet Name Domain）软件的 UNIX 机器）。

    除了进行主机名到 IP 地址的转换以外，DNS 还提供了一些重要的服务：

    - 主机别名（host aliasing）
    - 邮件服务器别名（mail server aliasing）
    - 负载分配（load distribution）：DNS 也用于在冗余的服务器（如冗余的 Web 服务器等）之间进行负载分配。繁忙的站点（如 cnn.com）被冗余分布在多台服务器上，每台服务器均运行在不同的端系统上，有着不同的 IP 地址。对于这些冗余的 Web 服务器，一个 IP 地址集合对应于同一个规范主机名。DNS 数据库中存储着这些 IP 地址集合。**当客户机为映射到这个 IP 地址集合的名字发出一个 DNS 请求时，该服务器用包含全部的这些地址的报文进行回答，但在每个回答中旋转这些地址排放的顺序。因为客户机通常总是向 IP 地址排在最前面的服务器发送 HTTP 请求报文，所以 DNS 就在所有这些冗余的 Web 服务器之间旋转分配负载**。

    &nbsp;

    DNS 采用了分布式的设计方案，事实上，DNS 是一个在因特网上实现分布式数据库的精彩范例。

    1. 分布式、层次数据库。

       没有一台 DNS 服务器具有因特网上所有主机的映射，相反，该映射分布在所有的 DNS 服务器上。大致说来，有 3 种类型的 DNS 服务器：根 DNS 服务器、顶级域（Top-Level Domain，TLD）DNS 服务器和权威 DNS 服务器。

       - 根 DNS 服务器：在因特网上有 13 个根 DNS 服务器（标号 A 到 M），其中大部分位于北美洲。尽管我们将这 13 个根 DNS 服务器中的每个都视为单个的服务器，但每台 “服务器” 实际上是冗余服务器的群集，以提供安全性和可靠性。
       - 顶级域（Top-Level Domain，TLD）服务器：这些服务器负责顶级域名（如 com、org、net、edu 和 gov）和所有国家的顶级域名（如 uk、fr、ca 和 jp）。
       - 权威 DNS 服务器：在因特网上具有公共可访问主机（如 Web 服务器和邮件服务器）的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。由组织机构的权威 DNS 服务器负责保存这些 DNS 记录，组织机构可以选择实现它自己的权威 DNS 服务器来保持这些记录，另一种方法是支付费用将这些记录存储在某个服务提供商的权威 DNS 服务器中。

       &nbsp;

       **跟、顶级域和权威 DNS 服务器都处在 DNS 服务器的层次结构中，但还有另一类重要的 DNS ，称为本地 DNS 服务器（local DNS server）**。本地 DNS 服务器严格来说并不属于 DNS 服务器的层次结构，但它对 DNS 层次结构是很重要的。**每个 ISP（如大学、系、公司或居民区的 ISP）都有一台本地 DNS 服务器（也叫默认名字服务器）**。当主机与某个 ISP 连接时，该 ISP 提供一台主机的 IP，该主机具有一台或多台其本地 DNS 服务器的 IP 地址（通常通过 DHCP）。**当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 服务器层次结构中**。

    2. DNS 缓存（DNS caching）

       为了改善时延性能并减少在因特网上到处传输的 DNS 报文数量，DNS 广泛使用了缓存技术。

       如果在 DNS 服务器中缓存了一个主机/IP 地址对，另一个对相同主机名的查询到达该 DNS 服务器时，该服务器能够提供所要求的 IP 地址，即使它不是该主机名的权威服务器。由于主机和主机名与 IP 地址间的映射对不是永久的，所以 DNS 服务器在一段时间后（通常设置为两天）将丢弃缓存的信息。

       本地 DNS 服务器也可以缓存 TLD 服务器的 IP 地址，因而允许本地 DNS 绕过查询链中的根 DNS 服务器（这经常发生）。

    

    DNS 记录和报文

    实现 DNS 分布式数据库的所有 DNS 服务器共同存储着资源记录（Resource Record，RR），RR 提供了主机名到 IP 地址的映射。每个 DNS 回答报文包含了一条或多条资源记录。

    资源记录是一个包含了下列字段的 4 元组：（Name, Value, Type, TTL）。TTL 是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。在下面给出的资源记录中，我们忽略掉 TTL 字段。Name 和 Value 的值取决于 Type。

    如果 Type = MX，则 Value 是别名为 Name 的邮件服务器的规范主机名，例如（foo.com, mail.bar.foo.com, MX）就是一条 MX 记录。MX 记录允许邮件服务器的主机名具有简单的别名。注意，通过使用 MX 记录，一个公司的邮件服务器和其它服务器（如它的 Web 服务器）可以使用相同的别名。

    

    DNS 只有查询和回答这两种报文。
    
    `nslookup` 



16. P2P 应用

    P2P 文件分发：

    1. P2P 体系结构的扩展性
    2. BitTorrent

    在 P2P 区域中搜索信息：

    - 集中式索引（缺点：单点故障；性能瓶颈和基础设施费用；侵犯版权）
    - 查询洪泛
    - 层次覆盖（层次覆盖设计允许数量多得多的对等方检查匹配，而不会产生过量的查询流量；分布式散列表（Distributed Hash Table，DHT））

    &nbsp;
    
    案例学习：Skype 的 P2P 因特网电话



17. 网络应用程序有两类：
    - 一类是网络应用程序，它们由如 RFC 所定义的标准协议的实现，对于这类实现，客户机程序和服务器程序必须满足该 RFC 所定义的规则。如果一个开发者编写客户机程序的代码，另一个开发者编写服务器程序的代码，并且两者都完全遵从该 RFC 的规则，那么这两个程序将能够交互操作。当客户机程序或服务器程序实现类由某 RFC 定义的协议时，应该使用与协议相关的端口号。
    - 另一类网络应用程序是专用的网络应用程序。在这种情况下，由客户机程序和服务器程序使用的应用层协议不必符合任何现有 RFC。一个开发者（或开发团队）创建了客户机程序和服务器程序，并且该开发者使用他的代码完全控制这程序的功能。**但是因为这些代码并没有实现公共的协议，其他独立的开发者将不能开发出和该应用程序交互的代码。当研发一个专用应用程序时，开发者必须小心，不要使用已在 RFC 中定义的周知端口号**。
    
    &nbsp;

18. 由于套接字在客户机/服务器应用程序中起着核心作用，因此客户机/服务器应用程序开发也称为套接字编程。



19. TCP 套接字编程：客户端从键盘读取一行字符，通过其套接字发送到服务器，服务器从其连接套接字读取一行字符，然后将该行字符转换成大写，服务器将修改后的行通过其连接套接字再回发给客户机，客户机从其套接字中读取修改后的行，然后将该行在其标准输出上打印出来。

    练习：可以稍微修改下这个程序，不是将所有的字符都转换成大写，而是让服务器统计字母 "s" 出现的次数，然后返回统计的个数。



20. UDP 套接字编程

    用 Java 编写 UDP 程序和用它编写 TCP 程序有很多不同之处，特别是我们应当注意以下几点：

    1. 两个进程之间没有进行初始握手，因此不需要欢迎套接字；
    2. 没有流与套接字相联系；
    3. 发送主机通过将 IP 目的地址和端口号与它发送的每批字节相联系，生成分组；
    4. 接收进程必须拆开每个所接收到的分组，获得该分组的信息字节。

&nbsp;



## 第 3 章 运输层

1. 前面讲过，更一般而言因特网是一个 TCP/IP 网络，为应用层提供了两种截然不同的运输层协议。其中，一种是 UDP（用户数据报协议），它为调用它的应用程序提供了一种不可靠的、无连接的服务。另一种是 TCP（传输控制协议），它为调用它的应用程序提供了一种可靠的、面向连接的服务。当设计一个网络应用程序时，该应用程序的开发人员必须指定使用这两种运输层协议中的哪一种。



2. **IP（网际协议）为主机之间提供了逻辑通信，IP 的服务模型是尽力而为交付服务（best-effort delivery service）**。这意味着 IP 尽它最大努力在通信的主机之间交付报文段，但它不做任何确保，特别是，它不确保报文段的交付，不保证报文段的按序交付，更不保证报文段中数据的完整性。由于这些原因，**IP 被称为不可靠服务（unreliable service）**。



3. 将主机间交付扩展到进程间交付，称为运输层的多路复用（transport-layer multiplexing）与多路分解（demultiplexing）。UDP 和 TCP 还可以通过在其报文段的首部添加差错检测字段而提供完整性检查，**进程间数据交付和差错检测是两种最低限度的运输层服务，也是 UDP 所能提供的仅有的两种服务**。



4. 从原理上讲，TCP 允许 TCP 连接通过一条拥塞的网络链路，平等地共享网络链路带宽，这可以通过调节发送方 TCP 发送到网络的流量速率来实现。**另一方面，UDP 流量是不可调节的，使用 UDP 传输的应用程序可以根据其需要以任何速率发送数据**。



5. 将运输层报文段中的数据交付到正确的套接字的工作称为多路分解（demultiplexing）。从源主机的不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在多路分解时使用）从而生成报文段，然后将报文段传递到网络层的工作称为多路复用（multiplxing）。



6. **端口号是一个 16 比特的数字**，其大小在 0-65535 之间，**0-1023 范围的端口号称为周知端口号（well-known port number），是受严格限制的**，也就是说它们是保留给诸如 HTTP（它使用端口号 80）和 FTP（它使用端口号 21）之类的周知应用层协议的。

   如果应用程序开发者所编写的代码实现的是一个 “周知协议” 的服务器端，那么他就必须为其分配一个相应的周知端口号。**典型的情况是，应用程序的客户机端口让运输层自动地（并且透明地）分配端口号，而服务器端口则分配一个特定的端口号**。

   

   端口扫描器（nmap）

   

7. 通常使用 UDP 的应用层协议：RIP、DNS 等。

   

8. UDP 首部只有 4 个字段，每个字段由两个字节组成（共 8 字节）。

   <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/TheStructureofUDPSegment-fromTextbook.JPG" alt="TheStructureofUDPSegment-fromTextbook" style="zoom:70%;" />

   

   通过端口号可以使目的主机将应用数据交给运行在目的端系统中相应进程（即执行多路分解功能）。

   接收主机使用检验和来检查报文段中是否存在差错。**事实上计算检验和时，除了 UDP 报文段以外还是用了 IP 首部的一些字段**。

   长度字段指明了包括首部在内的 UDP 报文段长度（以字节为单位）。



### 可靠数据传输的原理

7. 可靠数据传输的原理

   构造可靠数据传输协议

   有限状态机（finite-state machine，FSM）

   

   考虑一下你自己是怎么通过电话口述一条长消息的。通常情况下，报文接受者在听到、明白、记下每句话后可能会说 “OK”，如果消息接收者听到一句含糊不清的话，他可能要求你重复刚才那句话。这种口述消息协议使用了**肯定确认（positive acknowledgement）**（“OK”）与**否定确认（negative acknowledgement）**（“请重复一遍”）。这些控制报文使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误从而需要重传。**在计算机网络环境中，基于这种重传机制的可靠数据传输协议称为自动重传请求（Automatic Repeat reQuest，ARQ）协议**。

   

   发送方将不会发送一块新数据，直到发送方确信接收方已正确接收当前分组为止。由于这种行为，类似于 rdt2.0 的协议被称为**停等（stop-and-wait）协议**。

   从发送方的观点来看，重传是一种万能灵药，发送方不知道是一个数据分组丢失、一个 ACK 丢失，还是该分组或 ACK 只是过度时延。在所有情况下，采取的动作是同样的：重传。**为了实现基于时间的重传机制，需要一个倒计数定时器（countdown timer）**。

   现在我们归纳一下数据传输协议的要点。在**检验和、序号、定时器、肯定确认和否定确认分组**这些技术中，每种机制都在协议的运行中起到了必不可少的作用。**至此，我们得到了一个有效的可靠数据传输协议**。

   

   定义发送方（或信道）的利用率（utilization）为：发送方实际忙着将发送比特送进信道的那部分时间与发送时间之比。停等协议有着非常低的发送方利用率。

   不使用停等方式运行，允许发送方发送多个分组而无需等待确认，**如果发送方可以在等待确认之前发送 3 个分组，其利用率也将是原来的 3 倍**。因为从发送方向接收方传输的众多分组可以被看成是填充到一条流水线中，故这种技术被称为**流水线（pipelining）**。

   流水线技术可对可靠数据传输协议带来如下影响：

   - **必须增加序号范围**，因为每个传输的分组（不计算重传的）必须有一个唯一的序号，而且也许有多个在传输中的未确认的分组。
   - **协议的发送方和接收方也许必须缓存多个分组**。发送方最低限度应当能缓冲那些一发送但没有确认的分组，接收方或许也需要缓存那些已正确接收的分组。
   - **所需序号范围和对缓存的要求取决于数据传输协议处理丢失、损坏及过度延时分组的方式**。解决流水线的差错恢复有两种基本方法：**回退 N 步（Go-Back-N，GBN）和选择重传（selective repeat）**。

   &nbsp;

   回退 N 步

   GBN 发送方必须响应以下三种类型的事件：

   - 上层的调用
   - 收到 ACK
   - 超时事件

   &nbsp;

   这里我们注意到，GBN 协议中综合了我们在前面学习 TCP 可靠数据传输构件时遇到的所有技术。这些技术包括**使用序号、累计确认、检验和以及超时/重传操作**。

   

   选择重传（SR）
   
   对于 SR 协议而言，窗口长度必须小于或等于序号空间大小的一半。



### 面向连接的运输：TCP

8. 面向连接的运输：TCP

   既然我们已经学习了可靠数据传输的基本原理，那么就可以转而学习 TCP 了，该协议是因特网的运输层、面向连接的可靠运输协议。**为了提供可靠数据传输，TCP 依赖于之前所讨论的许多基本原理，其中包括差错检测、重传、积累确认、定时器以及用于序号和确认号的首部字段**。

   

   三次握手（three-way handshake）：客户机首先发送一个特殊的 TCP 报文段，服务器用另一个特殊的 TCP 报文段来响应，最后客户机再用第三个特殊报文段作为响应。**前两个报文段不承载 ”有效载荷“，也就是不包含应用层数据，而第三个报文段可以承载有效载荷**。由于这两台主机之间发送了 3 个报文段，所以这种连接建立过程常被称为三次握手。

   

   TCP 将这些数据（来自客户机进程）引导到该连接的发送缓存（send buffer）里，发送缓存是在三次握手初期设置的缓存之一。TCP 可从缓存中取出并放入报文段中的数据量受限于最大报文段长（maximum segment size，MSS）。MSS 通常根据最初确定的最大链路层帧长度来设置，本地发送主机发送长度是这样的帧，即所谓最大传输单元（maximum transmission unit，MTU），接着设置该 MSS 以保证一个 TCP 报文段（当封装在一个 IP 数据报中时）适合单个链路层帧。MTU 的常见值是 1460 字节、536字节或 512 字节。

   有人已经提出了发现路径的 MTU 方法，并基于该路径 MTU 值设置 MSS，其中路径 MTU 是指能在从源到目的地所有链路上发送的最大链路层帧。**注意到 MSS 是指报文段里应用层数据的最大长度，而不是指包括 TCP 首部的 TCP 报文段的最大长度**。

   

   TCP 连接的每一端都有各自的发送缓存和接收缓存。

   当 TCP 发送一个大文件（例如，某 Web 页面上的一个图像）时，TCP 通常是将文件划分成长度为 MSS 的若干块（最后一块除外，它通常小于 MSS）。然而交互式应用通常传送长度小于 MSS 的数据块，例如，对于像 Telnet 这样的远程登录应用，其 TCP 报文段的数据字段通常只有一个字节。由于 TCP 的首部一般是 20 字节（比 UDP 首部多 12 字节），所以 Telnet 发送的报文段也许只有 21 字节长。

   

   **和 UDP 一样，TCP 的首部包括源端口和目的端口号（source and destination port number）、检验和字段（checksum field）**。此外，TCP 报文首部还包含下列字段：

   <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/TheStructureofTCPSegment-fromTextbook.JPG" alt="TheStructureofTCPSegment-fromTextbook" style="zoom:67%;" />

   

   - 32比特的序号字段（sequence number field）和 32 比特的确认号字段（acknowledgement number field）。
   - 16 比特的接收窗口（receive window）字段，用于流量控制。
   - 4 比特的首部长度字段（header length field），该字段指示了以 32 比特的字为单位的 TCP 首部长度。由于 TCP 选项字段的原因，TCP 首部的长度是可变的。（通常，选项字段为空，所以一般 TCP 首部的长度就是 20 字节。）
   - 可选与变长的选项字段（options field），该字段用于当发送方与接收方协商最大报文段长度（MSS），或在高速网络环境下用作窗口调节因子时使用。
   - 6 比特的标志字段（flag field）。**ACK 比特用于指示确认字段中的值是有效的**，即该报文段包括一个对已成功接收报文段的确认。**RST、SYN 和 FIN 比特用于连接建立和拆除**。当 PUSH 比特被设置时，就指示接收方应立即将数据交给上层。URG 比特用来指示报文段里存在着被发送方上层实体置为 “紧急” 的数据。紧急数据的最后一个字节由 16 比特的紧急数据指针字段（urgent data pointer field）指出。当紧急数据存在并给出指向紧急数据尾的指针时，TCP 必须通知接收方方上层实体。（**在实际中，PSH、URG 和 紧急数据指针并没有使用，为了完整性起见，我们才提及这些字段**。）

   &nbsp;

   TCP 把数据看成一个无结构的但是有序的字节流，序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。 **一个报文段的序号是该报文段首字节的字节流编号**。

   TCP 是全双工通信，因此主机 A 也许在向主机 B 发送数据的同时，也接收来自主机 B 的数据（都是同一条 TCP 连接的一部分），从主机 B 到达的每个报文段都有一个序号用于从 B 流向 A 的数据，**主机 A 填充进报文段的确认号是主机 A 期望从主机 B 收到的下一字节的序号**。TCP 只确认数据流中至第一个丢失字节为止的字节，**所以 TCP 被称为是提供累计确认（cumulative acknowledgement）**。

   

   下图是一个基于 TCP 的简单 Telnet 应用的确认号和序号：

   <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/TheSqeAndACKNumberinTCPUsedByASimpleTelnetApplication.JPG" alt="TheSqeAndACKNumberinTCPUsedByASimpleTelnetApplication" style="zoom:67%;" />

   

   其中第二个报文段是由服务器发往客户机（即主机 B 到主机 A），它有两个目的：第一个目的是为服务器所收到的数据提供确认。服务器通过在确认号字段中填入 43 ，告诉客户机它已经 成功收到字节 42 及之前的所有字节，现在正在等待着字节 43 的出现。第二个目的是回显字符 “C”，因此，在第二个报文段的数据字段里填入的是字符 “C” 的 ASCII 码。注意到**对客户机到服务器的数据的确认**被装载在一个承载**服务器到客户机的数据的报文段中**，这种确认被称为是捎带（piggybacked）在服务器到客户机的数据报文段中的。

   第三个报文段是从客户机发往服务器的，它的唯一目的是确认已从服务器收到的数据。该报文段的数据字段为空（即确认信息没有被捎带在任何从客户机到服务器的数据中），该报文段的确认号字段填入的是 80，因为客户机已经收到了字节流中序号为 79 及以前的字节，它现在正等待着字节 80 的出现。此外，你可能认为这有点奇怪，即该报文段里没有数据但仍有序号，这是因为 TCP 存在序号字段，报文段需要填入某些序号。

   

   TCP 在 IP 的不可靠的尽力而为服务的基础上建立了一种可靠数据传输服务（reliable data transfer service）。TCP 的可靠数据传输服务确保一个进程从其接收缓存中读出非损坏、无间隔的、非冗余的和按序的数据流，即该字节流与连接的另一方端系统发出的字节流完全一样。TCP 提供可靠数据传输的方法涉及之前提到的许多原理。

   

   加倍超时间隔：每次 TCP 重传都会将下一次的超时间隔设为先前值的两倍，而不是从 EstimatedRTT 和 DevRTT 推出。因此，**超时间隔在每次重传后会呈指数型增长**。然而，**每当定时器在另两个事件中的任意一个发生（即收到上层应用的数据和收到 ACK）时，TimeoutInterval 是由最近的 EstimatedRTT 值与 DevRTT 值推算得出的**。

   这种改动提供了一个有限形式的拥塞控制。定时器过期很可能是由网络拥塞引起的，即太多的分组到达源与目的地之间路径上的一台（或多台）路由器的队列中，造成分组丢失或长时间的排队时延。在拥塞的时候，如果源持续重传分组，会使拥塞更加严重。**相反，TCP 使用更优雅的方式，每个发送方的重传都是经过越来越长的时间间隔后进行的**。（在第 5 章学习 CSMA/CD 时，将看到以太网采用了类似的思路。）

   

   快速重传：

   <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/FastRetransmit-fromTextbook.JPG" alt="FastRetransmit-fromTextbook" style="zoom:67%;" />

   

   因为发送方经常连续发送大量的报文段，所以如果一个报文段丢失，就很可能引起许多一个接一个的冗余 ACK。如果 TCP 发送方接收到对相同数据的 3 个冗余 ACK，它就认为跟在这个已被确认过 3 次的报文段之后的报文已经丢失（在课后习题中，我们将考虑为什么发送方等待 3 个重复的 ACK，而不是仅仅等待一个冗余 ACK）。一旦收到 3 个冗余 ACK，TCP 就执行快速重传（fast retransmit）。

   

   是回退 N 步（GBN）还是选择重传（SR）

   TCP 的确认是累积式的，正确接收但失序的报文段是不会被接收方逐个确认的。

   对 TCP 协议提出的一种修改就是所谓的选择确认（selective acknowledgement）[RFC 2018]，它允许 TCP 接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序的报文段。当将该机制与选择重传机制结合起来使用时（即跳过那些已被接收方选择性地确认过的报文段的重传），TCP 看起来很像我们通常的 SR 协议，因此 TCP 的差错恢复机制也许最好被划分成 GBN 协议与 SR 协议的混合体。

   

   流量控制

   TCP 为应用程序提供了流量控制服务（flow-control service）以消除发送方使接收方缓存溢出的可能性。

   TCP 发送方也可能因为 IP 网络的拥塞而被遏制，这种形式的发送方的控制被称为拥塞控制（congestion control）。

   

   假设主机 B 的接收缓存已经存满，以至于 RcvWindow = 0。在将 RcvWindow = 0 通告给主机 A 之后，还要假设主机 B 没有任何数据要发给主机 A。此时，考虑一下会发生什么情况。随着主机 B 上的应用进程将缓存清空，TCP 并不向主机 A 发送带有 RcvWindow 新值的新报文段；事实上，TCP 仅在它有数据或确认要发时才会发送报文段给主机 A。这样，主机 A 不会知道主机 B 的接收缓存已经有新的空间了，即主机 A 被阻塞而不能再发送数据。

   为了解决这个问题，TCP 规约中要求：**当主机 B 的接收窗口为 0 时，主机 A 继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非 0 的 RcvWindow 值**。

   

   UDP 并不提供流量控制。为了理解这个问题，考虑一下从主机 A 上的一个进程向主机 B 上的一个进程发送一系列 UDP 报文段的情形。作为一个典型的 UDP 实现，UDP 将会把这些报文段添加到相应套接字 “前面” 的一个有限大小的缓存中。进程每次从缓存中读取一个完整的报文段。如果进程从缓存中读取报文段的速度不够快，那么缓存将会溢出且报文段将被丢弃。

   

   TCP 连接管理

   客户机中的 TCP 会用以下方式（三次握手（three-way handshake））与服务器中的 TCP 建立一条 TCP 连接：

   <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/Three-wayHandshakeInTheEstablishmentOfTCPConnection.JPG" alt="Three-wayHandshakeInTheEstablishmentOfTCPConnection" style="zoom:67%;" />

   

   - 第一步：客户端向服务器发送 SYN 报文段，该报文段中不包含应用层数据。
   - 第二步：服务器在接收到客户端发来的 SYN 报文段后，**会为该 TCP 连接分配 TCP 缓存和变量**，并向该客户端发送允许连接的报文段。（我们将在第 8 章中看到，在完成三次握手的第三步之前分配这些缓存和变量，使得 TCP 易于受到称为 SYN 洪泛的拒绝服务攻击。）这个允许连接的报文段也不包含应用层数据，但在报文段的首部却包含 3 个重要的信息。该允许连接的报文段有时被称为 SYNACK 报文段（SYNACK segment）。
   - 第三步：在收到 SYNACK 报文段后，**客户机也要给该连接分配缓存和变量**。客户机主机还会向服务器发送另外一个报文段，这个报文段对服务器的允许连接的报文段进行了确认。

   &nbsp;

   四次挥手

   <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/DisconnectATCPConnection.JPG" alt="DisconnectATCPConnection" style="zoom:67%;" />

   

   参与 TCP 连接建立的两个进程中的任何一个都能终止该连接。当连接结束后，主机中使用的 “资源”（即缓存和变量）将被释放。举一个例子，假设客户机打算关闭连接，客户机应用进程发出一个关闭连接命令，这会引起客户机 TCP 向服务器进程发送一个特殊的 TCP 报文段。这个特殊的报文段首部中的一个标志比特，**即 FIN 比特将被设置为 1**。当服务器接收到该报文段后，**就向客户机回送一个确认报文段**。然后，**服务器发送其终止报文段，其 FIN 比特被置 1**。最后，**该客户机对这个服务器的终止报文段进行确认**。此时两台主机上用于该连接的所有资源都被释放了。

   

   TCP 状态（TCP state）

   客户机 TCP 经历的典型的 TCP 状态序列，如下图所示：

   <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/TheStateOfClientDuringTCPConnetingAndDisconnecting.JPG" alt="TheStateOfClientDuringTCPConnetingAndDisconnecting" style="zoom:67%;" />

   

   CLOSED → SYN_SENT → ESTABLISHED → FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED

   - CLOSED → SYN_SENT ：客户机 TCP 开始时处于 CLOSED（关闭）状态，客户机的应用程序发起一个新的 TCP 连接（可通过在第 2 章讲过的 Java 例子中创建一个 Socket 对象来完成）。这引起客户机中的 TCP 向服务器中的 TCP 发送一个 SYN 报文段。客户机在发送过 SYN 报文段后，进入 SYN_SENT（同步发送）状态。
   - SYN_SENT → ESTABLISHED ：当客户机 TCP 处在 SYN_SENT 状态时，等待来自服务器 TCP 对客户机所发报文段进行确认的，并且 SYN 比特被置为 1 的一个报文段。收到这样一个报文段之后，客户机 TCP 进入 ESTABLISHED（已建立）转态。**当处在 ESTABLISHED 状态时，TCP 客户机就能发送和接收包含有效载荷数据（即应用层产生的数据）的 TCP 报文段了**。
   - ESTABLISHED → FIN_WAIT_1 ：假设客户机应用程序决定要关闭该连接（注意，服务器也能选择关闭该连接。）这引起客户机 TCP 发送一个 FIN 比特被置 1 的 TCP 报文段，并进入 FIN_WAIT_1 状态。
   - FIN_WAIT_1 → FIN_WAIT_2 ：当处在 FIN_WAIT_1 状态时，客户机 TCP 等待一个来自服务器的带有确认信息的 TCP 报文段。当它收到该报文段时，客户机 TCP 进入 FIN_WAIT_2 状态。
   - FIN_WAIT_2 → TIME_WAIT ：当处在 FIN_WAIT_2 状态时，客户机等待来自服务器的 FIN 比特被置为 1 的另一个报文段，收到该报文段后，客户机 TCP 对服务器的报文段进行确认，并进入 TIME_WAIT 状态。
   - TIME_WAIT → CLOSED ：TIME_WAIT 状态使得 TCP 客户机重传最终确认报文，以防 ACK 丢失。在 TIME_WAIT 状态中所消耗的时间是与具体实现有关的，一般是 30 秒、一分钟或 2 分钟。**经过等待后，连接就正式关闭，客户机端所有与连接有关的资源（包括端口号）将被释放**。

   &nbsp;

   SYN 洪泛攻击；针对 SYN 洪泛攻击的一种有效防御系统，称为 SYN cookies。

   一种 SYN 洪泛攻击的变种是让怀有恶意的客户机对服务器产生的每个 SYNACK 报文段返回一个合法的 ACK 报文段。这将使得服务器创建全开的 TCP 连接，即使操作系统应用了 SYN cookies，如果数以万计的客户机正被（DDoS 攻击）使用，且每个客户机都有不同的源 IP 地址，则服务器很难区分合法的源和恶意的源。因此，防御这种 “完全握手攻击” 比防御经典的 SYN 洪泛攻击更为困难。

   

   服务器 TCP 经历的典型 TCP 状态序列：

   <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/TheStateOfServerDuringTCPConnetingAndDisconnecting.JPG" alt="TheStateOfServerDuringTCPConnetingAndDisconnecting" style="zoom:67%;" />

   

   CLOSED → LISTEN → SYN_RCVD → ESTABLISHED → CLOSE_WAIT → LAST_ACK → CLOSED

   - CLOSED → LISTEN ：服务器应用程序创建一个监听套接字。
   - LISTEN → SYN_RCVD ：接收 SYN 并发送 SYNACK。
   - SYN_RCVD → ESTABLISHED ：接收 ACK，不发送。
   - ESTABLISHED → CLOSE_WAIT ：接收 FIN，发送 ACK。
   - CLOSE_WAIT → LAST_ACK ：发送 FIN。
   - LAST_ACK → CLOSED ：接收 ACK，不发送。

   &nbsp;

   假如一台主机接收了具有目的端口 80 的一个 TCP SYN 分组，但该主机在端口 80 不接收连接（即它不在端口 80 上运行 Web 服务器），则该主机将向源发送一个特殊重置报文段。该 TCP 报文段将 RST 标志位置 1。因此，当主机发送一个重置报文段时，它告诉源 “我没有那个报文段的套接字，请不要再发送该报文段了。” 当一台主机接收到一个 UDP 分组，它的目的端口与进行中的 UDP 套接字不匹配时，该主机发送一个特殊的 ICMP 数据报，这将在第 4 章中讨论。

   

   我们再次回顾 nmap 端口扫描工具，并更为详细地研究其工作原理。为了考察以太网目标主机上的一个特定的 TCP 端口，如端口 6789 ，nmap 将对那台主机发送一个特殊的 TCP SYN 报文段。这将会出现以下 3 种结果：

   - 源主机从目标主机收到一个 TCP SYNACK 报文段。这意味着在目标主机上一个应用程序使用 TCP 端口 6789 运行，nmap 返回 “打开”。
   - 源主机从目标主机接收到一个 TCP RST 报文段。这意味着该 SYN 报文段到达了目标主机，而目标主机上的 TCP 端口 6789 没有应用程序运行，但攻击者至少知道发向主机端口 6789 的报文段没有被源主机和目标主机之间的任何防火墙阻挡。（将在第 8 章中讨论防火墙）
   - 源主机什么也没收到。这很可能表明该 SYN 报文段被中间的防火漆所阻挡，不可能到达目标主机。

   &nbsp;

   nmap 是一个强大的工具，该工具不仅能 “侦察” 打开的 TCP 端口，而且能 “侦察” 打开的 UDP 端口，还能 “侦察” 防火墙及其配置，甚至能 “侦察” 应用程序和操作系统的版本。其中，大多数任务都能通过操作 TCP 连接管理报文段完成。

   

9. 拥塞控制原理

   分组重传作为网络拥塞的征兆（某个特定运输层报文段的丢失），但是却不能解决网络拥塞问题（因为有太多的源主机想以过高的速率发送数据）。**要解决网络拥塞原因，需要一些机制在面临网络拥塞时遏制发送方**。

   

### TCP 拥塞控制

10. TCP 拥塞控制

    首先分析一下 TCP 发送方是如何限制向其连接发送流量的。在 3.5 节中我们看到，TCP 连接的每一端都由一个接收缓存、一个发送缓存和几个变量（LastByteRead、RcvWindow 等）组成。TCP 拥塞控制机制让连接的每一端都记录一个额外的变量，即拥塞窗口（congestion window）。拥塞窗口表示为 CongWin，它对一个 TCP 发送方能向网络中发送流量的速率进行了限制。特别是在一个发送方中未被确认的数据量不会超过 CongWin 与 RcvWindow 中的最小值，即：

    `LastByteSent - LastByteAcked <= min{CongWin, RcvWindow}` 

    

    因为 TCP 使用确认来触发（或计时）它的拥塞窗口长度的增大，所以 TCP 被称为是自计时（self-clocking）的。

    

    TCP 拥塞控制算法（TCP congestion control algorithm）包括三个主要部分：
    
    1. 加性增（additive-increase）、乘性减（multiplicative-decrease）
    2. 慢启动（slow start）
    3. 对超时事件做出反应

    &nbsp;

    TCP 拥塞控制算法常常被称为加性增、乘性减（Additive-Increase, Multiplicative-Decrease，AIMD）算法。TCP 拥塞控制协议的线性增长阶段被称为避免拥塞（congestion avoidance）。

    

    慢启动（Slow Start，SS）：在慢启动的初始化阶段期间，TCP 发送方以慢速率（因此叫慢启动）发送，但是以指数的速度快速增加其发送速率。

    

    TCP 中**对因超时而检测到的丢包时间做出的反应与因收到 3 个冗余 ACK 而检测到丢包事件做出的反应是不同的**。收到 3 个冗余 ACK 后，TCP 将拥塞窗口减小一半，然后线性地增长。但是超时事件发生时，TCP 发送方进入一个慢启动阶段，即它将拥塞窗口设置为 1 MSS，然后窗口长度以指数速度增长，维持以指数速度增长直到 CongWin 达到超时事件前窗口值的一半为止，此后，CongWin 以线性速率增长，就像收到 3 个冗余 ACK 一样。

    

    阈值（Threshold）；慢启动（SS）；拥塞避免（CA）

    

    TCP 拥塞窗口的变化：

    <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/TheVariationOfTCPCongestionWindowSize.JPG" alt="TheVariationOfTCPCongestionWindowSize" style="zoom:67%;" />

    

    考虑 TCP 拥塞控制为什么在处理发送的超时事件和收到 3 个冗余 ACK 的事件时，要采取不同的动作。特别是，为什么一个 TCP 发送方在发送超时事件后行为保守，将其拥塞窗口减至 1 个 MSS，而在收到 3 个冗余 ACK 后将其减半？有趣的是，**一种早期的 TCP （如 TCP Tahoe），不管发生哪种丢包事件，都无条件地将其拥塞窗口减至 1 MSS，并进入慢启动阶段。较新版本的 TCP（TCP Reno）在收到 3 个冗余 ACK 事件后会取消慢启动阶段。这种在收到 3 个冗余 ACK 后取消慢启动阶段的行为称为快速恢复（fast recovery）**。

    当前大多数的 TCP 实现都是采用 Reno 算法。

    

    公平性

    考虑 K 条 TCP 连接，每条连接都有不同的端到端路径，但是都经过一段传输速率为 R bps 的瓶颈链路（所谓瓶颈链路，是指对于每条连接，沿着该连接路径上的所有其他段链路都不拥塞，而且与该瓶颈链路的传输容量相比，它们有充足的传输容量）。**假设每条连接都在传输一个大文件，而且无 UDP 流量通过该段瓶颈链路，如果每条连接的平均传输速率接近 R/K，即每条连接都得到相同份额的链路带宽，则认为这个拥塞控制机制是公平的**。

    

    虽然在这种情况下我们做了许多理想的假设，但是它仍然能对为什么 TCP 会导致在多个连接之间平等地共享带宽这个问题提供一个直观的感觉。

    在理想化的情形中，我们假设仅有 TCP 连接穿过瓶颈链路，所有的连接具有相同的 RTT 值，且对于一个主机目的地对，只有一条 TCP 连接与之相关联。实际上，这些条件通常是不满足的，客户机/服务器应用因此能获得链路带宽的非常不等同的份额。特别是，已经表明了当多个连接共享一个公共的瓶颈链路时，那些具有较小的 RTT 的连接能够在链路空闲时更快地抢到可用带宽（即较快地打开其拥塞窗口），因而将比那些具有较大 RTT 的连接享有更高的吞吐量。

    

    公平性和 UDP 

    从 TCP 的观点来看，运行在 UDP 之上的多媒体应用是不公平的，因为它们既不与其他连接合作，也不适当地调整其传输速率。因为 TCP 拥塞控制遇到拥塞（丢包）增加的情况将降低其传输速率，而 UDP 源则不必这样做，UDP 源压制 TCP 流量的现象是可能发生的。

    

    公平性与并行 TCP 连接

    但是即使我们能够迫使 UDP 流量行为公平，但公平性问题仍然没有彻底解决。这是因为我们无法阻止基于 TCP 的应用使用多条并行连接。例如，Web 浏览器通常使用多条并行 TCP 连接来传送在一个 Web 页面中的多个对象。（在多数浏览器中都可以配置连接的确切数目。）当一个应用使用多条并行连接时，它占用了一段拥塞链路较大部分的带宽。

    

    尽管本章讨论了可靠数据传输，但是我们应该理解在链路层、网络层、运输层或应用层协议中都可以提供可靠数据传输。该协议栈中这 4 层中的任意一层都可以实现确认、定时器、重传、以及序号，也就是可以向其上层提供可靠数据传输。事实上，在过去的数年中，工程人员以及计算机科学家就是独立地设计并实现了提供可靠数据传输的链路层、网络层、运输层以及应用层协议（虽然这些协议中的许多已经销声匿迹了）。





## 第 4 章 网络层

1. 在本章中我们将**在网络层的转发（forwarding）和选路（routing）功能之间做重要区分**，转发涉及**分组从一条入链路到一台路由器中的出链路的传送**。选路涉及**一个网络中的所有路由器，它们经选路协议共同交互，以决定分组从源到目的地节点所采用的路径**。当你继续本章学习时，心中要记住这个区别，这将有助于你将所涉及的许多主题置于适当的场合中。



2. 我们将约定术语分组交换机是指一台通用分组交换设备，它根据分组首部字段中的值，从输入链路接口到输出链路接口传送分组。**某些分组交换机称为链路层交换机（link-layer switch）**（将在第 5 章研究），它们基于链路层字段中的值作转发决定。**其它分组交换机称为路由器（router）**，它们基于网络层字段中的值作转发决定。



3. 前面说过网络层有两个重要的功能——转发和选路。但我们很快将看到在某些计算机网络中，实际上有第三种重要的网络功能，即连接建立（connection setup）。回想我们学习 TCP 时，数据从发送方流向接收方之前需要三次握手。这使得发送方和接收方建立所需的状态信息（例如，序号和初始流控制窗口长度）。



4. 网络服务模型（network service model）定义网络的一侧边缘到另一侧边缘之间（即发送端系统与接收端系统之间）分组的端到端运输特性。



5. 在迄今为止的所有主要的计算机网络体系结构（因特网、ATM、帧中继等）中，网络层或者提供了主机到主机的无连接服务，或者提供了主机到主机的连接服务，而不同时提供两种。仅在网络层提供连接服务的计算机网络被称为虚电路（Virtual-Circuit，VC）网络；仅在网络层提供无连接服务的计算机网络被称为数据报网络（datagram network）。



6. 在网络层的虚电路建立与运输层的连接建立（例如，第 3 章学过的 TCP 三次握手）之间有一个细微但很重要的区别。
   
   - **运输层的连接建立仅涉及两个端系统**。在运输层连接建立期间，两个端系统独自决定运输层连接的参数（如初始序号与流量控制窗口大小）。虽然这两个端系统已经知道该运输层连接，但网络中的路由器对这些完全不知情。
   
   - **对于一个虚电路网络层，沿两个端系统之间路径上的路由器都要参与虚电路的建立**，且每台路由器都完全知道经过它的所有虚电路。

     &nbsp;
   
7. 数据报网络

   路由器使用分组的目的地址的前缀（prefix）与它的转发表中的表项进行匹配。当有多个匹配时，该路由器使用最长前缀匹配规则（longest prefix matching rule），即在该表中寻找最长的匹配项，并向与最长前缀匹配的链路接口转发该分组。

   

   在数据报网络中，转发表是由选路算法修改的，通常每 1-5 分钟左右更新一次转发表。因为数据报网络中的转发表能够在任何时刻修改，所以从一个端系统到另一个端系统发送一系列分组可能在通过网络时走不同的路径，并可能无序到达。



8. 在输入端口处理能力受限制的路由器中，输入端口也许直接将分组转发给中央选路处理器，然后该处理器执行转发表查找并将分组转发到恰当的输出端口。这就是当一个工作站或服务器用作一台路由器时所采用的方法。这里，选路处理器实际就是该工作站的 CPU，而且输入端口实际上就是一块网络接口卡（如一块以太网网卡）。



9. 网际协议：因特网中的转发和编址

   因特网的网络层有三个主要的组件：

   - IP 协议。（编址规则；数据报格式；分组处理规则）
   - 选路组件，它决定数据报从源到目的地所流经的路径。（路径选择；RIP、OSPF、BGP）
   - 报告数据报中的差错和对某些网络层信息请求进行响应的设施，我们将在 4.4.3 节中学习因特网的网络层差错和信息报告协议，即互联网控制报文协议（ICMP）。（ICMP；差错报告；路由器信令）
   
   &nbsp;

### IPv4 数据报格式

10. IPv4 数据报格式：

    

    <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/theStructureofIPv4Datagram-fromTextbook.JPG" alt="theStructureofIPv4Datagram-fromTextbook" style="zoom:70%;" />

    

    - 版本号：这 4 比特规定了数据报的 IP 协议版本。通过查看版本号，路由器可确定如何解释 IP 数据报的剩余部分。不同的 IP 版本使用不同的数据报格式。
    - 首部长度：因为一个 IPv4 数据报可包含一些可选项（包含在 IPv4 数据报首部中），故需要用这 4 比特来确定 IP 数据报中的数据部分实际从哪开始。**大多数 IP 数据报不包含可选项，所以一般的 IP 数据报都有 20 字节的首部**。
    - 服务类型：服务类型（TOS）比特用来使不同类型的 IP 数据报（例如，一些特别要求低时延、高吞吐量或可靠性的数据报）能相互区别开来。例如将实时数据报（如用于 IP 电话应用）与非实时流量（如 FTP）区分开也许是有用的。提供具体的服务等级是一个由路由器管理员确定的策略问题。我们将在第 7 章详细讨论区分服务主题。
    - 数据报长度：这是 IP 数据报的总长度（首部加上数据），以字节计。因为该字段长为 16 比特，所以 IP 数据报的理论最大长度为 65535 字节。然而，数据报很少有超过 1500 字节的。
    - 标识、标志、片偏移：**这三个字段与所谓的 IP 分片有关**，稍后会详细讨论该主题。**有趣的是，新版本的 IP（即IPv6）不允许在路由器上分片**。
    - 寿命：**寿命（Time-To-Live，TTL）字段用来确保数据报不会永远（如由于长时间的选路循环）在网络中循环。每当数据报经过一台路由器时，该字段的值减 1 。若 TTL 字段减为 0 ，则该数据报必须丢弃**。
    - 协议：该字段仅在一个 IP 数据报到达其最终目的地时才会用到。**该字段值指明了 IP 数据报的数据部分应交给哪个运输层协议**。例如，值为 6 表明数据部分要交给 TCP，而值为 17 表明数据要交给 UDP。注意，**IP 数据报中的协议号所起的作用类似于运输层报文段中端口号字段所起的作用。协议号是将网络层与运输层绑定到一起的黏合剂，而端口号是将运输层和应用层绑定到一起的黏合剂**。我们将在第 5 章看到，链路层帧也有一个特殊字段用于将链路层与网络层绑定到一起。
    - 首部检验和：首部检验和用于帮助路由器检测收到的 IP 数据报中的比特错误。路由器要对每个收到的 IP 数据报计算其首部检验和，并根据数据报首部中携带的检验和与计算得到的检验和是否一致，来检查是否出错。路由器一般会丢弃检测出的错误数据报。注意，**在每台路由器上都必须重新计算检验和并存放在原处，因为 TTL 字段以及选项字段可能会改变**。这里，一个经常问到的问题是，为什么 TCP/IP 在运输层与网络层都执行差错检测？这种重复有几个原因。首先，**在 IP 层只对 IP 首部进行了检验，而 TCP/UDP 检验和是对整个 TCP/UDP 报文段进行的**。其次 **TCP/UDP 与 IP 不一定属于同一个协议栈。原则上，TCP 能运行在一个不同的协议（如 ATM）上，而 IP 能够携带不一定要传递给 TCP/UDP 的数据**。
    - 源和目的 IP 地址。当源主机产生一个数据报时，它在源 IP 字段中插入它的 IP 地址，在目的 IP 地址字段中插入其最终目的地的地址。通常源主机经 DNS 查找来决定目的地址，如第 2 章所述，我们将在 4.4.2 节中详细讨论 IP 编址。
    - 选项：**选项字段允许 IP 首部被扩展**。首部选项意味着很少使用，因此在每个数据报首部不包括选项字段中的信息能够节约开销。然而，选项的存在的确是件复杂是事，因为数据报头长度可变，故不能预先确定数据字段从何处开始。而且，还由于有些数据报要求处理选项，而有些数据报则不要求，故导致一台路由器处理一个 IP 数据报所需的时间变化很大。这些考虑对于高性能路由器和主机上的 IP 处理来说特别重要。由于这样或那样的原因，IP 选项已在 IPv6 中不再采用了，如 4.4.4 节将讨论的那样。
    - 数据（有效载荷）：**我们开看看最后的也是最重要的字段，也是数据报存在的首要理由**！在大多数情况下，**IP 数据报中的数据字段含有要交付给目的地的运输层报文段（TCP或UDP）。然而，数据字段也可承载其他类型的数据，如 ICMP 报文段**（将在 4.4.4 节中讨论）。

    &nbsp;

    我们将在第 5 章看到，**并不是所有的链路层协议都能承载相同长度的网络层分组。有的协议能承载大数据报，而有的协议只能承载小分组**。例如，以太网帧可承载不超过 1500 字节的数据，而某些广域网链路的帧可承载不超过 576 字节的数据。**一个链路层能承载的最大数据量叫做最大传输单元（Maximum Transimission Unit，MTU）**。

    

    想象你是一个互连几条链路的路由器，且每条链路运行具有不同 MTU 的链路协议。假定你从某条链路收到一个 IP 数据报，通过检查转发表决定出链路，但该出链路的 MTU 比该 IP 数据报的长度小。此时，你会感到慌乱，如何将这个过大的 IP 数据报压缩成链路层帧的有效载荷字段呢？**解决该问题的方法是将 IP 数据报中的数据分片成两个或更多个较小的数据报，用单独的链路层帧封装这些较小的 IP 数据报，然后向输出链路上发送这些帧**。这些较小的数据报叫做片（fragment）。

    片在其到达目的地运输层以前需要被重新组装。的确，TCP 与 UDP 都希望从网络层收到完整的未分片的报文。IPv4 的设计者认为在路由器中重新组装数据报会给协议带来相当大的复杂性并且影响路由器的性能。（如果你是一台路由器，你愿意将片重新组成报文作为你必须要做的各种工作的首要工作吗？）为了坚持使网络内核保持简单的原则，**IPv4 的设计者决定将数据报的重新组装工作放到端系统中，而不是放到网络路由器中**。

    

    **虽然 IP 分片在将许多不同的链路层技术结合起来的过程中起到了重要作用，但是分片也是有开销的**。

    - 首先，它使路由器和端系统更为复杂，即必须将数据报分成适当大小的片并且需要重新组装。
    - 其次，分片可能引发致命的 DoS 攻击，即攻击者发送一系列古怪的片。Jolt2 攻击是一个典型的例子，其中攻击者向目标主机发送了小片的流，这些片的偏移量都不是 0 。当目标主机试图根据这些不良分组重建数据报时，可能会崩溃。另一类行为是发送交迭的 IP 分片，即这些分片的偏移量值被设置得不能适当地排列起来。易受攻击的操作系统可能由于不知道如何处理交迭的片而奔溃。

    &nbsp;
    
    如我们将在本节最后看到的那样，**IP 协议的新版本（IPv6）从根本上废止了分片，从而简化了 IP 分组的处理，并使得 IP 不太容易受到攻击**。



### IPv4编址

11. IPv4编址：

    一台路由器有多个接口，每个接口有一条链路。**因为每台主机与路由器都能发送和接收 IP 数据报，所以 IP 要求每台主机和路由器接口都拥有自己的 IP 地址**。因此，**一个 IP 地址在技术上是与一个接口相关联的，而不是与包括该接口的主机或路由器相关联的**。

    

    每个 IP 地址长度为 32 比特（4 字节），因此总共有 2^32 个可能的 IP 地址。由于 2^10 可近似地表示成 10^3，故容易看出约有 40 亿个可能的 IP 地址。这些地址一般按所谓**点分十进制计法（dotted-decimal notation）的方式书写，即地址中的每个字节用十进制形式书写，各字节间以点号隔开**。

    

    在全球因特网中，每台主机和路由器上的每个接口都必须有一个全球唯一的 IP 地址（在 NAT 后面的接口除外，本节结尾将讨论）。然而，这些地址不能以随意的方式自由选择，**一个接口的 IP 地址的组成部分需要由其连接的子网来决定**。

    

    接口地址和子网：

    <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/InterfaceAddressAndSubnet.JPG" alt="InterfaceAddressAndSubnet" style="zoom:67%;" />

    

    上图给出了一个 IP 编址与接口的例子，图中一台路由器（有 3 个接口）用于互联 7 台主机。仔细观察分配给主机和路由器接口的 IP 地址，有几点需要注意。在图的左上侧部分的 3 台主机以及它们连接的路由器接口都有一个形如 223.1.1.XXX 的 IP 地址。这就是说，在它们的 IP 地址中，最左侧的 24 比特是相同的。这 4 个接口也通过一个不包含路由器的网络互联起来。（例如，该网络可以是一个以太 LAN，在此情况下，这些接口将通过一台以太网集线器或一台以太网交换机互联，参见第 5 章。）**用 IP 的术语来说，互连这 3 台主机的接口与路由器的一个接口的网络形成一个子网（subnet）**（在因特网文献中，**子网**也称为 **IP 网络**或**网络**）。IP 编址为这个子网分配一个地址：223.1.1.0/24，其中的 /24 记法有时称为子网掩码（subnet mask），它表明 32 比特中的最左侧 24 比特定义了子网地址。因此子网 223.1.1.0/24 是由 3 台主机接口（223.1.1.1、223.1.1.2、223.1.1.3）和一个路由器接口（223.1.1.4）组成的。任何其它要连接到 223.1.1.0/24 子网的主机都要求其地址形式为 223.1.1.xxx 。在上图中还显示了另外两个子网：223.1.2.0/24 子网与 223.1.3.0/24 子网。

    下图说明了上图中的 3 个子网。子网地址：

    <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/SubnetAddress.JPG" alt="SubnetAddress" style="zoom:67%;" />

    

    

    因特网的地址分配策略被称为无类别域间选路（Classless Interdomain Routing，CIDR，读作 cider）[RFC 4632]。CIDR 将子网寻址的概念一般化了。因为对于子网寻址，32 比特的 IP 地址被划分为两部分，并且也具有点分十进制形式 a.b.c.d/x，其中 x 指示了在地址的第一部分中的比特数。

    

    层次编址与路由聚合：

    <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/HierarchicalAddressingAndRouteAggregation.JPG" alt="HierarchicalAddressingAndRouteAggregation" style="zoom:67%;" />

    

    这是一个 ISP 将 8 个组织连接到因特网的例子，它也较好地说明了仔细分配的 CIDR 化的地址有利于选路的道理。如上图所示，假设该 ISP（我们称之为 Fly-By-Night-ISP）向外界通告，应该发送所有地址的前 20 比特与 200.23.16.0/20 相符的数据报。外界其他部分不需要知道在地址块 200.23.16.0/20 内实际上还存在 8 个其它组织，每个组织有自己的子网。这种使用单个网络前缀通告多个网络的能力通常称为地址聚合（address aggregation），也称为路由聚合（route aggregation）或路由摘要（route summarization）。

    

    当地址按块分给 ISP，然后又由 ISP 分给客户组织时，地址聚合工作极为有效。但是当地址不是按这样的层次方式分配时，会出现什么情况呢？例如，如果 Fly-By-Night-ISP 获取了 ISPs-R-Us，然后让组织 1 通过其辅助的 ISPs-R-Us 与因特网相连，将会发生什么情况呢？通过上图我们可以知道，该辅助的 ISPs-R-Us 拥有地址块 199.31.0.0/16，但很遗憾的是组织 1 的 IP 地址在该地址块之外，这里可以采取什么措施呢？

    

    ISPs-R-Us 到组织 1 有一条更具体的路由：

    <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/AMoreConcreteRouteFromISPs-R-UsToOrganization1.JPG" alt="AMoreConcreteRouteFromISPs-R-UsToOrganization1" style="zoom:67%;" />

    

    组织 1 无疑可以将其所有的路由器和主机重新编号，使得地址在 ISPs-R-Us 的地址块内。但这是一种代价很高的方案，而且组织 1 将来也许还会从 ISPs-R-Us 更换到另一个 ISP。通常采用的做法是，组织 1 保持其 IP 地址在 200.23.18.0/23 内，在这种情况下，如上图所示，Fly-By-Night-ISP 继续通告地址 200.23.16.0/20，并且 ISPs-R-Us 也继续通告地址块 199.31.0.0/16，然而，ISPs-R-Us 现在还要通告组织 1 的地址块 200.23.18.0/23。当较大因特网上的其它路由器看见地址块 200.23.16.0/20（来自 Fly-By-Night-ISP）和 200.23.18.0/23（来自 ISPs-R-Us），并且想选路以到达地址块 200.23.18.0/23 内的一个地址时，它们将使用最长前缀匹配（参见 4.2.2 节），并朝着 ISPs-R-Us 选路，因为它通告了与目的地址相匹配的最长（最具体）的地址前缀。

    

    形式为 a.b.c.d/x 的地址的 x 最高比特构成了 IP 地址的网络部分，并且经常被称为该地址的前缀（prefix）（或网络前缀）。一个组织通常被分配一块连续的地址，即具有相同前缀的一段地址。在这种情况下，该组织内部的设备的 IP 地址将共享共同的前缀。当我们在 4.6 节中论及**因特网的 BGP 选路协议时，将看到组织外部的路由器仅考虑前面的前缀比特 x**。这就是说，当组织外部的路由器转发一个数据报，且该数据报的目的地址在组织内部时，仅需要考虑该地址前面的 x 比特。这大大减少了这些路由器中的转发表长度，因为形式为 a.b.c.d/x 单一项足以将数据报转发到组织内的任何目的地。

    一个地址的剩余 32-x 比特可认为是用于区分组织内部设备，其中所有设备具有相同的网络前缀。当组织内部的路由器转发分组时，才会考虑这些比特。这些较低阶比特可能具有一个附加的子网结构。例如，假设某 CIDR 化的地址 a.b.c.d/21 的前 21 比特定义了组织的网络前缀，这对组织中的所有主机的 IP 地址来说是共同的，则其余的 11 比特标识了组织内的主机。该组织的内部结构可以采用这样的方式，使用这 11 个最右边的比特在该组织中划分子网，就像前面所讨论的那样。例如，a.b.c.d/24 可能表示该组织内的特定子网。

    在采用 CIDR 之前，IP 地址的网络部分被限制长度为 8、16 或 24 比特，因为具有 8、16 或 24 比特子网地址的网络分别被称为 A、B 和 C 类网络，所以这种编址方案被称为分类编址（classful addressing）。要求一个 IP 地址的网络部分正好为 1、2 或 3 字节，已经在支持迅速增加的具有小、中规模子网的组织数量方面出现了问题。一个 C 类（/24）子网仅能容纳多达 2^8^ - 2 = 254 台主机（其中的两个地址预留用于特殊用途），这对于许多组织来说太小了。然而，一个 B 类（/16）子网可支持多达 65534 台主机，又太大了。

    

    IP 广播地址：255.255.255.255 。当一台主机发出一个目的地址为 255.255.255.255 的数据报时，该报文会被交付给同一个子网中的所有主机。路由器也会有选择地向邻近的子网转发该报文（虽然它们通常不这样做）。

    

    获取一块地址：

    IP 地址由因特网名字与号码分配机构（Internet Corporation for Assigned Names and Numbers，ICANN）[ICANN 2007] 管理，它基于 RFC 2050 中提出的规则。非盈利的 ICANN 组织 [NTIA 1998] 的作用不仅是分配 IP 地址，还管理 DNS 根服务器。它还有一项有争议的工作，即分配域名与解决域名纷争。ICANN 向地区性因特网注册机构（如 ARIN、RIPE、APNIC 和 LACNIC）分配地址，这些机构一起形成了 ICANN 地址支持组织 [ASO-ICANN 2007] ，处理本地域内的地址分配/管理。




#### DHCP

12. 获取主机地址：动态主机配置协议（DHCP）

    一个组织一旦获取了一块地址，它就可为该组织内的主机与路由器接口分配独立的 IP 地址。对于路由器接口地址，系统管理员手工配置路由器中的 IP 地址（在远程通常通过网络管理工具配置）。也可以手动配置主机，但这项任务目前更常使用**动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）**来完成。

    利用 DHCP 主机可以自动获取 IP 地址，网络管理员可以配置 DHCP，以便某给定主机每次与该网络连接时能得到一个相同的 IP 地址，或者被分配一个临时的 IP 地址（temporary IP address），主机每次与该网络连接时该地址都可能是不同的。除了为主机分配 IP 地址外，DHCP 还允许一台主机获取其它信息，如它的**子网掩码、它的第一跳路由器地址（常称为默认网关）与它的本地 DNS 服务器的地址**。

    

    DHCP 是一个客户机/服务器协议。客户机通常是新到达的主机，它要获得网络配置信息，包括用于其自身的 IP 地址。在最简单的情形下，每个子网拥有拥有一台 DHCP 服务器。如果某子网没有 DHCP 服务器，则需要一个 DHCP 中继代理（通常是一台路由器），这个 DHCP 中继代理要知道用于该网络的一台 DHCP 服务器地址。

    

    DHCP 客户 - 服务器交互：

    <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/CommunicationBetweenClientAndDHCPServer.JPG" alt="CommunicationBetweenClientAndDHCPServer" style="zoom:67%;" />

    

    DHCP 协议是一个 4 个步骤的过程（yiaddr，“你的因特网地址” 之意，表示分配给该新到达客户机的地址）：

    - DHCP 服务器发现：新到达的主机的首要任务是发现一个要与其交互的 DHCP 服务器。这可通过 DHCP 发现报文（DHCP discovery message）来完成，**客户机在 UDP 分组中向端口 67 发送该发现数据报**。其中数据报的目的地 IP 地址使用广播地址 255.255.255.255，“本主机” 源地址使用 0.0.0.0。DHCP 客户机将该 IP 数据报传递给链路层，**链路层再将该帧广播到所有与该子网连接的子网**（我们将在 5.4 节学习链路层广播的细节）。
    - DHCP 服务器提供。DHCP 服务器收到一个 DHCP 发现报文时，用一个 DHCP 提供报文（DHCP offer message）对客户机做出响应，数据报的目的地 IP 地址仍然使用 IP 广播地址 255.255.255.255 。因为在子网中可能有几个 DHCP 服务器，所以该客户机可以选择其中的一个 DHCP 服务器。每个 DHCP 服务器提供报文中含有收到的发现报文的事务 ID、向客户机推荐的 IP 地址、网络掩码以及 IP 地址租用期（IP address lease time，即 IP 地址有效的时间量）。服务器租用期通常设置为几小时或几天。
    - DHCP 请求。新到达的客户机从一个或多个服务器中选择一个，并用一个 DHCP 请求报文（DHCP request message）对选中的服务器进行响应，回显配置参数。
    - DHCP ACK。服务器用 DHCP ACK 报文（DHCP ACK message）对 DHCP 请求报文进行响应，证实所要求的参数。

    &nbsp;
    
    一旦客户机收到 DHCP ACK 后交互便完成了，该客户机就能够在租用期内使用 DHCP 分配给它的 IP 地址。为了使客户机能再超出租用期后继续使用该地址，DHCP 还提供了一种允许客户机更新它对一个 IP 地址的租用期的机制。



#### NAT

13. 网络地址转换（Network Address Translation，NAT）

    进行了有关因特网地址和 IPv4 数据报格式讨论后，我们现在可清楚地认识到每个 IP 使能的设备都需要一个 IP 地址。网络地址转换（NAT）是一种应用越来越广泛的简单地址分配方法。

    

    <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/NetworkAddressTranslation.JPG" alt="NetworkAddressTranslation" style="zoom:67%;" />

    

    上图显示了一台 NAT 使能路由器运作的情况，位于家中的 NAT 使能路由器有一个接口，该接口是图中右侧所示家庭网络的一部分。家庭网络内的编址就像我们在上面看到的完全一样，其中的所有 4 个接口都有相同的网络地址 10.0.0.0/24 。**地址空间 10.0.0.0/8 是在 RFC 1918 中保留的 3 部分 IP 地址空间之一，这些地址用于专用网络或具有专用地址地域（realm）。具有专用地址的地域是指其地址仅对该网络中的设备有意义的网络**。

    为理解其重要性，考虑有数以百万计家庭网络这样的事实，许多网络使用相同的地址空间 10.0.0.0/24，一个给定家庭网络中的设备能够使用 10.0.0.0/24 编址彼此发送分组，然而，转发到家庭网络之外进入更大的全球因特网的分组显然不能使用这些地址（要么作为源地址，要么作为目的地址），因为有数以百万计的网络使用这块地址，这就是说 10.0.0.0/24 地址仅在给定的网络中才有意义。但是如果专用地址仅在给定的网络中才有意义的话，当向因特网发送分组或从因特网接收分组时，如何处理地址？这里地址必须是唯一的。答案在于理解 NAT。

    NAT 使能路由器对于外界来说甚至不像一台路由器。相反，**NAT 路由器对外界的行为就如同一个具有单一 IP 地址的单一设备**。在上图中，**所有离开家庭路由器通向更大的因特网的报文都拥有同一个源 IP 地址 138.76.29.7 ，且所有进入家庭的报文都拥有同一个目的 IP 地址 138.76.29.7**。从本质上讲，**NAT 使能路由器对外界隐藏了家庭网络的细节**。（另外，你也许想知道家庭网络计算机是从哪得到其地址，路由器又是从哪里得到其单个 IP 地址的。通常答案是相同的，即 DHCP！路由器从 ISP 的 DHCP 服务器得到其地址，它再运行一个 DHCP 服务器，在 NAT-DHCP 路由器控制的家庭网络的地址空间中为计算机提供地址。）

    如果来自广域网到达 NAT 路由器的所有数据报都有相同的目的 IP 地址，那么该路由器是怎么知道它应将一个给定数据报转发给哪个内部主机的呢？技巧就是使用 NAT 路由器上的一张 NAT 转换表（NAT translation table），并且在表项中包含了端口号和 IP 地址。

    

    端口号字段为 16 比特长，NAT 协议可支持 60000 多个并行使用路由器广域网一侧 IP 地址的连接。

    

    NAT 会妨碍 P2P 应用程序，包括 P2P 文件共享应用和 P2P 的 IP 之上话音应用。

    NAT 穿越（NAT traversal）

    NAT 穿越正越来越多地由通用即插即用（UPnP）提供，UPnP 是一种允许主机发现并配置邻近 NAT 的协议。UPnP 要求主机和 NAT 是 UPnP 兼容的。使用 UPnP ，在一台主机上运行的应用程序能够为某些请求的公共端口号请求一个 NAT 映射，该映射位于（专用 IP 地址，专用端口号）和（公共 IP 地址，公共端口号）之间。如果 NAT 接受该请求并生成该映射，则来自外部的节点能够发起到（公共 IP 地址，公共端口号）的 TCP 连接。此外，UPnP 让该应用程序知道（公共 IP 地址，公共端口号），因此该应用程序能够向外部世界通告它。



### ICMP

14. ICMP：互联网控制报文协议

    因特网的网络层有 3 个主要组件：IP 协议、因特网选路协议（包括 RIP、OSPF 和 BGP）和 ICMP。

    ICMP 由 RFC 792 定义，它用于主机和路由器彼此交互网络层信息。ICMP 最典型的用途是差错报告。例如，当运行一次 Telnet、FTP 或 HTTP 会话时，你也许会遇到一些诸如 “目的网络不可达” 之类的错误报文。这种报文就是在 ICMP 中产生的。在某个位置，IP 路由器不能找到一条路径，以通往 Telnet、FTP 或 HTTP 应用所指定的主机。该路由器就会创建和发出一个类型 3 的 ICMP 报文到你的主机来指示该错误。

    **ICMP 通过被认为是 IP 的一部分，但从体系结构上讲它是位于 IP 之上，因为 ICMP 报文是承载在 IP 分组中的**。这就是说，ICMP 报文是作为 IP 有效载荷承载的，就像 TCP 与 UDP 报文段作为 IP 有效载荷被承载那样。类似地，当一台主机收到一个指明上层协议为 ICMP 的 IP 数据报时，它分解该数据报的内容给 ICMP，就像分解一个数据报的内容给 TCP 或 UDP 一样。

    ICMP 报文有一个类型字段和一个编码字段，并且包含引起该 ICMP 报文首次生成的 IP 数据报（以便发送方能确定引发该差错的数据报）的首部和前 8 字节内容。注意， ICMP 报文并不是仅用于通知差错情况。

    ICMP 报文类型：

    <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/TypesOfICMPSegment.JPG" alt="TypesOfICMPSegment" style="zoom:67%;" />

    

    众所周知的 ping 程序发送一个 ICMP 类型 8 编码 0 的报文到指定主机。看到该回显（echo）请求的目的主机发回一个类型 0 编码 0 的 ICMP 回显回答。

    在第 1 章中我们介绍了 Traceroute 程序，该程序允许用户跟踪从一台主机到世界上任意一台其他主机之间的路由。有趣的是，Traceroute 是用 ICMP 报文来实现的。为了判断源和目的地之间所有路由器的名字和地址，源主机中的 Traceroute 向目的主机发送一系列普通的 IP 数据报。这些数据报中的每个都携带了一个具有不可达 UDP 端口号的 UDP 报文段。第一个数据报的 TTL 为 1，第二个数据报的 TTL 为 2，第三个数据报的 TTL 为 3，以此类推。该源主机也为每个数据报启动定时器，当第 n 个数据报到达第 n 台路由器时，第 n 台路由器观察到这个数据报的 TTL 正好终止。根据 IP 协议规则，则路由器将丢弃该数据报并发送一个 ICMP 告警报文给源主机（类型 11 编码 0）。该告警报文包含有路由器的名字与 IP 地址。当该 ICMP 报文到达源主机时，源主机从定时器得到往返时延，从 ICMP 报文中得到第 n 台路由器的名字与 IP 地址。
    
    注意，Traceroute 客户机程序必须能够指示操作系统产生具有特定 TTL 值的 UDP 数据报，也必须能够由它的操作系统通知 ICMP 报文到达的时间。
    
    
    
    针对恶意分组攻击的两种流行防御措施是防火墙和入侵检测系统（IDS）。



### IPv6

15. IPv6 数据报的格式如下图所示：

    <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/theStructureofIPv6Datagram-fromTextbook.JPG" alt="theStructureofIPv6Datagram-fromTextbook" style="zoom:75%;" />

    

    IPv6 中引入的最重要的变化表现在其数据报格式中：

    - 扩大的地址容量：IPv6 将 IP 地址长度从 32 比特增加到 128 比特，这就确保全世界不会用尽 IP 地址。
    - 简单高效的 40 字节首部：许多 IPv4 字段已被舍弃或作为选项，因而形成的 40 字节定长首部允许更快地处理 IP 数据报。
    - 流标签与优先级：IPv6 有一个难以捉摸的流（flow）定义。RFC 1752 与 RFC 2460 中描述道，该字段可用于 “给属于特殊流的分组加上标签，这些特殊流是发送方要求进行特殊处理的流，如一种非默认服务质量或需要实时服务的流” 。

    &nbsp;

    IPv6 数据报的格式中：

    - 下一个首部：该字段标识该数据报中的内容（数据字段）需要交付给哪个协议（如 TCP 或 UDP），该字段使用与 IPv4 首部中协议字段相同的值。
    - 数据：这是 IPv6 数据报的有效载荷部分，当数据报到达目的地时，该有效载荷就从 IP 数据报中移出，并被交给下一个首部字段中指定的协议处理。

    &nbsp;

    注意到 IPv4 数据报中出现的几个字段在 IPv6 数据报中已不复存在：

    - 分片/重新组装
    - 首部检验和
    - 选项

    &nbsp;

    从 IPv4 向 IPv6 迁移：

    - 双栈（dual-stack），即 IPv6 节点也具有完整的 IPv4 实现。这样的节点在 RFC 4213 中被称为 IPv6/IPv4 节点，它有发送和接收 IPv4 与 IPv6 两种数据报的能力。
    - 建隧道（tunneling）

    &nbsp;

    我们能从 IPv6 经验中学到的重要一点就是，要改变网络层协议是极其困难的。在网络层中引入新的协议就如同替换一幢房子的基石（在不能将整幢房子拆掉或临时重新安置房屋住户的情况下是很难完成的。）另一方面，因特网却已见证了应用层中新协议的快速部署，典型的例子是 Web、即时讯息、P2P文件共享。引入新的应用层协议就像给一幢房子重新刷一层漆（这是相对容易做的事），如果你选择了一个好看的颜色，邻居将会照搬你的选择。

16. IP 安全性概述

    IPv4 是在因特网主要用于相互信任的网络研究人员之间的时代（20 世纪 70 年代）设计的，那时，创建一个能够集成众多链路层技术的计算机网络就已经面临巨大的挑战了，更别提顾及安全性了。但是，在安全性越来越重要的今天，因特网研究人员开始设计提供各种安全性服务的新型网络层协议，其中一个就是 IPsec，它是流行的安全网络层协议之一，也是虚拟专用网（VPN）中广泛采用的协议。在本小节中我们对 IPsec 服务进行简要的、高层次的概述，在第 8 章中再详细的讨论 IPsec 及其密码学基础。

    

    在 IPsec 的运输模式下，两台主机首先在它们之间创建一个 IPsec 会话。（因此 IPsec 是面向连接的）使用适当的会话，这两台主机之间发送的所有 TCP 和 UDP 报文段都享受 IPsec 提供的安全性服务。由 IPsec 会话提供的服务包括：

    - 密码技术协约
    - IP 数据报有效载荷的加密
    - 数据完整性
    - 初始鉴别

    &nbsp;

### 选路算法

17. 选路算法

    一台主机通常直接与一台路由器相连接，该路由器即为该主机的默认路由器（default router），又称为该主机第一跳路由器（first-hop router）。每当某主机发送一个分组时，该分组都被传送给它的默认路由器，我们将源主机的默认路由器称为源路由器（source router），把目的主机的默认路由器称为目的路由器（destination router）。**为一个分组从源主机到目的主机选路的问题显然可归结为从源路由器到目的路由器的选路问题**。

    

    从广义上来说，我们对选路算法分类的一种方法就是根据该算法是全局性还是分布式来区分的。

    - 全局选路算法（global routing algorithm）：用完整的、全局性的网络知识来计算从源到目的之间的最低费用路径。也就是说，该算法以所有节点之间的连通性及所有链路的费用为输入。这就要求该算法在真正开始计算之前，以某种方式获得这些信息。实际上具有全局状态信息的算法常被称作链路状态（Link-State，LS）算法，因为该算法必须知道网络中每条链路的费用。
    - 分布式选路算法（decentralized routing algorithm）以迭代的、分布式的方式计算出最低费用路径。没有节点拥有关于所有网络链路费用的完整信息，而每个节点仅有与其直接相连链路的费用知识即可开始工作。然后，通过迭代计算过程并与相邻节点（即与该节点相连链路的另一端的节点）交换信息，一个节点逐渐计算出到达某目的节点或一组目的节点的最低费用路径。我们将学习一个称为距离向量（Distance-Vector，DV）算法的分布式选路算法。它之所以叫做 DV 算法，是因为每个节点维护到网络中的所有其它节点的费用（距离）估计的向量。

    &nbsp;

    选路算法的第二种广义分类方法是根据算法是静态的还是动态的来分类。可分为静态选路算法（static routing algorithm）和动态选路算法（dynamic routing algorithm）。

    

    选路算法的第三种分类方法是根据它是负载敏感的还是负载迟钝的进行划分。可分为负载敏感算法（load-sensitive algorithm）和负载迟钝算法（load-insensitive algorithm）。

    当今的因特网选路算法（如 RIP、OSPF 和 BGP） 都是负载迟钝的（load-insensitive），因为某条链路的费用不明显地反映当前（或最近）拥塞水平。

    

    链路状态选路算法

    我们下面给出的链路状态选路算法叫做 Dijkstra 算法，该算法以其发明者命名。一个密切相关的算法是 Prim 算法。Dijkstra 算法计算从某节点（源节点，我们称之为 u）到网络中所有其他节点的最低费用路径。Dijkstra 算法是迭代算法，其性质是经过算法的第 k 次迭代后，可知道到 k 个目的节点的最低费用路径。
    
    
    
    源节点 u 的链路状态（LS）算法
    
    ```
    Initialization:
      N' = {u}
      for all nodes v
        if v is a neighbor of u
          then D(v) = c(u,v)
        else D(v) = ∞
        
    Loop
      find w not in N' such that D(w) is a minimum
      add w to N'
      update D(v) for each neighbor v of w and not in N':
        D(v) = min( D(v), D(w) + c(w,v) )
      /* new cost to v is either old cost to v or know least path cost to w plus cost from w to v */
    until N' = N
    ```
    
    
    
    当 LS 算法结束时，对于每个节点，我们都得到从源节点沿着它的最低费用路径的前一节点。对于每个前一节点，我们又有它的前一节点，按照此方式我们可以构建从源节点到所有目的节点的完整路径。
    
    
    
    振荡问题
    
    
    
    距离向量选路算法
    
    距离向量（Distance-Vector，DV）算法是一种迭代的、异步的和分布式的算法。
    
    - 说它是分布式的，是因为每个节点都要从一个或多个直接相连的邻居接收某些信息，执行计算，然后将计算结果发回给邻居。
    - 说它是分布式的，是因为此过程一直要持续到邻居之间没有更多的信息要交换为止。（有趣的是，此算法是自我终结的，即没有计算应该停止的信号，它就停止了。）
    - 说该算法是异步的，是因为它不要求所有节点相互之间步伐一致地操作。
    
    &nbsp;
    
    距离向量选路算法（DV 算法）
    
    对每个节点 x ：
    
    ```
    Intitialization:
      for all destination y in N:
        D_x(y) = c(x,y)  /* if y is not a neighbor then c(x,y) = ∞ */
      for each neighbor w
        D_w(y) = ∞ for all destination y in N
      for each neighbor w
        send distance vector D_x = [D_x(y): y in N] to w
        
    loop
      wait (until I see a link cost change to some neighbor w or
            until I receive a distance vector from some neighbor w )
    
      for each y in N:
        D_x(y) = min_v{c(x,v) + D_v(y)}
        
      if D_x(y) changed for any destination y
        send distance vector D_x = [D_x(y): y in N] to all neighbors
      
    forever
    ```
    
    
    
    选路环路（routing loop）问题
    
    
    
    LS 与 DV 选路算法的比较（这两个算法没有一个算法对另一个算法而言是赢家，事实上它们都在因特网中得到了应用。）
    
    
    
    层次选路
    
    自治系统（Autonomous System，AS）。每个 AS 由一组通常在相同管理控制下的路由器组成（例如，由相同的 ISP 运营或属于相同的公司网络）。
    
    在自治系统内运行的选路算法叫做自治系统内部选路协议（intra-autonomous system routing protocol）。将 AS 彼此互连是必需的，因此在一个 AS 内的一台或多台路由器将有另外的任务，来负责向本 AS 之外的目的地转发分组。这些路由器被称为**网关路由器（gateway router）**。
    
    
    
    **从相邻 AS 获取可达性信息**以及**向该 AS 中的所有路由器传播可达性信息**这两项任务由**自治系统间选路协议（inter-autonomous system routing protocol）**负责。因为自治系统间选路协议涉及两个 AS 之间的通信，**所以这两个通信的 AS 必须运行相同的自治系统间选路协议**。事实上，因特网中的所有 AS 都运行相同的自治系统间选路协议（BGP4），我们将在下一节讨论。
    
    每台路由器接收来自一个 AS 内部选路协议和一个 AS 间选路协议的信息，并使用来自这两个协议的信息配置其转发表。
    
    
    
    在下一节中，我们将学习当今因特网中使用的两种 AS 内部选路协议（RIP 与 OSPF）和一种 AS 间选路协议（BGP）。对这些案例的研究将从不同侧面帮助我们学习层次选路内容。



### 因特网中的选路

18. 因特网中的选路：

    因特网的选路协议包含了许多我们在本章前面学过的原理，4.5.1 节和 4.5.2 节中学过的链路状态算法与距离向量算法以及 4.5.3 节中讨论的自治系统（AS）概念，都在当今的因特网选路中发挥了重要是作用。

    

    因特网中自治系统（AS）内部选路：AS 内部选路协议用于确定在一个自治系统（AS）内执行选路的方式。AS 内部选路协议又称为内部网关协议（interior gateway protocol）。历史上有两个选路协议曾被广泛用于因特网上自治系统内的选路：**选路信息协议（Routing Information Protocol，RIP）**与**开放最短路径优先（Open Shortest Path First，OSPF）**。

    

    RIP 是一种距离向量协议，其运行方式很像我们在 4.5.2 节中学习的理想化 DV 协议。在 RFC 1058 中定义的 RIP 版本使用跳数作为其费用测度，即每条链路的费用为 1 。RIP 使用术语跳，跳是沿着从源路由器到目的子网（包括目的子网）的最短路径所经过的子网数量。

    

    OSPF 和它的关系密切的兄弟 IS-IS 通常被设置在较顶层的 ISP 中，而 RIP 却被设置在较低层 ISP 和企业网中。OSPF 中的开放是指选路协议规约是公众可用的（与之相反的是，如 Cisco 的 EIGRP 协议就不是开放的）。

    

    OSPF 被认为是 RIP 的后继者，并且有许多先进特性。然而，OSPF 的核心就是一个使用洪泛链路状态信息的链路状态协议和一个 Dijkstra 最低费用路径算法。

    

    自治系统间的选路：BGP

    跨越多个 AS 的源和目的对之间是如何确定路径的？由 RFC 4271 定义的**边界网关协议（Border Gateway Protocol，BGP）版本 4 是当今因特网中域间选路协议事实上的标准**。它通常被称为 **BGP4** 或简称为 **BGP**。



### 广播和多播选路

19. 广播和多播选路

    在广播选路（broadcast routing）中，网络层提供了从**一个源节点**到网络中的**所有其它节点**交付分组的服务。

    多播选路（multicast routing）使单个源节点能够向**其它网络节点的一个子集**发送分组的拷贝。

    

    无控制洪泛：广播风暴

    受控洪泛：

    - 序号控制洪泛（sequence-number-controlled flooding）
    - 反向路径转发（Reverse Path Forwarding，RPF），有时也称为反向路径广播（RPB）。

    

    生成树广播：

    虽然序号控制洪泛和 RPF 避免了广播风暴，但它们不能完全避免冗余广播分组的传输。

    生成树（spanning tree）：图 G = (N, E) 的一颗生成树是一个图 G' = (N, E') ，满足 E' 是 E 的子集，G' 是连通的，G' 不包含圈，并且 G' 包括了 G 中的所有初始节点。

    

    在 OSPF [RFC 2328，Perlman 1999] 选路算法和中间系统到中间系统（IS-IS）选路算法 [RFC 1142，Perlman 1999] 中，使用了一种形式的序号控制洪泛来广播链路状态通告（LSA）。

    

    多播

    在因特网体系结构中，多播数据报使用间接地址（address indirection）来编址。这就是说用一个标识来表示一组接收方，寻址到该组的分组的拷贝被交付给所有与该组相关的多播接收方。在因特网中，表示一组接收方的单一标识就是一个 D 类多播地址。与一个 D 类地址相关联的接收方组称为一个多播组（multicast group）。

    多播组：寻址到该组的数据报被交付给多播组的所有成员。

    <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/MulticastGroup.JPG" alt="MulticastGroup" style="zoom:67%;" />

    

    上图中 4 台主机与多播组地址 226.17.30.197 相关联，而且它们将接收所有寻址到该多播地址的数据报。我们仍然必须应对的困难在于这样一个事实，每台主机有一个唯一的 IP 单播地址，该单播地址完全独立于它所参与的多播组的地址。

    

    因特网组管理协议（IGMP）

    IGMP 为一台主机提供了手段，可让它通知与其相连的路由器，在本主机上运行的一个应用程序想加入一个特定的多播组。由于 IGMP 的交互范围被局限于主机与其相连的路由器间，因此显然需要其他协议来协调遍及因特网内的多播路由器（包括相连的路由器），以便多播数据报能路由到其最终目的地。后一个功能是由网络层多播选路算法完成的。**因此因特网中的网络层多播是由两个互补的组件组成的：IGMP 与多播选路协议**。

    

    至今为止，IP 多播还没有得到大规模的应用。与此同时，应用层多播使用应用层（而不是网络层）多播协议在对等方之间提供了内容的多播分发。未来的多播服务主要是在网络层（网络核心中）实现还是在应用层（在网络边缘）实现呢？虽然当前经对等方到对等方的方法分发内容的狂热暗示着至少在近期天平向应用层多播倾斜，但是 IP 多播将继续取得进展，总有一天前进的步伐会放慢并稳定下来。





## 第 5 章 链路层和局域网

1. 在链路层的讨论中，我们将发现有两种截然不同类型的链路层信道。**第一种类型由广播信道组成**，这种信道常用在局域网（Local Area Network，LAN）、无线 LAN、卫星网和混合光纤电缆（Hybrid Fiber-coaxial Cable，HFC）接入网中。**对于广播信道，许多主机被连接到相同的通信信道，需要所谓的媒体访问协议来协调传输和避免 “碰撞”**。第二种类型的链路层信道是**点对点通信链路**，例如两台路由器之间的通信链路或一个住宅的拨号调制解调器与一台 ISP 路由器之间的通信链路。**协调对点对点链路的访问不是一件困难的事，但是仍然有一些重要的问题，如成帧、可靠数据传输、差错检测和流量控制**。

   我们也将在这一章中探讨几种重要的链路层技术。我们将深入研究以太网，这是目前最流行的有线 LAN 技术。我们还将学习点对点协议（PPP），这是拨号住宅主机选用的协议。

   尽管 WiFi 及其更一般的无线 LAN 无疑属于链路层的主题，但本章不涉及它们。这不是因为 WiFi 是一个不重要的主题，恰恰相反，WiFi 革命正在极大地改变着人们接入和使用因特网的方式，第 6 章将深入地研究 WiFi。

   

2. 链路层协议交换的数据单元称为帧（frame），每个链路层通常封装了一个网络层的数据报。当发送和接收帧时，链路层协议所采取的动作包括差错检测、重传、流量控制和随机接入。链路层协议的例子包括以太网、802.11 无线 LAN（也称为 WiFi）、令牌环和 PPP；在很多场合下，ATM 也被认为是链路层协议。



3. 链路层的一个重要特点是数据报在路径的不同链路上**可能由不同链路层协议所承载**。例如，数据报在第一段链路上可能由以太网承载，在最后一段链路上可能由 PPP 承载，而在中间的链路上由链路层 WAN 协议承载。



4. 链路层协议能够提供的可能服务包括：

   - 成帧（framing）：一个帧由一个数据字段和若干首部字段组成，其中网络层数据报就插在数据字段中。（一个帧也可能包括尾部字段，然而我们把首部字段和尾部字段合称为首部字段。）
   - 链路接入（link access）：媒体访问控制（Medium Access Control，MAC）协议规定了帧在链路上传输的规则。
   - 可靠交付（reliable delivery）：链路层的可靠交付服务通常是通过确认和重传取得的。链路层可靠交付服务通常用于易产生高差错率的链路，例如无线链路，其目的是本地（也就是在差错发生的链路上）纠正一个差错，而不是通过运输层或应用层协议迫使进行端到端的数据重传。然而，对于低比特差错的链路，包括光纤、同轴电缆和许多双绞铜线链路，链路层的可靠交付可能会被认为是一种不必要的开销。因此，**许多有线的链路层协议不提供可靠交付服务**。
   - 流量控制（flow control）：链路每一端的节点都具有有限容量的帧缓存能力。
   - 差错检测（error detection）：在因特网中运输层和网络层也提供了有限形式的差错检测（即互联网检验和），但链路层的差错检测通常更复杂，并且用硬件实现。
   - 差错纠正（error correcton）
   - 半双工和全双工（half-duplex an full-duplex）

   &nbsp;

5. 链路层的主体部分是在网络适配器（network adapter）中实现的，网络适配器也称为网络接口卡（Network Interface Card，NIC）。



6. 差错检测和纠错技术

   比特级差错检测和纠错（bit-level error detection and correction）

   

   在传输数据中检测差错的 3 种技术：奇偶校验（它用来描述差错检测和纠错隐含的基本思想）、检验和方法（它通常更多地应用于运输层）和循环冗余检测（它通常更多地应用在适配器中的链路层）。

   

   奇偶校验

   奇偶校验位；偶校验方案；奇校验方案；

   二维奇偶校验

   接收方检测和纠正差错的能力被称为前向纠错（Forward Error Correction，FEC）。

   

   检验和方法

   

   循环冗余检测

   现今的计算机网络中广泛应用的差错检测技术是基于循环冗余检测（Cyclic Redundancy Check，CRC）编码。CRC 编码也称为多项式编码（polynomial code），因为该编码能够将要发送的比特串看作是系数为 0 和 1 的一个多项式，对比特串的操作被解释为多项式算术。



7. 多路访问协议

   点对点链路（point-to-point link）

   广播链路（broadcast link）

   

   如何协调多个发送和接收节点对一个共享广播信道的访问，这就是多路访问问题（multiple access problem）。

   

   多路访问协议（multiple access protocol）：节点通过这些协议来规范它们在共享的广播信道上的传输行为。

   

   我们能够将任何多路访问协议划分为 3 种类型之一：信道划分协议（channel partitioning protocol）、随机接入协议（random access protocol）和轮流协议（taking-turns protocol）。

   

   信道划分协议

   - 时分多路复用（TDM）
   - 频分多路复用（FDM）
   - 码分多址（Code Division Mutiple Access，CDMA）

   &nbsp;

   随机接入协议

   时隙 ALOHA协议

   纯 ALOHA

   

   载波侦听多路访问（CSMA）

   - 载波侦听（carrier sensing）（说话之前先听）
   - 碰撞检测（collison detection）（如果与他人同时开始说话，则停止说话）。

   &nbsp;

   这两个规则包含在载波侦听多路访问（Carrier Sense Muliple Access，CSMA）和具有碰撞检测的 CSMA（CSMA with Collision Detection，CSMA/CD）协议族中。

   

   轮流协议
   
   - 轮询协议（polling protocol）
   - 令牌传递协议（token-passing protocol）
   
   &nbsp;



8. 链路层编址

   地址解析协议（ARP），该协议提供了将 IP 地址转换为链路层地址的机制。

   

   MAC 地址：我们将链路层地址称为 MAC 地址。并不是节点（即主机或路由器）具有 MAC 地址，而是节点的适配器具有链路层地址。

   对于大多数 LAN（包括以太网和 802.11 无线 LAN）而言，MAC 地址长度为 6 字节，共有 2^48 个可能的 LAN 地址。MAC 地址通常用十六进制表示法，地址的每个字节被表示为一对十六进制数。尽管 MAC 地址被设计成永久的，但现在用软件改变一块适配器的 MAC 地址是可能的。然而，对于本节的后面部分而言，我们将假设某适配器的 MAC 地址是固定的。

   

   MAC 广播地址（broadcast address）：对于使用 6 字节地址的 LAN（例如以太网和令牌传递 LAN）来说，广播地址是 48 个连续的 1 组成的字符串（即以十六进制表示法表示的 FF-FF-FF-FF-FF-FF）。

   

   地址解析协议

   因为存在网络层地址（如因特网的 IP 地址）和链路层地址（即 MAC 地址），所以需要在它们之间进行转换。对于因特网而言，这是地址解析协议（Address Resolution Protocol，ARP）的工作。

   

   ARP 将一个 IP 地址解析为一个 MAC 地址。在很多方面它和 DNS 类似，DNS 将主机名解析为 IP 地址。然而，这两种解析器之间的一个重要区别是，DNS 为在因特网中任何地方的主机解析主机名，而 ARP 只为在同一个子网上的节点解析 IP 地址。

   

   发送节点用 ARP 协议来解析一个 IP 地址时，首先发送节点构造一个称为 ARP 分组（ARP packet）的特殊分组。ARP 分组有几个字段，**包括发送节点和接收节点的 IP 地址和 MAC 地址**。ARP 查询和响应分组都具有相同的格式。ARP 查询分组的目的是询问子网上所有其他节点，以确定对应于要解析的 IP 地址的那个 MAC 地址。（**ARP 查询分组用 MAC 广播地址作为接收节点的 MAC 地址**。）



9. 以太网

   以太网几乎完全占领着现有的有线局域网市场。20 世纪 80 年代和 90 年代早期，以太网面临着来自其他 LAN 技术包括令牌环、FDDI 和 ATM 的挑战，但是自从 20 世纪 70 年代中期发明以太网以来，它就不断演化和发展，保持了它的支配地位。

   

   集线器（hub）是一种物理层设备，它作用于各个比特而不是作用于帧。当表示一个 0 或一个 1 的比特到达一个接口时，集线器只是重新生成这个比特，将其能量强度放大，并将该比特向其他所有接口传输出去。如果某集线器同时从不同的接口接收到帧，出现一次碰撞，生成该帧的节点必须重新传输该帧。

   

   在 21 世纪前期，以太网又经历了一次重要的革命性变革。以太网安装继续使用星型拓扑，但是位于中心的集线器被交换机（switch）所替代。交换机不仅是 “无碰撞的” ，而且也是名副其实的存储转发的分组交换机，但是与运行在下 3 层的路由器不同，交换机仅运行在下 2 层 。

   

   以太网帧结构

   <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/FrameofEthernet-fromTextbook.JPG" alt="FrameofEthernet-fromTextbook" style="zoom:80%;" />

   

   - 数据字段（data field）：46-1500 字节。这个字段承载了 IP 数据报，以太网的最大传输单元（MTU）是 1500 字节。这意味着如果 IP 数据报超过了 1500 字节，则主机必须将该数据报分段。数据字段的最小长度是 46 字节。这意味着如果 IP 数据报小于 46 字节，数据报必须被填充到 46 字节。当采用填充时，传递到网络层的数据包括 IP 数据和填充部分。网络层使用 IP 数据报首部中的长度字段来去除该填充。
   - 目的地址（destination address）：6 字节。这个字段包含目的适配器的 MAC 地址。当适配器 B 收到一个以太网帧，**它的帧目的地址无论是它自己的 MAC 地址，还是 MAC 广播地址，都将该帧的数据字段的内容传递给网络层**。如果它收到了具有任何其他 MAC 地址的帧，则丢弃之。
   - 源地址（source address）：6 字节。这个字段包含了传输该帧到 LAN 上的适配器的 MAC 地址。
   - 类型字段（type field）：2 字节。该类型字段允许以太网复用多种网络层协议。
   - 循环冗余检测（Cyclic Redundancy Check，CRC）：4 字节。
   - 前同步码（preamble）：8 字节。以太网帧以一个 8 字节的前同步码字段开始，该前同步码的前 7 个字节的值都是 10101010 ，最后一个字节是 10101011 。前同步码字段的前 7 个字节用于 “唤醒” 接收适配器，并且将它们的时钟和发送方的时钟同步。

   &nbsp;

   许多以太网技术（例如 10BASE-T）也使用曼彻斯特（Manchester）编码。采用曼彻斯特编码，每个比特包含一次跳变，从高电平跳变为低电平为 1，而从低电平跳变为高电平为 0。使用曼彻斯特编码的原因是发送适配器和接收适配器的时钟没有精确同步。通过在每个比特的中间包含一次跳变，接收主机能够将它的时钟与发送主机的时钟同步。曼彻斯特编码是一种物理层的操作，而不是链路层的操作。然而，我们在这里简要地描述它，是因为它广泛地应用于以太网中。

   

   所有的以太网技术都向网络层提供无连接服务（connectionsless service）。

   所有的以太网技术都向网络层提供了不可靠服务（unreliable service）。特别是，当适配器 B 收到一个来自适配器 A 的帧，它对该帧进行 CRC 校验，但是当该帧通过 CRC 校验时，它不发送确认帧，而当该帧没有通过 CRC 校验时，它也不发送否认帧。当某帧没有通过 CRC 校验，适配器 B 只是丢弃该帧。

   

   今天的以太网与 Metcalfe 和 Boggs 在 30 多年前构想的初始以太网有了非常大的不同，然而的确还有一个经历 30 多年保持不变的东西，即以太网帧格式。也许这才是以太网标准的一个真正重要的特征。



10. 链路层交换机

    交换机的过滤和转发借助于交换机表（switch table）完成。

    交换机是自学习（self-learning）的。

    

    链路层使用交换机的几个优点：

    - 消除碰撞。在使用交换机（不使用集线器）构建的 LAN 中，没有因碰撞而浪费的带宽。交换机缓存帧并且绝不会在网段上同时传输多于一个帧。就像使用路由器一样，交换机的最大聚合带宽是该交换机所有接口速率之和。
    - 异质的链路。因为交换机将链路彼此相隔离，LAN 中的不同链路能够以不同的速率运行，并且能够在不同的媒体上运行。
    - 管理。除了提供强化的安全性，交换机也易于进行网络管理。

    &nbsp;

    嗅探交换 LAN：交换机毒化

    它向交换机发送大量的具有不同伪造源 MAC 地址的分组，因而用伪造表项填满了交换机表，没有为合法节点留下空间。这使得该交换机广播大多数帧，这些帧则能够由嗅探器所俘获到。由于这种攻击只有技艺高超的攻击者才能做到，因此交换机比集线器和无线 LAN 更难以受到嗅探。

    

    交换机和路由器的比较

    路由器是使用网络层地址转发分组的存储转发分组交换机。尽管交换机也是一个存储转发分组交换机，但它和路由器是根本不同的，**因为它用 MAC 地址转发分组。交换机是在第二层的分组交换机，而路由器是第三层的分组交换机**。

    

    给定交换机和路由器都是候选的互联设备，这两种方式的优点和缺点各是什么呢？

    - 交换机是即插即用的，这是所有网络管理员都喜爱的特性。
    - 交换机还能够具有相对高的分组过滤和转发速率。交换机必须处理最高仅为第二层的帧，而路由器必须处理最高为第三层的数据报。
    - 在另一方面，为了防止广播帧的循环，交换网络的活跃拓扑限制为一颗生成树。
    - 还有，大型交换网络要求在该节点有大的 ARP 表，这将生成可观的 ARP 流量和处理量。
    - 此外，交换机对于广播风暴并不提供任何保护措施，即如果某主机出了故障并传输出没完没了的以太网广播帧流，该交换机将转发所有这些帧，使得整个以太网崩溃。

    &nbsp;

    现在考虑路由器的优点和缺点。
    
    - 因为网络寻址通常是分层次的（不像 MAC 寻址那样是扁平的），即使当网络中存在冗余路径，分组通常也不会通过路由器循环。（然而，当路由器表被误配置时，分组能够循环；但是如我们在第 4 章所学的那样，IP 用一个特殊的报文首部字段来限制循环。）所以，分组就不会被限制到一颗生成树上，并可以使用源与目的之间的最佳路径。
    - 因为路由器没有生成树限制，所以它们能用各种拓扑结构来构建因特网，例如包括欧洲和北美之间的多条活跃链路。
    - 路由器的另一个特色是它们对第二层的广播风暴提供了防火墙保护。
    - 尽管也许路由器最重要的缺点就是它们不是即插即用的，即路由器和连接到它们的主机都需要人为地配置 IP 地址。
- 而且路由器对每个分组的处理时间通常比交换机更长，因为它们必须处理最高达第三层的字段。
    - 最后路由器一词有两种不同的发音方法，或者发音为 “rootor” ，或者发音为 “rowter” ，人们浪费了许多时间争论正确的发音 [Perlman 1999]。

    &nbsp;
    
    通常，由几百台主机组成的小网络一般会有几个 LAN 网段，对于这些小网络，交换机就足够了，因为它们不要求 IP 地址的任何配置就能使流量局部化并增加总计吞吐量。但是在由几千台主机组成的更大网络中，除了交换机之外还包括路由器。路由器提供了更健壮的流量隔离方式和对广播风暴的控制，并在网络的主机之间使用更 “智能的” 路由。



11. PPP：点对点协议

    通常是住宅主机拨号链路所选择的协议。





## 第 8 章 计算机网络中的安全

1. 什么是网络安全

   安全通信（secure communication）具有下列所需要的特性：

   - 机密性（confidentiality）
   - 报文完整性（message intergrity）
   - 端点鉴别（end-point authentication）
   - 运行安全性（operational security）
   
   &nbsp;

2. 密码学的使用在提供机密性方面是不言而喻的，我们很快看到它对提供端点鉴别、报文完整性也起到了核心作用，这使得密码学成为网络安全的基石。

   密码学的原则

   明文（plaintext, cleartext）；加密算法（encryption algorithm）；密文（ciphertext）；

   密钥（key）；解密算法（decryption algorithm）；

   

   密码学组成部分：

   <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/TheComponentsOfCryptography.JPG" alt="TheComponentsOfCryptography" style="zoom:67%;" />

   

   在对称密钥系统（symmetric key system）中，Alice 和 Bob 的密钥是相同的并且秘密的。

   在公钥系统（public key system）中，使用一对密钥，一个密钥为 Bob 和 Alice 俩人所知（实际上，它为全世界所知）。另一个密钥只有 Bob 或 Alice 知道（而不是双方都知道）。

   

   对称密钥密码学

   所有密码算法都包含用一种东西替换另一种东西的思想。

   

   公开密钥密码系统有许多很好的特性，使得它不仅可以用于加密，还可以用于鉴别和数字签名。

   

   公开密钥加密

   公钥（public key）；私钥（private key）。

   公开密钥密码：

   <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/public-keyCryptography-fromTextbook.JPG" alt="public-keyCryptography-fromTextbook" style="zoom:70%;" />

   

   RSA（RSA algorithm，取创立人 Ron Rivest、Adi Shamir 和 Leonard Adleman 的首字母命名）算法几乎已经成了公开密钥密码的代名词。

   

   会话密钥

   需要指出的是，RSA 所要求的指数运算过程是相当耗费时间的。在实际应用中 RSA 通常和对称密钥密码结合使用。

   例如，如果 Alice 要发送大量已加密数据给 Bob，她可以用下面的方式。首先，Alice 选择一个用于加密数据本身的密钥，**这个密钥有时称为会话密钥（session key）K_s**。Alice 必须把这个会话密钥告知 Bob，因为这是他们用于对称密钥密码（如 DES 或 AES）的共享对称密钥。然后 Alice 可以使用 Bob 的 RSA 公钥加密该会话密钥，Bob 收到 RSA 加密的会话密钥后，解密得到会话密钥 K_s 。此时 Bob 已经知道了 Alice 将要用做加密传输的会话密钥了。



3. 报文完整性（message integrity）

   **报文完整性和数字签名的共有部分是密码散列函数（crytographic hash function）**。

   

   散列函数以 m 为输入，经过计算得到一个称为散列的固定长度的字符串。一个密码散列函数要求具有下列附加性质：

   - 找到任意两个不同的报文 x 和 y 使得 H(x) = H(y)，在计算上是不可能的。

   &nbsp;

   为了执行报文的完整性，除了使用密码散列函数，Alice 和 Bob 还需要共享秘密 s 。这个共享的秘密只不过是一个比特串，称为**鉴别密钥（authentication key）**。使用这个共享秘密，报文完整性执行如下：

   1. Alice 生成报文 m，用 s 级联 m 生成 m+s，并计算散列 H(m+s)（例如用 SHA-1）。H(m+s) 被称为**报文鉴别码（Message Authentication Code，MAC）**。
   2. 然后 Alice 将 MAC 附加到报文 m 上，生成扩展报文（m，H(m+s)），并将该扩展报文发送给 Bob。
   3. Bob 接收到一个扩展报文（m，h），并且（已经知道 s）计算 MAC H(m+s)，如果 H(m+s) = h，Bob 得到结论：一切正常。

   &nbsp;

   MAC 的一个优良特点是它不需要加密算法。

   

   数字签名（digital signature）

   公钥密钥是一种用于提供数字签名的优秀候选者，我们现在来研究一下这是怎么完成的。

   

   假设 Bob 要以数字方式签署一个文档 m ，我们可以认为这个文档是 Bob 打算签署并发送的一个文件或报文，要签署这个文档，Bob 直接使用他的私钥 K~_B~ 计算 K~_B~(m)。此处 Bob 的目的不是弄乱或掩盖文档的内容，而只是要以能鉴别、不可伪造的方式签署这个文档。Bob 对文档 m 签名之后所得的文档就是 K~_B~(m)。

   假设 Alice 有 m 和 K~_B~(m)，她要在法庭上证明 Bob 确实签署过这个文档。Alice 持有 Bob 的公钥，并把它作用于 Bob 的数字签名 K~_B~(m) 上，如果能得到 m ，那么 Alice 就可以论证仅有 Bob 能够签署过这个文档。

   

   数字签名也提供完整性，使得接收方验证该报文未被篡改。

   

   用加密对数据进行签名所担心的是，加密和解密的计算代价昂贵，更有效的方法是将散列函数引入数字签名。一种散列算法是取一个任意长的报文 m ，计算生成该报文的一个固定长度的数据 “指纹” ，表示为 H(m) 。

   使用散列函数，Bob 对报文的散列签名而不是对报文本身进行签名，即 Bob 计算 K~_B~(H(m))，因为 H(m) 通常比报文 m 小得多，生成数字签名所需要的计算量大为降低。

   

   公钥认证

   数字签名的一个重要应用是公钥认证（public key certification），即证实一个公钥属于某个特定的实体。公钥认证用于许多流行的安全网络协议中，包括 IPsec 和 SSL 。

   

   将公钥与特定实体绑定通常是由认证中心（Certification Authority，CA）完成的，CA 的职责就是验证身份和发行证书。

   CA 具有下列作用：

   - CA 证实一个实体（一个人、一台路由器等）的真实身份。如何进行认证并没有强制的过程。当与一个 CA 打交道时，一方必须信任这个 CA 能够执行适当的严格身份验证。
   - 一旦 CA 验证了某个实体的身份，这个 CA 生成了一个把其身份和实体的公钥绑定起来的证书（certificate）。这个证书包含这个公钥和公钥所有者全局唯一的身份标识信息（例如，一个人的名字或一个 IP 地址）。由 CA 对这个证书进行数字签名。

   &nbsp;

   我们现在来看如何通过认证来对抗 “比萨订购” 中的恶作剧（如 Trudy）和其他意外情况。当 Bob 下了他的订单时，他也发送了他的 CA 签署的证书。Alice 使用 CA 的公钥来核对 Bob 证书的合法性并提取 Bob 的公钥。



4. 鉴别

   端点鉴别（end-point authentication）就是向其他人证明一个人身份的过程。

   鉴别协议（authentication protocol）

   

   不重数（nonce）是在一个协议的生存期中只使用一次的一个数。也就是说，一旦某协议使用了一个不重数，就永远不会再使用那个数字了。

   

   中间人攻击（man-in-the-middle attack），有时也称为救火水桶接力攻击（bucket-brigade attack），因为 Trudy 在 Alice 和 Bob 之间传递数据，就像一队人从远处的水源传递水桶灭火一样。



5. 电子邮件安全

   在前面各节中我们分析了网络安全中的基本问题，包括**对称密钥和公开密钥密码学、端点鉴别、密钥分发、报文完整性和数字签名**。我们现在着手研究如何使用这些工具在因特网中提供安全性。有趣的是，可以为因特网协议栈上面 4 层的任一层提供安全性服务。

   当为某一特定应用层协议提供安全性时，则使用这一协议的应用程序将能使用一种或多种安全服务，比如机密性、鉴别或完整性。当为某一运输层协议提供安全性时，则所有使用这一协议的应用程序都可以使用到该运输层协议所提供的安全性服务。在基于主机到主机的网络层提供安全性时，则所有运输层报文段（当然也包括所有应用层数据）都可以享用该网络层所提供的安全服务。当基于一条链路提供安全性时，则所有经过这个链路传输的帧中的数据都得到了为该链路提供的安全性服务。

   

   在 8.5 ~ 8.8 节中，我们研究如何在应用层、运输层、网络层和数据链路层中使用这些安全性工具。为了与本书的整体框架保持一致，我们从协议栈的顶层开始，讨论应用层的安全性。此处我们的方法是使用特定的应用程序即电子邮件，作为应用层安全性的一个案例来研究。然后我们沿协议栈向下，分析 SSL 协议（该协议在运输层提供安全性），IPsec 协议（它在网络层提供了安全性），以及 IEEE 802.11 无线局域网协议的安全性。

   

   PGP（Pretty Good Privacy），它提供了安全的电子邮件，由于只需要客户机和服务器应用程序代码，PGP 是第一个在因特网上得到广泛应用的安全性技术。



6. 使 TCP 连接安全：SSL

   在这一节中我们研究如何使用密码技术来加强 TCP 安全服务，包括机密性、数据完整性和端点鉴别。TCP 的这种强化版本通常被称为安全套接字层（Secure Socket Layer，SSL）。SSL 版本 3 的稍加修改的版本称为运输层安全性（Transport Layer Security，TLS），已经被 IETF 标准化了 [RFC 2246] 。

   

   SSL 通过采用机密性、数据完整性、服务器鉴别和客户机鉴别来强化 TCP，从而处理这些问题。

   SSL 经常用于为发生在 HTTP 之上的事务提供安全性。然而，因为 SSL 使 TCP 安全了，因此它能被应用于运行在 TCP 之上的任何应用程序。SSL 提供了一个简单的具有套接字的应用编程接口（API），该接口类似于 TCP 的 API。当一个应用程序要使用 SSL 时，该应用程序包括为应用程序研发者提供 SSL 套接字接口的 SSL 类/库。

   尽管 SSL 技术上位于应用层中，但从研发者的角度看它是运输层协议：

   <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/SSL-BeViewedAsATransportLayerProtocol.JPG" alt="SSL-BeViewedAsATransportLayerProtocol" style="zoom:67%;" />

   

   宏观描述：

   我们从描述一个简化的 SSL 版本开始，这将使我们从宏观上理解 SSL 的工作原理和工作过程。我们将这个 SSL 的简化版本称之为 “类 SSL” 。描述过类 SSL 之后，在下一小节中我们将详细描述真实的 SSL 。类 SSL（和 SSL）具有三个阶段：握手，密钥导出和数据传输。

   

   SSL 记录：该记录是由类型字段、版本字段、长度字段、数据字段和 MAC 字段组成。注意到前三个字段是不加密的。类型字段指出该字段是握手报文还是包含应用数据的报文，它也用于关闭 SSL 连接。在接收端的 SSL 使用长度字段以从到达的 TCP 字节流中提取 SSL 记录。版本字段是自解释的。

   <img src="https://gitee.com/haokaimo/Picture/raw/master/ComputerNetworks/TheSSLRecordFormat.JPG" alt="TheSSLRecordFormat" style="zoom:67%;" />



7. 网络层安全：IPsec

   IP 安全（IP Security）协议更常被称为 IPsec，它是为网络层提供安全性的一组协议。如第 4 章所述，IPsec 处于大多数虚拟专用网（VPN）的核心位置。IPsec 相当复杂，10 多个 RFC 文档对它的不同部分分别进行了描述。在本节中，我们在特定的环境下讨论 IPsec，即其中的两台通信的主机都装备了 IPsec 。

   

   在网络层提供安全性意味着什么？
   
   - 首先考虑提供网络层机密性（network-layer confidentiality）是什么含义。如果由 IP 数据报携带的所有有效载荷都被加密了，则该网络层将提供机密性。**原则上这种加密可用对称密钥密码、公钥密码或者通过公钥密码协商的会话密钥加密完成。该有效载荷可能是一个 TCP 报文段、一个 UDP 报文段或一个 ICMP 报文等**。
   - 除了机密性，我们也需要网络层提供源鉴别（source authentication）。当目的主机接收一个有特定 IP 源地址的 IP 数据报时，它通过判断这个 IP 数据报是否确实由具有这个特定 IP 源地址的主机生成而进行源鉴别。这种服务可防止 IP 地址哄骗。

   &nbsp;

   在 IPsec 协议族中有两个主要协议：
   
   - 鉴别首部协议（Authentication Header (AH) protocol）
   - 封装安全性载荷协议（Encapsulation Security Payload (ESP) protocol）。

   &nbsp;

   当源主机向目的主机发送安全数据报时，可以使用 AH 协议或 ESP 协议。AH 协议提供源鉴别和数据性服务，但是不提供机密性服务。ESP 协议提供鉴别、数据完整性和机密性服务。因为 ESP 协议提供了更多的服务，所以它比 AH 协议更复杂，也需要进行更多的处理。
   
   
   
   在 AH 和 ESP 这两个协议中，在从源主机向目的主机发送安全数据报之前，源主机和网络主机握手并创建了一个网络层的逻辑连接。这个逻辑连接通道称为安全关联（Security Association，SA）。因此，**IPsec 把因特网传统的无连接网络层转化成了一个具有逻辑连接的层**。这个由一个 SA 定义的逻辑连接是一个**单工连接，也就是说它是单向的。如果两台主机间要相互发送安全数据报，则需要创建两个 SA，每个方向一个**。



8. 使无线 LAN 安全

   在无线网络中，安全性是特别重要的考虑因素，因为这时携带数据帧的无线电波可以传播到远离包含无线基站和主机的建筑物以外的地方。在本节中，我们对无线安全性做了简要介绍。



9. 运行安全性：防火墙和入侵检测系统

   在许多机构中，从中世纪的城堡到现代化公司的建筑物，都有单一的出口/入口点，无论好人坏人出入该机构，都需要进行安全检查。在一个城堡中，可以在吊桥的一端的门口执行安全检查；在公司大厦中，这些工作可由安全台来完成。在计算机网络中，当通信流量进入/离开网络时要执行安全检查，被记录、丢弃和/或转发，这些工作都由称为防火墙、入侵检测系统（IDS）和入侵防止系统（IPS）的运行设备完成。

   

   防火墙（firewall）是一个硬件和软件的结合体，它将一个机构的内部网络与整个因特网隔离开，允许一些数据分组通过而阻止另一些通过。防火墙允许网络管理员控制外部世界和被管理网络内部资源之间的访问，这种控制是通过管理流入和流出这些资源的流量实现的。

   

   防火墙能够分为 3 类：传统的分组过滤器（traditional packet filter）、状态过滤器（stateful filter）、和应用程序级网关（application-level gateway）。

   

   传统的分组过滤器

   一个机构通常都有一个将其内部网络与其 ISP 相连的网关路由器，并因此与更大的公共因特网相连。所有离开和进入内容部网络的流量都要经过这个路由器，而这个路由器正是出现分组过滤（packet filtering）的地方。

   

   对于某机构网络 130.207/16，且 Web 服务器在 130.207.244.203，对应的过滤规则和策略：

   策略 | 防火墙设置
   ------ | -------
   无外部 Web 访问 | 丢弃所有到任何 IP 地址端口 80 的出分组
   无 TCP 连接，但只访问机构公共 Web 服务器那些分组除外 | 丢弃所有到任何 IP 的入 TCP SYN 分组，但到 130.207.244.203 端口 80 的除外
   防止 Web 无线电占据可用带宽 | 丢弃所有入 UDP 分组，但 DNS 分组除外
   防止你的网络被用于一个 smurf DoS 攻击 | 丢弃所有去往某 “广播” 地址（如 130.207.255.255）的 ICMP ping 分组
   防止你的网络被跟踪路由 | 丢弃所有 ICMP TTL 过期的出流量

   

   状态分组过滤器

   在传统的分组过滤器中，根据每个分组独立作出过滤决定。状态过滤器实际跟踪 TCP 连接，并使用这种知识作出过滤决定。

   

   应用程序网关

   为了得到更高水平的安全性，防火墙必须把分组过滤器和应用程序网关结合起来。应用程序网关基于应用数据来看待 IP/TCP/UDP 报头，并作策略决定。**一个应用程序网关（application gateway）是一个应用程序特定的服务器，所有应用程序数据（入和出的）都必须通过应用程序网关**。多个应用程序网关可以在同一主机上运行，但是每一个网关都是具有其单独进程的单独服务器。

   
   
   入侵检测系统
   
   能够观察到潜在恶意流量并产生告警的设备称为**入侵检测系统（Intrusion Detection System，IDS）**。滤除可疑流量的设备称为**入侵防止系统（Intrusion Prevention System, IPS）**。在本节中我们一起研究 IDS 和 IPS 这两种系统，**因为这些系统的最有意思的技术方面是它们如何检测可疑流量（而不是它们发送警告还是丢弃分组）。我们因此将 IDS 系统和 IPS 系统统称为 IDS 系统**。
   
   
   
   IDS系统大致可分类为基于特征的系统（signature-based system）或基于异常的系统（anomaly-based system）。
   
   
   
   虽然广泛地部署了基于特征的 IDS 系统，但仍有一些限制。更重要的是，它们要求根据攻击的以前知识来产生一个准确的特性。换言之，基于特征的 IDS 对将被记录的新攻击完全缺乏判断力。另一个缺点是即使与一个特征匹配，它也可能不是一个攻击，因此产生了一个虚假告警。最后，因为每个分组必须与范围广泛的特征集合相比较，IDS 可能处于处理过载状态并因此难以检测出许多恶意分组。
   
   当基于异常的 IDS 观察正常运行的流量时，它会生成一个流量概况文件。然后，它寻找统计上不寻常的分组流，例如，ICMP 分组过度的百分比，或端口扫描和 ping 扫描导致的突然的指数增长。有关基于异常的 IDS 系统的最大特点时它们不依赖有关现有攻击的以前知识。另一方面，区分正常流量和统计异常流量是一个极具挑战性的问题。至今为止，大多数部署的 IDS主要是基于特征的，尽管某些 IDS 包括了某些基于异常的特征。



&nbsp;

&nbsp;

> **版权声明：本文采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh) 许可协议，若转载请注明出处**。